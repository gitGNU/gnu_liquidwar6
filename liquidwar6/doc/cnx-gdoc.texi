@deftypefun {void} {lw6cnx_backlog_zero} (lw6cnx_backlog_t * @var{backlog})
@var{backlog}:  struct to initialize

Fills the struct with zeros, ignoring what was in there before

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6cnx_backlog_reset} (lw6cnx_backlog_t * @var{backlog})
@var{backlog}:  struct to reset

Resets the structure, freeing any ressource it was holding.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6cnx_backlog_push} (lw6cnx_backlog_t * @var{backlog}, char * @var{str})
@var{backlog}:  struct to add stuff to

@var{str}:  string to add

Adds a string to the backlog. Be careful, the function will not duplicate
the string but assume it's been dynamically allocated, and will free it
when it's done with it.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6cnx_backlog_filter} (lw6cnx_backlog_t * @var{backlog}, lw6cnx_backlog_filter_func_t @var{func}, lw6cnx_backlog_filter_data_t * @var{func_data})
@var{backlog}:  struct to filter

@var{func}:  function used for filter

@var{func_data}:  additionnal data passed to function

Filters the internal backlog list, the filter function, as standard list
filter funcs, should return 1 if the record is to be kept, and 0 if it
must be deleted, typically because it finally has been sent.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {lw6cnx_connection_t *} {lw6cnx_connection_new} (const char * @var{local_url}, const char * @var{remote_url}, const char * @var{remote_ip}, int @var{remote_port}, const char * @var{password}, u_int64_t @var{local_id}, u_int64_t @var{remote_id}, int @var{dns_ok}, int @var{network_reliability}, lw6cnx_recv_callback_t @var{recv_callback_func}, void * @var{recv_callback_data})
@var{local_url}:  the local public URL

@var{remote_url}:  the remote public URL

@var{remote_ip}:  the remote IP address

@var{remote_port}:  the remote port

@var{password}:  the password to use

@var{local_id}:  the local ID

@var{remote_id}:  the remote ID

@var{dns_ok}:  1 if no DNS mismatch, 0 if IP does not match public URL

@var{network_reliability}:  drop 1 out of X packets

@var{recv_callback_func}:  a callback to call when data is received

@var{recv_callback_data}:  additionnal data to pass to the callback

Create a connection object. This object in itself does
nothing, it's just to share common structures among
modules, more precisely, between cli and srv code.
It's the responsability off the caller/backend to handle
the @code{backend_specific_data} field which is NULL after this
call.

@strong{Return value:}  newly allocated object.
@end deftypefun

@deftypefun {void} {lw6cnx_connection_free} (lw6cnx_connection_t * @var{connection})
@var{connection}:  object to free

Frees a connection object. It's the responsibility of
the caller/backend to handle the @code{backend_specific_data} field.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_connection_should_send_foo} (lw6cnx_connection_t * @var{connection}, int64_t @var{now})
@var{connection}:  the connection concerned

@var{now}:  the current timestamp

Tells wether a new foo message must be issued.

@strong{Return value:}  1 if true, 0 if false.
@end deftypefun

@deftypefun {void} {lw6cnx_connection_init_foo_bar_key} (lw6cnx_connection_t * @var{connection}, int64_t @var{now}, int @var{next_foo_delay})
@var{connection}:  the connection concerned

@var{now}:  the current timestamp

@var{next_foo_delay}:  the delay (msec) before next foo message is sent

Generates a new foo_bar_key, and schedules the next foo message send timestamp.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_connection_lock_send} (lw6cnx_connection_t * @var{connection})
@var{connection}:  the connexion to lock

Acquires a "send" lock on the connexion, the idea is to avoid
too threads sending data using the same socket at the same time.
Note that each backend must call this when accessing the socket,
there's no top-level lock for the sake of performance.

@strong{Return value:}  1 on success, 0 if not.
@end deftypefun

@deftypefun {void} {lw6cnx_connection_unlock_send} (lw6cnx_connection_t * @var{connection})
@var{connection}:  the connexion to lock

Releases a "send" lock on the connexion, the idea is to avoid
too threads sending data using the same socket at the same time.
Note that each backend must call this when accessing the socket,
there's no top-level lock for the sake of performance.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_connection_reliability_filter} (lw6cnx_connection_t * @var{connection})
@var{connection}:  the connexion concerned

Will filter and return true only in "rare" cases when packets
must be artificially dropped for testing purpose.

@strong{Return value:}  1 if message must be sent/received, 0 if not
@end deftypefun

@deftypefun {char *} {lw6cnx_password_checksum} (const char * @var{seed}, const char * @var{password})
@var{seed}:  a seed to blur the password, can be NULL

@var{password}:  the password, can be NULL

Calculates the checksum of a password, and returns
it as a string, ready to be sent on the network.
If password is empty or NULL, then an empty (but
not NULL unless internal error) string will be
returned. All LW6 protocols should send
these checksums instead of real passwords, then
on server side value can be checked against both
real password and its checksum. The seed is here
so that eavesdropper can't reuse the checksum to
connect on random sessions. Seed can typically
be the node 'public_url' value.

@strong{Return value:}  a dynamically allocated string
@end deftypefun

@deftypefun {int} {lw6cnx_password_verify} (const char * @var{seed}, const char * @var{password_here}, const char * @var{password_received})
@var{seed}:  a seed to blur the password, can be NULL

@var{password_here}:  the local password, can be NULL

@var{password_received}:  the password received from network, can be NULL

Tells wether a password received over the network is valid.
The @code{password_here} argument (the local password) will be
checksumed so that @code{password_received} is checked against both
clear and checksumed values, so it can be in any form.

@strong{Return value:}  1 if OK, passwords are the same, 0 if not.
@end deftypefun

@deftypefun {int} {lw6cnx_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{cnx} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_zero} (lw6cnx_ticket_table_t * @var{ticket_table})
@var{ticket_table}:  the ticket table to fill with zero

Fills the ticket table struct with 0s.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_ticket_table_init} (lw6cnx_ticket_table_t * @var{ticket_table}, int @var{hash_size})
@var{ticket_table}:  the ticket table to init

@var{hash_size}:  the hash size for both recv/send hashs

Initialize a ticket table, that is, set it up with two
empty hashs. Recv hash is filled automatically as it's queried
for tickets, send hash must be filled explicitely with info 
from the network.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_clear} (lw6cnx_ticket_table_t * @var{ticket_table})
@var{ticket_table}:  the ticket table to clear

Clears the object (frees memory).

@strong{Return value:}  none.
@end deftypefun

@deftypefun {u_int64_t} {lw6cnx_ticket_table_get_recv} (lw6cnx_ticket_table_t * @var{ticket_table}, const char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Gets the ticket used to communicate with peer, to check its incoming
(recv) messages. If ticket does not exist yet, it's automatically
generated so tunction will always return a non-zero value.

@strong{Return value:}  the ticket used to check incoming messages.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_ack_recv} (lw6cnx_ticket_table_t * @var{ticket_table}, const char * @var{peer_id}, int @var{ack_delay_msec})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

@var{ack_delay_msec}:  delay before which we'll consider the ticket as really received

Acknowledges the ticket used to communicate with peer, to check its incoming
(recv) messages has been received. This is to avoid sending it again when
it has been received, as it's kept "forever" by peer, we never need to
send it again. The delay is here to avoid checking tickets too quickly,
for instance one could have sent the ticket yet, but for some reason some
unsigned messages are still in the pipe, typically they transit through
another slow channel such as httpd while the ticket was sent on udp.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_ticket_table_was_recv_exchanged} (lw6cnx_ticket_table_t * @var{ticket_table}, const char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Acknowledges the ticket used to communicate with peer, to check its incoming
(recv) messages has been received. This is to avoid sending it again when
it has been received, as it's kept "forever" by peer, we never need to
send it again.

@strong{Return value:}  the ticket used to check incoming messages.
@end deftypefun

@deftypefun {u_int64_t} {lw6cnx_ticket_table_get_send} (lw6cnx_ticket_table_t * @var{ticket_table}, const char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Gets the ticket used to communicate with peer, to stamp the outgoing
messages. If ticket does not exist yet, 0 is returned, indeed this value
must be initialized with the value the peer gives us.

@strong{Return value:}  the ticket used to stamp outgoing messages.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_set_send} (lw6cnx_ticket_table_t * @var{ticket_table}, const char * @var{peer_id}, u_int64_t @var{send_ticket})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

@var{send_ticket}:  the ticket to use to stamp outgoing messages

Sets the ticket used to communicate with peer, to stamp the outgoing (send)
messages. This value should be received from the network. Note that
once it's set, it's impossible to change it, it will remain the same
for the whole duration of the node existence.

@strong{Return value:}  NULL
@end deftypefun

