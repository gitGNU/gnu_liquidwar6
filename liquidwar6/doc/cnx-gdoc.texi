@deftypefun {lw6cnx_connection_t *} {lw6cnx_connection_new} (char * @var{local_url}, char * @var{remote_url}, char * @var{remote_ip}, int @var{remote_port}, char * @var{password}, u_int64_t @var{local_id}, u_int64_t @var{remote_id}, lw6cnx_recv_callback_t @var{recv_callback_func}, void * @var{recv_callback_data})
@var{local_url}:  the local public URL

@var{remote_url}:  the remote public URL

@var{remote_ip}:  the remote IP address

@var{remote_port}:  the remote port

@var{password}:  the password to use

@var{local_id}:  the local ID

@var{remote_id}:  the remote ID

@var{recv_callback_func}:  a callback to call when data is received

@var{recv_callback_data}:  additionnal data to pass to the callback

Create a connection object. This object in itself does
nothing, it's just to share common structures among
modules, more precisely, between cli and srv code.
It's the responsability off the caller/backend to handle
the @code{backend_specific_data} field which is NULL after this
call.

@strong{Return value:}  newly allocated object.
@end deftypefun

@deftypefun {void} {lw6cnx_connection_free} (lw6cnx_connection_t * @var{connection})
@var{connection}:  object to free

Frees a connection object. It's the responsibility of
the caller/backend to handle the @code{backend_specific_data} field.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_connection_should_send_foo} (lw6cnx_connection_t * @var{connection}, int64_t @var{now})
@var{connection}:  the connection concerned

@var{now}:  the current timestamp

Tells wether a new foo message must be issued.

@strong{Return value:}  1 if true, 0 if false.
@end deftypefun

@deftypefun {void} {lw6cnx_connection_init_foo_bar_key} (lw6cnx_connection_t * @var{connection}, int64_t @var{now}, int @var{next_foo_delay})
@var{connection}:  the connection concerned

@var{now}:  the current timestamp

@var{next_foo_delay}:  the delay (msec) before next foo message is sent

Generates a new foo_bar_key, and schedules the next foo message send timestamp.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{cnx} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_zero} (lw6cnx_ticket_table_t * @var{ticket_table})
@var{ticket_table}:  the ticket table to fill with zero

Fills the ticket table struct with 0s.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_ticket_table_init} (lw6cnx_ticket_table_t * @var{ticket_table}, int @var{hash_size})
@var{ticket_table}:  the ticket table to init

@var{hash_size}:  the hash size for both recv/send hashs

Initialize a ticket table, that is, set it up with two
empty hashs. Recv hash is filled automatically as it's queried
for tickets, send hash must be filled explicitely with info 
from the network.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_clear} (lw6cnx_ticket_table_t * @var{ticket_table})
@var{ticket_table}:  the ticket table to clear

Clears the object (frees memory).

@strong{Return value:}  none.
@end deftypefun

@deftypefun {u_int32_t} {lw6cnx_ticket_table_get_recv} (lw6cnx_ticket_table_t * @var{ticket_table}, char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Gets the ticket used to communicate with peer, to check its incoming
(recv) messages. If ticket does not exist yet, it's automatically
generated so tunction will always return a non-zero value.

@strong{Return value:}  the ticket used to check incoming messages.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_ack_recv} (lw6cnx_ticket_table_t * @var{ticket_table}, char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Acknowledges the ticket used to communicate with peer, to check its incoming
(recv) messages has been received. This is to avoid sending it again when
it has been received, as it's kept "forever" by peer, we never need to
send it again.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6cnx_ticket_table_was_recv_exchanged} (lw6cnx_ticket_table_t * @var{ticket_table}, char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Acknowledges the ticket used to communicate with peer, to check its incoming
(recv) messages has been received. This is to avoid sending it again when
it has been received, as it's kept "forever" by peer, we never need to
send it again.

@strong{Return value:}  the ticket used to check incoming messages.
@end deftypefun

@deftypefun {u_int32_t} {lw6cnx_ticket_table_get_send} (lw6cnx_ticket_table_t * @var{ticket_table}, char * @var{peer_id})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

Gets the ticket used to communicate with peer, to stamp the outgoing
messages. If ticket does not exist yet, 0 is returned, indeed this value
must be initialized with the value the peer gives us.

@strong{Return value:}  the ticket used to stamp outgoing messages.
@end deftypefun

@deftypefun {void} {lw6cnx_ticket_table_set_send} (lw6cnx_ticket_table_t * @var{ticket_table}, char * @var{peer_id}, u_int32_t @var{send_ticket})
@var{ticket_table}:  the ticket table to query

@var{peer_id}:  the id of remote node

@var{send_ticket}:  the ticket to use to stamp outgoing messages

Sets the ticket used to communicate with peer, to stamp the outgoing (send)
messages. This value should be received from the network. Note that
once it's set, it's impossible to change it, it will remain the same
for the whole duration of the node existence.

@strong{Return value:}  NULL
@end deftypefun

