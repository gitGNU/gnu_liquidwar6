

  
@deftp {Struct} {lw6dyn_dl_handle_s}

    
Handle on dynamic library. Well, actually, ltdl does already provide something like, so why use our own wrapper? It happens storing the library path, that's to say what .so files it comes from, is usefull for debugging, so this structure bundles those two informations together.     
@end deftp

@defcv {Member} {lw6dyn_dl_handle_s} {handle}
@strong{Type:} @code{lt_dlhandle}

@strong{Definition:} @code{lt_dlhandle lw6dyn_dl_handle_s::handle}


Libtool handler.         
        
@end defcv

@defcv {Member} {lw6dyn_dl_handle_s} {library_path}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6dyn_dl_handle_s::library_path}


        
Path to .so file containing the code, or whatever file is relevant on the current platform, the idea is to keep track of where the library comes from.         
@end defcv

@defcv {Member} {lw6dyn_dl_handle_s} {is_backend}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6dyn_dl_handle_s::is_backend}


        
True (1) if the handle is a backend or false (0) if it's just some shared code.         
@end defcv


