@deftypefun {void} {lw6map_body_builtin_custom} (lw6map_body_t * @var{body}, int @var{w}, int @var{h}, int @var{d}, int @var{noise_percent}, lw6map_rules_t * @var{rules})
@var{body}:  the body to initialize

@var{w}:  the width

@var{h}:  the height

@var{d}:  the depth

@var{noise_percent}:  the noise level to fill meta layers with

@var{rules}:  the map rules

Sets up a default body structure.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_body_clear} (lw6map_body_t * @var{body})
@var{body}:  the structure to clear

Clears a body structure.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_body_fix_checksum} (lw6map_body_t * @var{body})
@var{body}:  the structure to update

Updates (calculates) the checksum of a map body structure.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_body_check_and_fix_holes} (lw6map_body_t * @var{body}, lw6map_rules_t * @var{rules})
@var{body}:  the structure to update

@var{rules}:  the game rules

This (fundamental) function ensures that all playable areas in a map
are connected. If isolated zones are found out, then they are marked
as walls and not used any more.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_body_coord_from_texture} (lw6map_level_t * @var{level}, int * @var{body_x}, int * @var{body_y}, int @var{texture_x}, int @var{texture_y})
@var{level}:  the level to work on

@var{body_x}:  the body (logical) x coord

@var{body_y}:  the body (logical) y coord

@var{texture_x}:  the texture x coord

@var{texture_y}:  the texture y coord

Gets body (logical) coords from texture position.

@strong{Return value:}  1 on success, 0 on failure (out of bounds)
@end deftypefun

@deftypefun {u_int8_t} {lw6map_body_get_with_texture_coord} (lw6map_level_t * @var{level}, int @var{texture_x}, int @var{texture_y}, int @var{z})
@var{level}:  the level to work on

@var{texture_x}:  the texture x coord

@var{texture_y}:  the texture y coord

@var{z}:  the z position (depth related)

Tells wether a given map position is free or not, but using
texture coords.

@strong{Return value:}  1 if position is playable, 0 if not (wall)
@end deftypefun

@deftypefun {void} {lw6map_color_invert} (lw6map_color_couple_t * @var{color})
@var{color}:  the color to invert

Inverts a color couple, that is, replace fg by bg and vice-versa.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_color_is_same} (lw6map_color_couple_t * @var{color1}, lw6map_color_couple_t * @var{color2})
@var{color1}:  1st color to compare

@var{color2}:  2nd color to compare

Compares two colors. 

@strong{Return value:}  1 if equal, 0 if not.
@end deftypefun

@deftypefun {char *} {lw6map_team_color_index_to_key} (int @var{index})
@var{index}:  index of the color between 0 & 9

Transforms a team color index into its readable string form,
which can be used in config files for instance.

@strong{Return value:}  a string, must *not* be freed.
@end deftypefun

@deftypefun {int} {lw6map_team_color_key_to_index} (char * @var{key})
@var{key}:  key of the color, for instance "red"

The index of the color, between 0 & 9

@strong{Return value:}  an integer.
@end deftypefun

@deftypefun {void} {lw6map_cursor_texture_clear} (lw6map_cursor_texture_t * @var{cursor_texture})
@var{cursor_texture}:  the cursor texture to clear

Clears a cursor texture (set it all transparent).

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_cursor_texture_builtin} (lw6map_cursor_texture_t * @var{cursor_texture})
@var{cursor_texture}:  the cursor texture to clear

Sets a cursor texture to the builtin defauts, that is a circle
that is black on the outside and gets white/transparent in the
middle.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_cursor_texture_layer_set} (lw6map_cursor_texture_layer_t *      @var{cursor_texture_layer}, int @var{x}, int @var{y}, lw6sys_color_8_t @var{color})
@var{cursor_texture_layer}:  the cursor texture_layer to change

@var{x}:  x coord

@var{y}:  y coord

@var{color}:  the color

Sets a pixel in the cursor texture_layer.

@strong{Return value:}  none
@end deftypefun

@deftypefun {lw6sys_color_8_t} {lw6map_cursor_texture_layer_get} (lw6map_cursor_texture_layer_t *      @var{cursor_texture_layer}, int @var{x}, int @var{y})
@var{cursor_texture_layer}:  the cursor texture_layer to query

@var{x}:  x coord

@var{y}:  y coord

Gets a pixel in the cursor texture_layer.

@strong{Return value:}  the color
@end deftypefun

@deftypefun {lw6map_level_t *} {lw6map_dup} (lw6map_level_t * @var{source}, lw6sys_progress_t * @var{progress})
@var{source}:  the map to copy

@var{progress}:  to show advancement

Performs a deep copy of the map, all elements are newly allocated
and source can safely be destroyed after it's been duplicated.

@strong{Return value:}  a newly allocated map, may be NULL.
@end deftypefun

@deftypefun {int} {lw6map_exp_get_highest_team_color_allowed} (int @var{exp})
@var{exp}:  the player experience

Gets the highest color available for a given exp.

@strong{Return value:}  a color id
@end deftypefun

@deftypefun {int} {lw6map_exp_get_highest_weapon_allowed} (int @var{exp})
@var{exp}:  the player experience

Gets the highest weapon available for a given exp.

@strong{Return value:}  a weapon id
@end deftypefun

@deftypefun {char *} {lw6map_to_hexa} (lw6map_level_t * @var{level})
Converts a map to something that is later readable by @code{lw6map_from_hexa}
to reproduce the exact same map. Just a serializer.

@strong{Return value:}  a newly allocated pointer, NULL if conversion failed.
@end deftypefun

@deftypefun {lw6map_level_t *} {lw6map_from_hexa} (char * @var{hexa})
@var{hexa}:  an hexadecimal ASCII string, created by @code{lw6map_to_hexa}

Constructs a map from an hexadecimal string generated
by @code{lw6map_to_hexa}. Just an un-serializer.

@strong{Return value:}  a new map, might be NULL if string isn't correct.
@end deftypefun

@deftypefun {void} {lw6map_layer_builtin_custom} (lw6map_layer_t * @var{layer}, int @var{w}, int @var{h})
@var{layer}:  the layer to init

@var{w}:  width

@var{h}:  height

Creates a default layer. This is mostly for testing purposes, the default
layer is not empty, it contains a simplified map of the world.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_layer_clear} (lw6map_layer_t * @var{layer})
@var{layer}:  the layer to init

Clears a layer struct. This means freeing the pointer
if it's non NULL and setting everything to 0.

@strong{Return value:}  none
@end deftypefun

@deftypefun {lw6map_level_t *} {lw6map_new} ()

Creates a new empty map. This object is perfectly unusable as is,
since it has a 0x0 size, and many things set to "NULL". Still, it's
used internally and is the canonical way to create the object, it
ensures later calls that set up default parameters, for instance,
will succeed.

@strong{Return value:}  a newly allocated pointer.
@end deftypefun

@deftypefun {lw6map_level_t *} {lw6map_builtin_defaults} ()

Creates a map, set to defaults. This is usefull mostly for testing.
This builtin map has walls, paths, it's playable.

@strong{Return value:}  a newly allocated map. 
@end deftypefun

@deftypefun {lw6map_level_t *} {lw6map_builtin_custom} (int @var{w}, int @var{h}, int @var{d}, int @var{noise_percent})
@var{w}:  the width of the map

@var{h}:  the height of the map

@var{d}:  the depth (number of layers) of the map

@var{noise_percent}:  percentage of noise to use for metalayers

Creates a map, set to defaults. This is usefull mostly for testing.
This one, unlike @code{lw6map_builtin_defaults}  will let you give a width,
height and a depth.

@strong{Return value:}  a newly allocated map. 
@end deftypefun

@deftypefun {void} {lw6map_free} (lw6map_level_t * @var{level})
Frees a map and releases all its internal ressources.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_memory_footprint} (lw6map_level_t * @var{level})
Reports how many bytes the map needs, in memory. Note that this is
not contiguous memory, it involves a bunch of pointers, and possibly
much more...
@end deftypefun

@deftypefun {char *} {lw6map_repr} (lw6map_level_t * @var{level})
Returns a string describing the map. This is a very short description,
use it for logs, and to debug stuff. By no means it's a complete exhaustive
description. Still, the string returned should be unique.

@strong{Return value:}  a dynamically allocated string.
@end deftypefun

@deftypefun {int} {lw6map_is_same} (lw6map_level_t * @var{level_a}, lw6map_level_t * @var{level_b})
@var{level_a}:  the first level to compare

@var{level_b}:  the other level to compare

Compares two level structs, the idea is to compare the content, not
only the pointers and level ids.

@strong{Return value:}  1 if they're the same, 0 if not.
@end deftypefun

@deftypefun {int} {lw6map_local_info_set_music_dir} (lw6map_local_info_t * @var{local_info}, char * @var{music_dir})
@var{local_info}:  the structure to modify

@var{music_dir}:  the new music_dir value

Sets the music_dir value, in a 'safe' manner, freeing any previous
value and performing a string duplication.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {void} {lw6map_local_info_clear} (lw6map_local_info_t * @var{local_info})
@var{local_info}:  the structure to clear

Clears the local_info structure, before destroying a level for instance.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_metadata_defaults} (lw6map_metadata_t * @var{metadata})
@var{metadata}:  struct to set to defaults

Sets the metadata struct to defaults, this does not set
fields to NULL/empty values, but rather fills it with
data claiming, for instance, that this is a default map.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_metadata_clear} (lw6map_metadata_t * @var{metadata})
@var{metadata}:  struct to clear

Clears a metadata, will expect it to be in a consistent
state, that is either filled with proper values or
completely zeroed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_metadata_is_same} (lw6map_metadata_t * @var{metadata_a}, lw6map_metadata_t * @var{metadata_b})
@var{metadata_a}:  first item to compare

@var{metadata_b}:  second item to compare

Tells wether both metadata items contain the same values.

@strong{Return value:}  1 if same, 0 if different.
@end deftypefun

@deftypefun {void} {lw6map_meta_layer_set} (lw6map_meta_layer_t * @var{meta_layer}, int @var{x}, int @var{y}, u_int8_t @var{value})
@var{meta_layer}:  the meta_layer structure

@var{x}:  x coord

@var{y}:  y coord

@var{value}:  the value to set at this place

Simple setter for the meta_layer struct.

@strong{Return value:}  none
@end deftypefun

@deftypefun {u_int8_t} {lw6map_meta_layer_get} (lw6map_meta_layer_t * @var{meta_layer}, int @var{x}, int @var{y})
@var{meta_layer}:  the meta_layer structure

@var{x}:  x coord

@var{y}:  y coord

Simple getter for the meta_layer struct.

@strong{Return value:}  the value at this place
@end deftypefun

@deftypefun {void} {lw6map_meta_layer_clear} (lw6map_meta_layer_t * @var{meta_layer})
@var{meta_layer}:  the meta_layer to clear

Clears a meta_layer struct. This means freeing the pointer
if it's non NULL and setting everything to 0.

@strong{Return value:}  none
@end deftypefun

@deftypefun {int} {lw6map_meta_layer_builtin_custom} (lw6map_meta_layer_t * @var{meta_layer}, int @var{w}, int @var{h}, int @var{analog}, int @var{noise_percent}, int @var{seed})
@var{meta_layer}:  the object to init

@var{w}:  width

@var{h}:  height

@var{analog}:  wether to use analog mode (0-255) or boolean (0-1)

@var{noise_percent}:  the quantity of noise to initialise the layer with

@var{seed}:  a pseudo-random seed to feed the pseudo-random generator

Builds a custom metalyer, suitable for tests or demo, letting the choice
of its size and the noise to fill it with. If noise is 100 then metalayer
is "full". If noise is 0, then meta layer is empty.

@strong{Return value:}  1 if OK, 0 on failure.
@end deftypefun

@deftypefun {void} {lw6map_param_defaults} (lw6map_param_t * @var{param})
@var{param}:  the param struct to modify

Sets a param structure to its default value, note that current
structured must be zeroed or correctly initialized.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_param_clear} (lw6map_param_t * @var{param})
@var{param}:  the param struct to modify

Resets a param structure to nothing. Note that current
structured must be zeroed or correctly initialized.
The idea is just to free member pointers before calling free.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6map_param_copy} (lw6map_param_t * @var{dst}, lw6map_param_t * @var{src})
@var{dst}:  the destination param struct

@var{src}:  the source param struct

Copies parameters. Both structures must be zeroed or
correctly initialized.

@strong{Return value:}  none
@end deftypefun

@deftypefun {int} {lw6map_param_set} (lw6map_param_t * @var{param}, char * @var{key}, char * @var{value})
@var{param}:  the param struct to modify

@var{key}:  the name of the parameter to modify

@var{value}:  the value of the parameter to modify

Sets an entry in a param struct. All values must be submitted
as strings, internally, the function will call atoi to convert
to integers if needed, for instance. It will also dispatch
automatically between rules, style and teams.

@strong{Return value:}  1 if parameter successfully set, 0 on error.
@end deftypefun

@deftypefun {char *} {lw6map_param_get} (lw6map_param_t * @var{param}, char * @var{key})
@var{param}:  the param struct to query

@var{key}:  the name of the parameter to get

Gets an entry from a param struct. All values returned
as strings, do not use this in performance bottlenecks,
this is just to export values to scripts, for instance.

@strong{Return value:}  dynamically allocated string, NULL on error,
might return a string containing 0 on bad keys.
@end deftypefun

@deftypefun {int} {lw6map_param_is_same} (lw6map_param_t * @var{param_a}, lw6map_param_t * @var{param_b})
@var{param_a}:  one struct to compare

@var{param_b}:  another struct to compare

Compares the contents of two param structs.

@strong{Return value:}  1 if they contain the same thing, 0 if not
@end deftypefun

@deftypefun {void} {lw6map_rules_defaults} (lw6map_rules_t * @var{rules})
@var{rules}:  struct to set to defaults

Set rules to default values, as these are all integers,
you can call this on any rules object.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_rules_copy} (lw6map_rules_t * @var{dst}, lw6map_rules_t * @var{src})
@var{dst}:  destination (out param)

@var{src}:  source (in param)

Copies the data from source to destination, simple
wrapper on memcpy.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_rules_update_checksum} (lw6map_rules_t * @var{rules}, u_int32_t * @var{checksum})
@var{rules}:  rules struct to check

@var{checksum}:  checksum to update (in/out param)

Updates a checksum with the rules data.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int32_t} {lw6map_rules_get_default} (char * @var{key})
@var{key}:  key to query

Get the default value for a given string key. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int32_t} {lw6map_rules_get_min} (char * @var{key})
@var{key}:  key to query

Get the min value for a given string key. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int32_t} {lw6map_rules_get_max} (char * @var{key})
@var{key}:  key to query

Get the min value for a given string key. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int32_t} {lw6map_rules_get_int} (lw6map_rules_t * @var{rules}, char * @var{key})
@var{rules}:  struct to use

@var{key}:  key to query

Get the value for a given string key, as an integer. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int} {lw6map_rules_set_int} (lw6map_rules_t * @var{rules}, char * @var{key}, int32_t @var{value})
@var{rules}:  struct to use

@var{key}:  key to set

@var{value}:  new integer value for key

Set the value for a given string key, as an integer. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  1 on success, 0 on failure (eg key not found)
@end deftypefun

@deftypefun {int} {lw6map_rules_get_bool} (lw6map_rules_t * @var{rules}, char * @var{key})
@var{rules}:  struct to use

@var{key}:  key to query

Get the value for a given string key, as a boolean. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  boolean.
@end deftypefun

@deftypefun {int} {lw6map_rules_set_bool} (lw6map_rules_t * @var{rules}, char * @var{key}, int @var{value})
@var{rules}:  struct to use

@var{key}:  key to set

@var{value}:  new boolean value for key

Set the value for a given string key, as a boolean. Of course
you could access the member, but this function internally does
the conversion between readable string and actual
struct offset.

@strong{Return value:}  1 on success, 0 on failure (eg key not found)
@end deftypefun

@deftypefun {void} {lw6map_rules_clear} (lw6map_rules_t * @var{rules})
@var{rules}:  struct to init

Set rules to 0, this is not defaults, this is 0 (probably
unusable as a real-world setting).

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_rules_is_same} (lw6map_rules_t * @var{rules_a}, lw6map_rules_t * @var{rules_b})
@var{rules_a}:  first item to compare

@var{rules_b}:  second item to compare

Compares two rules items. Will tell if they contain the same data.

@strong{Return value:}  1 if same, 0 if different.
@end deftypefun

@deftypefun {void} {lw6map_style_zero} (lw6map_style_t * @var{style})
@var{style}:  struct to initialize

Sets a style struct to zero, simply puts zero everywhere
without checking what was here before

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_style_defaults} (lw6map_style_t * @var{style})
@var{style}:  struct to modify

Sets a style struct to defaults values, expects
the object to be in a consistent style, that's to
say either containing real data or being zeroed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_style_clear} (lw6map_style_t * @var{style})
@var{style}:  struct to clear

Clears a style struct. This function won't work on an unitialized
structure, structure must be zeroed by some CALLOC
or something, else automatic freeing of pointers
will fail.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_style_copy} (lw6map_style_t * @var{dst}, lw6map_style_t * @var{src})
@var{dst}:  destination

@var{src}:  source

Copies style data from source to destination.
Like with clear, @code{dst} must be either initialized or
totally zeroed, else function will fail (core dump)

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_style_set} (lw6map_style_t * @var{style}, char * @var{key}, char * @var{value})
@var{style}:  style struct to modify (out param)

@var{key}:  key to use

@var{value}:  value to use

Sets a style entry, takes string values and will
identify the struct offset and convert the value
to whatever C type is needed.

@strong{Return value:}  1 on success, 0 on failure (key not found)
@end deftypefun

@deftypefun {char *} {lw6map_style_get} (lw6map_style_t * @var{style}, char * @var{key})
@var{style}:  style struct to query

@var{key}:  key to use

Get a style entry, takes a string key and will
identify the struct offset. The return value is
converted to string, typically the cannonical 
representation suitable to write in an XML config file.

@strong{Return value:}  dynamically allocated string.
@end deftypefun

@deftypefun {char *} {lw6map_style_get_default} (char * @var{key})
@var{key}:  key to query

Get the default value for a style entry. This is quite
a cost-expensive function given what it does, indeed it
will convert anything to a string, and also perform
key lookup to fetch the value.

@strong{Return value:}  dynamically allocated string.
@end deftypefun

@deftypefun {int} {lw6map_color_set_is_same} (lw6map_color_set_t * @var{color_set_a}, lw6map_color_set_t * @var{color_set_b})
@var{color_set_a}:  first item to compare

@var{color_set_b}:  second item to compare

Compares two color sets, telling if they contain
the same data.

@strong{Return value:}  1 if same, 0 if different.
@end deftypefun

@deftypefun {int} {lw6map_style_is_same} (lw6map_style_t * @var{style_a}, lw6map_style_t * @var{style_b})
@var{style_a}:  first item to compare

@var{style_b}:  second item to compare

Compares two style structures, telling if they contain
the same data.

@strong{Return value:}  1 if same, 0 if different.
@end deftypefun

@deftypefun {void} {lw6map_teams_zero} (lw6map_teams_t * @var{teams})
@var{teams}:  data to initialize

Zeros the teams struct, this is not the same as setting to defaults.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_teams_defaults} (lw6map_teams_t * @var{teams})
@var{teams}:  data to initialize

Set the teams struct to its defaults.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_teams_clear} (lw6map_teams_t * @var{teams})
@var{teams}:  data to initialize

Clears the teams struct, this is not the same as setting to defaults.
This one supposes the struct has been properly initialized, at least
zeroed before usage, it might contain pointers which should be freed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6map_teams_copy} (lw6map_teams_t * @var{dst}, lw6map_teams_t * @var{src})
@var{dst}:  destination

@var{src}:  source

Copies the contents of the teams struct. It's a real duplicate,
any string is reallocated.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_teams_set} (lw6map_teams_t * @var{teams}, char * @var{key}, char * @var{value})
@var{teams}:  the teams to modify

@var{key}:  the key to modify

@var{value}:  the value to affect to the key, as a string

Sets one single parameter in a teams structure. Value must
always be passed as a string, will be converted to the right
type automatically when storing it in the structure.

@strong{Return value:}  1 if success, 0 if failed. Note that while 0 really
means there's a problem, some affectations can fail and return 1,
needs to be worked on.
@end deftypefun

@deftypefun {char *} {lw6map_teams_get} (lw6map_teams_t * @var{teams}, char * @var{key})
@var{teams}:  the teams to modify

@var{key}:  the key to modify

Gets one single parameter in a teams structure. Value is
converted as a string.

@strong{Return value:}  dynamically allocated string, NULL on error.
@end deftypefun

@deftypefun {char *} {lw6map_teams_get_default} (char * @var{key})
@var{key}:  the key we want informations about.

Gets the default value for a given teams key.

@strong{Return value:}  dynamically allocated string, NULL on error.
@end deftypefun

@deftypefun {int} {lw6map_teams_is_same} (lw6map_teams_t * @var{teams_a}, lw6map_teams_t * @var{teams_b})
@var{teams_a}:  one struct to compare

@var{teams_b}:  another struct to compare

Compares the contents of two teams structs.

@strong{Return value:}  1 if they contain the same thing, 0 if not
@end deftypefun

@deftypefun {int} {lw6map_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{map} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {int} {lw6map_texture_from_body} (lw6map_texture_t * @var{texture}, lw6map_body_t * @var{body}, lw6map_color_couple_t * @var{color})
@var{texture}:  texture to load (out param)

@var{body}:  body to pick data from

@var{color}:  colors to use

Will create a default bicolor texture from the body data,
this is in case we don't want to use the texture or there is
none. Result is not beautifull but might be very comfortable
to play.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {void} {lw6map_texture_clear} (lw6map_texture_t * @var{texture})
@var{texture}:  data to clear

Clears a texture object, expects it to be in a consitent
state, either filled with real data of zeroed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6map_texture_coord_from_body} (lw6map_level_t * @var{level}, int * @var{texture_x}, int * @var{texture_y}, int @var{body_x}, int @var{body_y})
@var{level}:  map to work on

@var{texture_x}:  texture x coordinate (out param)

@var{texture_y}:  texture y coordinate (out param)

@var{body_x}:  body x coordinate (in param)

@var{body_y}:  body y coordinate (in param)

Translates from body coordinate space to texture
coordinate space.

@strong{Return value:}  1 on success, 0 if failure.
@end deftypefun

@deftypefun {lw6sys_color_8_t} {lw6map_texture_get_with_body_coord} (lw6map_level_t * @var{level}, int @var{body_x}, int @var{body_y})
@var{level}:  map to use

@var{body_x}:  x coordinate in body space

@var{body_y}:  y coordinate in body space

Get the color of a given point in the texture, using the
body coordinate space.

@strong{Return value:}  RGBA 8-bit color.
@end deftypefun

@deftypefun {int} {lw6map_texture_has_alpha} (lw6map_texture_t * @var{texture})
@var{texture}:  texture object to test

Finds out if the texture is fully opaque or not. If it has
an alpha layer (typically, PNG file) but this one is filled
at 100% everywhere, then it will consider opaque. This is
a slow function but the result is cached in the has_alpha
member, so as the function is called at map loading, use
the cached value instead.

@strong{Return value:}  1 if has used alpha layer, 0 if opaque.
@end deftypefun

@deftypefun {char *} {lw6map_weapon_index_to_key} (int @var{index})
@var{index}:  index of the weapon between 0 & 19

Transforms a team weapon index into its readable string form,
which can be used in config files for instance.

@strong{Return value:}  a string, must *not* be freed.
@end deftypefun

@deftypefun {int} {lw6map_weapon_key_to_index} (char * @var{key})
@var{key}:  key of the weapon, for instance "red"

The index of the weapon, between 0 & 19

@strong{Return value:}  an integer.
@end deftypefun

