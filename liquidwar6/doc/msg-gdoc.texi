@deftypefun {char *} {lw6msg_cmd_generate_hello} (lw6nod_info_t * @var{info}, lw6msg_cmd_mode_t @var{mode})
@var{info}:  the nod info to use

@var{mode}:  the mode to use (standard or URL compatible)

Generate a HELLO command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_ticket} (lw6nod_info_t * @var{info}, lw6msg_cmd_mode_t @var{mode}, u_int32_t @var{ticket})
@var{info}:  the nod info to use

@var{mode}:  the mode to use (standard or URL compatible)

Generate a TICKET command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_foo} (lw6msg_cmd_mode_t @var{mode}, int @var{key})
@var{mode}:  the mode to use (standard or URL compatible)

Generate a FOO command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_bar} (lw6msg_cmd_mode_t @var{mode}, int @var{key})
@var{mode}:  the mode to use (standard or URL compatible)

Generate a BAR command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_goodbye} (lw6msg_cmd_mode_t @var{mode})
@var{mode}:  the mode to use (standard or URL compatible)

Generate a GOODBYE command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {int} {lw6cmd_analyse_hello} (lw6nod_info_t ** @var{info}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{msg}:  the message to anaylse

Analyzes a HELLO message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6cmd_analyse_ticket} (lw6nod_info_t ** @var{info}, u_int32_t * @var{ticket}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{ticket}:  if not NULL, will contain the ticket value on success

@var{msg}:  the message to anaylse

Analyzes a TICKET message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6cmd_analyse_foo} (int * @var{key}, char * @var{msg})
@var{key}:  if not NULL, will contain the foo/bar key on success

@var{msg}:  the message to anaylse

Analyzes a FOO message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6cmd_analyse_bar} (int * @var{key}, char * @var{msg})
@var{key}:  if not NULL, will contain the foo/bar key on success

@var{msg}:  the message to anaylse

Analyzes a BAR message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6cmd_analyse_goodbye} (char * @var{msg})
@var{msg}:  the message to anaylse

Analyzes a GOODBYE message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_info} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the INFO question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_list} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the LIST question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_pong} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the PING question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_request} (char * @var{command}, char * @var{remote_url}, char * @var{password}, char * @var{local_url})
@var{command}:  the command to send (PING, INFO, LIST)

@var{remote_url}:  the remote URL (used to seed password)

@var{password}:  the password, can be NULL or ""

@var{local_url}:  the public URL to send along with the message, can be NULL or ""

Generates a simple clear text OOB request, with a password if needed.

@strong{Return value:}  a newly allocated string
@end deftypefun

@deftypefun {int} {lw6msg_oob_analyse_request} (int * @var{syntax_ok}, char ** @var{command}, int * @var{password_ok}, char ** @var{remote_url}, char * @var{request}, char * @var{local_url}, char * @var{password})
@var{syntax_ok}:  will contain 1 if syntax is OK, 0 if not

@var{command}:  the command (out param, needs *not* to be freed) 

@var{password_ok}:  will contain 1 if password is OK, 0 if not

@var{remote_url}:  the URL detected, if provided (out param, does needs to be freed)

@var{request}:  the request to analyse

@var{local_url}:  the local url (used to seed password)

@var{password}:  the password to check against

Analyses a simple OOB message of the form COMMAND <passwd> <url>. 

@strong{Return value:}  1 if OK, 0 if not. If 0, check the value of password_ok. 
@end deftypefun

@deftypefun {char *} {lw6msg_oob_analyse_pong} (char * @var{text})
@var{text}:  the text of the message to parse

Analyses a PONG message and gets the public_url from it, if
it exists.

@strong{Return value:}  newly allocated string containing public_url if OK, NULL on error.
@end deftypefun

@deftypefun {int} {lw6msg_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{nod} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {int} {lw6msg_utils_parse_key_value_to_ptr} (char ** @var{key}, char ** @var{value}, char * @var{line})
@var{key}:  will contain the key detected

@var{value}:  will contain the value detected

@var{line}:  the line to analyse

Analyses a trivial "KEY value" line and returns the key and the value in
the passed pointers.

@strong{Return value:}  1 if line OK (and in this case @code{key} and @code{value} are set), 0 if not.
@end deftypefun

@deftypefun {int} {lw6msg_utils_parse_key_value_to_assoc} (lw6sys_assoc_t ** @var{assoc}, char * @var{line})
@var{assoc}:  an assoc object which will contain the result

@var{line}:  the line to analyse

Analyses a trivial "KEY value" line and sets the @code{assoc} parameter according
to detected values. Note that @code{assoc} must be set to contain string, and
free them automatically with @code{lw6sys_free_callback} for instance.

@strong{Return value:}  1 if line OK (and in this case @code{assoc} is updated), 0 if not.
@end deftypefun

@deftypefun {char *} {lw6msg_utils_get_assoc_str_with_default} (lw6sys_assoc_t * @var{assoc}, char * @var{key}, char * @var{default_value})
@var{assoc}:  the string assoc to query

@var{key}:  the key to find in the assoc

@var{default_value}:  the default value to return

Queries a string assoc for a given value, and if not available, returns
default value. Not that default value (nor the assoc value) is copied,
so you must take care all remain valid until usage of returned value
is over.

@strong{Return value:}  a string, must not be freed.
@end deftypefun

@deftypefun {int} {lw6msg_utils_get_assoc_int_with_default} (lw6sys_assoc_t * @var{assoc}, char * @var{key}, int @var{default_value})
@var{assoc}:  the string assoc to query

@var{key}:  the key to find in the assoc

@var{default_value}:  the default value to return

Queries a string assoc for a given value, and if not available, returns
default value. Not that default value (nor the assoc value) is copied,
so you must take care all remain valid until usage of returned value
is over. This one will returned an int converted with @code{lw6sys_atoi}.

@strong{Return value:}  a string, must not be freed.
@end deftypefun

@deftypefun {int} {lw6msg_word_first} (lw6msg_word_t * @var{word}, char ** @var{next}, char * @var{msg})
@var{word}:  will contain the parsed word

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message and gets the first word. This word is put in @code{buf} member
with its length. @code{next} is usefull if you want to parse the rest of the message,
it points at the beginning of it.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_int} (int * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an int.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_int_gt0} (int * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an int.
The value must be strictly greater than 0.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_16} (u_int16_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 16-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_32} (u_int32_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 32-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_64} (u_int64_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 64-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {char *} {lw6msg_z_encode} (char * @var{msg}, int @var{limit})
@var{msg}:  message to encode

@var{limit}:  if under this limit (length in bytes), do not encode, return as is

Z-encode a message, by "Z-encoding" we mean pass the string through
1) zlib then 2) base64 encoding, this way we get a string without any
blank and/or special character, and of reasonnable length. There's
an optional limit *not* to encode anything, just when we know there
are no special characters to escape and string is small, it's useless
to fire this big artillery.

@strong{Return value:}  newly allocated string, 0 terminated, NULL on error.
@end deftypefun

@deftypefun {char *} {lw6msg_z_decode} (char * @var{msg})
@var{msg}:  message to decode

Z-decode a message, by "Z-encoding" we mean pass the string through
1) zlib then 2) base64 encoding, this way we get a string without any
blank and/or special character, and of reasonnable length. This decode
string does it the reverse way, un64-encode the string then uncompress
it back to a readable string.

@strong{Return value:}  newly allocated string, 0 terminated, NULL on error.
@end deftypefun

