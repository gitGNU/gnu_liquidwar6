@deftypefun {char *} {lw6msg_cmd_generate_hello} (lw6nod_info_t * @var{info})
@var{info}:  the node info to use

Generate a HELLO command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_ticket} (lw6nod_info_t * @var{info}, u_int32_t @var{ticket})
@var{info}:  the node info to use

@var{ticket}:  the ticket to send

Generate a TICKET command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_foo} (lw6nod_info_t * @var{info}, u_int32_t @var{key})
@var{info}:  the node info to use

@var{key}:  the key to identify the message

Generate a FOO command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_bar} (lw6nod_info_t * @var{info}, u_int32_t @var{key})
@var{info}:  the node info to use

@var{key}:  the key to identify the message

Generate a BAR command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_generate_goodbye} (lw6nod_info_t * @var{info})
@var{info}:  the node info to use

Generate a GOODBYE command.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {int} {lw6msg_cmd_analyse_hello} (lw6nod_info_t ** @var{info}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{msg}:  the message to analyse

Analyzes a HELLO message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6msg_cmd_analyse_ticket} (lw6nod_info_t ** @var{info}, u_int32_t * @var{ticket}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{ticket}:  if not NULL, will contain the ticket value on success

@var{msg}:  the message to analyse

Analyzes a TICKET message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6msg_cmd_analyse_foo} (lw6nod_info_t ** @var{info}, u_int32_t * @var{key}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{key}:  if not NULL, will contain the foo/bar key on success

@var{msg}:  the message to analyse

Analyzes a FOO message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6msg_cmd_analyse_bar} (lw6nod_info_t ** @var{info}, u_int32_t * @var{key}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{key}:  if not NULL, will contain the foo/bar key on success

@var{msg}:  the message to analyse

Analyzes a BAR message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6msg_cmd_analyse_goodbye} (lw6nod_info_t ** @var{info}, char * @var{msg})
@var{info}:  if not NULL, will contain (remote) node info on success

@var{msg}:  the message to analyse

Analyzes a GOODBYE message.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {char *} {lw6msg_cmd_guess_from_url} (char * @var{msg})
@var{msg}:  the message to analyse

Analyzes a GOODBYE message.

@strong{Return value:}  the from url, if found (dynamically allocated)
@end deftypefun

@deftypefun {char *} {lw6msg_envelope_generate} (lw6msg_envelope_mode_t @var{mode}, char * @var{version}, char * @var{password_checksum}, u_int32_t @var{physical_ticket_sig}, u_int32_t @var{logical_ticket_sig}, u_int64_t @var{physical_from_id}, u_int64_t @var{physical_to_id}, u_int64_t @var{logical_from_id}, u_int64_t @var{logical_to_id}, char * @var{msg})
@var{mode}:  mode to use (a la TELNET or URL compatible)

@var{version}:  the program version to use (note: can be changed when testing)

@var{password_checksum}:  the password string to send

@var{physical_ticket_sig}:  the signature of the message, calculated with ticket + physical from/to

@var{logical_ticket_sig}:  the signature of the message, calculated with ticket + logical from/to

@var{physical_from_id}:  the sender id

@var{physical_to_id}:  the receiver id

@var{logical_from_id}:  the message creator id

@var{logical_to_id}:  the message final destination id

@var{msg}:  the body of the message

Generate an envelope, that is, the complete message sendable on the
network.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {int} {lw6msg_envelope_analyse} (char * @var{envelope}, lw6msg_envelope_mode_t @var{mode}, char * @var{local_url}, char * @var{password}, u_int64_t @var{expected_physical_from_id}, u_int64_t @var{expected_physical_to_id}, char ** @var{msg}, u_int32_t * @var{physical_ticket_sig}, u_int32_t * @var{logical_ticket_sig}, u_int64_t * @var{physical_from_id}, u_int64_t * @var{physical_to_id}, u_int64_t * @var{logical_from_id}, u_int64_t * @var{logical_to_id}, char ** @var{physical_from_url})
@var{envelope}:  the envelope to analyse

@var{mode}:  mode to use (a la TELNET or URL compatible)

@var{local_url}:  the url of local server (usefull for password)

@var{password}:  the password to check against

@var{expected_physical_from_id}:  the sender id, if NULL, no check performed

@var{expected_physical_to_id}:  the receiver id, if NULL, no check performed

@var{msg}:  if not NULL, will contain body of the message

@var{physical_ticket_sig}:  if not NULL, will contain signature of message, calculated with ticket

@var{logical_ticket_sig}:  if not NULL, will contain signature of message, calculated with ticket

@var{physical_from_id}:  if not NULL, will contain sender id

@var{physical_to_id}:  if not NULL, will contain receiver id

@var{logical_from_id}:  if not NULL, will contain message creator id

@var{logical_to_id}:  if not NULL, will contain message final destination id

@var{physical_from_url}:  if not NULL and if message allows, will contain sender public URL

Generate an envelope, that is, the complete message sendable on the
network.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_info} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the INFO question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_list} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the LIST question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_pong} (lw6nod_info_t * @var{info})
@var{info}:  the node to generate info about

Generates a standard response to the PING question for OOB
(out of band) messages. The same message is sent, be it
on http or tcp or udp, so it's factorized here. Function
will lock the info object when needed.

@strong{Return value:}  newly allocated string.
@end deftypefun

@deftypefun {char *} {lw6msg_oob_generate_request} (char * @var{command}, char * @var{remote_url}, char * @var{password}, char * @var{local_url})
@var{command}:  the command to send (PING, INFO, LIST)

@var{remote_url}:  the remote URL (used to seed password)

@var{password}:  the password, can be NULL or ""

@var{local_url}:  the public URL to send along with the message, can be NULL or ""

Generates a simple clear text OOB request, with a password if needed.

@strong{Return value:}  a newly allocated string
@end deftypefun

@deftypefun {int} {lw6msg_oob_analyse_request} (int * @var{syntax_ok}, char ** @var{command}, int * @var{password_ok}, char ** @var{remote_url}, char * @var{request}, char * @var{local_url}, char * @var{password})
@var{syntax_ok}:  will contain 1 if syntax is OK, 0 if not

@var{command}:  the command (out param, needs *not* to be freed) 

@var{password_ok}:  will contain 1 if password is OK, 0 if not

@var{remote_url}:  the URL detected, if provided (out param, does needs to be freed)

@var{request}:  the request to analyse

@var{local_url}:  the local url (used to seed password)

@var{password}:  the password to check against

Analyses a simple OOB message of the form COMMAND <passwd> <url>. 

@strong{Return value:}  1 if OK, 0 if not. If 0, check the value of password_ok. 
@end deftypefun

@deftypefun {char *} {lw6msg_oob_analyse_pong} (char * @var{text})
@var{text}:  the text of the message to parse

Analyses a PONG message and gets the public_url from it, if
it exists.

@strong{Return value:}  newly allocated string containing public_url if OK, NULL on error.
@end deftypefun

@deftypefun {int} {lw6msg_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{nod} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {u_int32_t} {lw6msg_ticket_calc_sig} (u_int32_t @var{ticket}, u_int64_t @var{from_id}, u_int64_t @var{to_id}, char * @var{msg})
@var{ticket}:  the (private) ticket to use

@var{from_id}:  the sender/creator

@var{to_id}:  the receiver/target

@var{msg}:  the message to sign

Produces a little signature, which is clearly
vulnerable to brute-force attacks but makes it
possible to be 100% sure if it's wrong, someone
is trying to do something nasty (or there's a 
serious bug!).

@strong{Return value:}  the sig, always non-zero
@end deftypefun

@deftypefun {int} {lw6msg_ticket_check_sig} (u_int32_t @var{ticket}, u_int64_t @var{from_id}, u_int64_t @var{to_id}, char * @var{msg}, u_int32_t @var{ticket_sig})
@var{ticket}:  the (private) ticket to use

@var{from_id}:  the sender/creator

@var{to_id}:  the receiver/target

@var{msg}:  the message to sign

@var{ticket_sig}:  the signature to check against

Checks a sig is OK.

@strong{Return value:}  1 if they are the same, 0 if not.
@end deftypefun

@deftypefun {int} {lw6msg_utils_parse_key_value_to_ptr} (char ** @var{key}, char ** @var{value}, char * @var{line})
@var{key}:  will contain the key detected

@var{value}:  will contain the value detected

@var{line}:  the line to analyse

Analyses a trivial "KEY value" line and returns the key and the value in
the passed pointers.

@strong{Return value:}  1 if line OK (and in this case @code{key} and @code{value} are set), 0 if not.
@end deftypefun

@deftypefun {int} {lw6msg_utils_parse_key_value_to_assoc} (lw6sys_assoc_t ** @var{assoc}, char * @var{line})
@var{assoc}:  an assoc object which will contain the result

@var{line}:  the line to analyse

Analyses a trivial "KEY value" line and sets the @code{assoc} parameter according
to detected values. Note that @code{assoc} must be set to contain string, and
free them automatically with @code{lw6sys_free_callback} for instance.

@strong{Return value:}  1 if line OK (and in this case @code{assoc} is updated), 0 if not.
@end deftypefun

@deftypefun {char *} {lw6msg_utils_get_assoc_str_with_default} (lw6sys_assoc_t * @var{assoc}, char * @var{key}, char * @var{default_value})
@var{assoc}:  the string assoc to query

@var{key}:  the key to find in the assoc

@var{default_value}:  the default value to return

Queries a string assoc for a given value, and if not available, returns
default value. Not that default value (nor the assoc value) is copied,
so you must take care all remain valid until usage of returned value
is over.

@strong{Return value:}  a string, must not be freed.
@end deftypefun

@deftypefun {int} {lw6msg_utils_get_assoc_int_with_default} (lw6sys_assoc_t * @var{assoc}, char * @var{key}, int @var{default_value})
@var{assoc}:  the string assoc to query

@var{key}:  the key to find in the assoc

@var{default_value}:  the default value to return

Queries a string assoc for a given value, and if not available, returns
default value. Not that default value (nor the assoc value) is copied,
so you must take care all remain valid until usage of returned value
is over. This one will returned an int converted with @code{lw6sys_atoi}.

@strong{Return value:}  a string, must not be freed.
@end deftypefun

@deftypefun {int} {lw6msg_word_first} (lw6msg_word_t * @var{word}, char ** @var{next}, char * @var{msg})
@var{word}:  will contain the parsed word

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message and gets the first word. This word is put in @code{buf} member
with its length. @code{next} is usefull if you want to parse the rest of the message,
it points at the beginning of it.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_x} (lw6msg_word_t * @var{word}, char ** @var{next}, char * @var{msg})
@var{word}:  will contain the parsed word

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message and gets the first word. This word is put in @code{buf} member
with its length. @code{next} is usefull if you want to parse the rest of the message,
it points at the beginning of it. This special @code{x} function will consider slash
("/") as valid separator. It can't be used all the time but for almost every
field but URLs, it's fine. Internally, this one is used to parse integers,
IDs, etc.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_base64} (lw6msg_word_t * @var{word}, char ** @var{next}, char * @var{msg})
@var{word}:  will contain the parsed word

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message and gets the first word. This word is put in @code{buf} member
with its length. @code{next} is usefull if you want to parse the rest of the message,
it points at the beginning of it. The word is expected to
be base64 encoded and is decoded on-the-fly.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_int} (int * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an int.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_int_gt0} (int * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an int.
The value must be strictly greater than 0.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_16} (u_int16_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 16-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_32} (u_int32_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 32-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6msg_word_first_id_64} (u_int64_t * @var{parsed_value}, char ** @var{next}, char * @var{msg})
@var{parsed_value}:  will contain the parsed value

@var{next}:  if NOT NULL, will contain a (non freeable) pointer on remaining message

@var{msg}:  the message to parse

Analyses a message, gets the first word and interpret it as an 64-bit id.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {char *} {lw6msg_z_encode} (char * @var{msg}, int @var{limit})
@var{msg}:  message to encode

@var{limit}:  if under this limit (length in bytes), do not encode, return as is

Z-encode a message, by "Z-encoding" we mean pass the string through
1) zlib then 2) base64 encoding, this way we get a string without any
blank and/or special character, and of reasonnable length. There's
an optional limit *not* to encode anything, just when we know there
are no special characters to escape and string is small, it's useless
to fire this big artillery.

@strong{Return value:}  newly allocated string, 0 terminated, NULL on error.
@end deftypefun

@deftypefun {char *} {lw6msg_z_decode} (char * @var{msg})
@var{msg}:  message to decode

Z-decode a message, by "Z-encoding" we mean pass the string through
1) zlib then 2) base64 encoding, this way we get a string without any
blank and/or special character, and of reasonnable length. This decode
string does it the reverse way, un64-encode the string then uncompress
it back to a readable string.

@strong{Return value:}  newly allocated string, 0 terminated, NULL on error.
@end deftypefun

