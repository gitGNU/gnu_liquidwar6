This is /home/ufoot/Home/_/liquidwar6/doc/liquidwar6.info, produced by
makeinfo version 4.13 from
/home/ufoot/Home/_/liquidwar6/doc/liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c)  2005, 2006, 2007, 2008, 2009, 2010  Christian Mauduit
<ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: C functions,  Prev: C to Guile API,  Up: Reference

4.15 C functions
================

This section lists all documented C functions in the program. It
contains many references and is self-generated from C comments using
gdoc (http://josefsson.org/gdoc/) by Simon Josefsson
(http://josefsson.org/).

   In order to reduce the number of pages of printed output, this
complete reference is, by default, disabled in printable versions of
the documentation (PostScript, PDF).  This is both to make the manual
more readable and to avoid wasting paper.  Think about the environment.

   It is however available in the HTML version of the documentation,
which you can read online. The following adresses contain various view
on the source code, giving informations on all the internal and public
C interfaces:

   *
     `http://www.gnu.org/software/liquidwar6/manual/html_node/C-functions.html':
     the gdoc (http://josefsson.org/gdoc/) reference, generated from
     source code comments.

   * `http://www.gnu.org/software/liquidwar6/coverage/': the lcov
     (http://ltp.sourceforge.net/coverage/lcov.php) output when running
     `./liquidwar6 --test'.  It shows what functions are actually
     tested, and how many times they are called.

   * `http://www.gnu.org/software/liquidwar6/global/': the GNU global
     (http://www.gnu.org/software/global/) output gives complete
     cross-references, macros, headers, contants declaration. It's a
     very good place to start browsing the code.

   * `http://www.gnu.org/software/liquidwar6/cyclo/': the pmccabe
     (http://parisc-linux.org/~bame/pmccabe/) output shows the
     cyclomatic complexity of functions. It enables the programmer to
     spots the "ugly" and dangerous parts of the program.

4.15.1 libliquidwar6
--------------------

 -- Function: void lw6_resize_callback (lw6gui_video_mode_t *
          VIDEO_MODE)
     VIDEO_MODE:  the new video mode

     This callback is here because gfx needs to update the config when
     the screen is resized. But... we did not want to make gfx depend
     on cfg "directly". It's cleaner to pass parameters with Scheme, in
     the long run, it should make things easier.  So this callback is
     the solution. Another side effect is that this way there's a
     tangible obvious trace of this updating of config status by the
     gfx module. Seeing it sticking out like a thumb isn't a bad thing.

     *Return value:*  none

 -- Function: void lw6_release ()
     Functions which will call `quit'(), `free'(), `destroy'() on
     whatever smob object that has threads and/or requires hardware
     ressources.  This is to be called before the Guile interpreter
     ends. This is because when it garbage collects objects at the end
     of the program, it has no idea of what order to use when freeing
     objects. So if an object which uses another one in a thread is
     freed after the other is freed, you get a (rather unexplainabled
     if not warned) segfault.

     *Return value:*  none

 -- Function: void lw6_exit ()
     Will exit the program. If there are some display objects alive,
     that is if there's a display activated, it will find them and send
     a quit event, giving a chance to the to exit cleanly.  If not, it
     will just call `exit'() directly.

     *Return value:*  none

 -- Function: int lw6_fix_env (int ARGC, char * [] ARGV)
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Fixes environment variables (path related) so that program can
     find its requirements. This must be called early in the program
     flow (else other calls might fail).

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6_register_funcs ()
     Register all the functions, make them callable from Guile.  This
     is a very simple yet long and very usefull function, without it
     Guile has no knowledge of what LW6 is.

     *Return value:*  1 on success, 0 if failed.

 -- Function: extern void lw6_cns_handler (char * C_LINE)
     c_line: the line typed by the user

     This function will be called every time a message is typed on the
     console. It runs the given line in the current Guile environment.

     *Return value:*  none

 -- Function: int lw6_init_global (int ARGC, char * [] ARGV)
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Initializes global values to their defaults.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6_quit_global ()
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Frees global values. Will also garbage collect objects in case
     Guile failed to do it perfectly (or we failed to tell Guile how to
     do it).

     *Return value:*  none.

 -- Function: int lw6_main (int ARGC, char * [] ARGV)
     ARGC:  the argc parameter of the `main'() function, that is, the
     number of command-line args.

     ARGV:  the argv parameter of the `main'() function, that is, an
     array containing pointers on command-line args.

     This function is directly called by `main'(). This means by linking
     against libliquidwar6 and calling it, you would have a program
     that is almost exactly the "official" upstream liquidwar6 binary,
     except you can tweak it and have all the power to call whatever
     other functions you like, embed it. In short, everything the binary
     does, you can do it in your own binarn, by linking against the
     library and calling this function.

     *Return value:*  1 if success, zero if failure. Note that this is
     the "standard" C / liquidwar6 way to proceed, but your `main'()
     function should return 0 if success, else an error code. Typical
     use is "return !lw6_main(argc, argv);".

 -- Function: int lw6_process_non_run_options (int ARGC, char * []
          ARGV, int * RUN_GAME)
     ARGC:  the number of command-line args, as passed to `main()'

     ARGV:  an array of strings containing command-line args, as passed
     to `main()'

     RUN_GAME:  a pointer to a boolean which will contain true (1) if
     the game must be launched, or false (0) if the option is such that
     game must be skipped. Example: -copyright, -help, ...

     *Return value:*  non-zero if success, 0 if error. The error can
     be, for instance, the test suite returning "no, tests were not OK".

 -- Function: void lw6_print_help ()
     Displays a short help message.

     *Return value:*  none

 -- Function: void lw6_print_version ()
     Displays the version of the game.

     *Return value:*  none

 -- Function: void lw6_print_short_copyright ()
     Displays the copyright of the game (short version).

     *Return value:*  none

 -- Function: void lw6_print_long_copyright ()
     Displays the copyright of the game (long version).

     *Return value:*  none

 -- Function: void lw6_print_bench (float BENCH_RESULT)
     Displays the program bench value.

     *Return value:*  none

 -- Function: void lw6_print_pedigree ()
     Displays the program pedigree, think of this as version on
     steroids.

     *Return value:*  none

 -- Function: void lw6_print_host ()
     Displays the host on which the program was compiled.

     *Return value:*  none

 -- Function: void lw6_print_audit (int ARGC, char * [] ARGV)
     Displays various paths used by the game.

     *Return value:*  none

 -- Function: void lw6_print_modules ()
     Displays the list of modules compiled with the game.

     *Return value:*  none

 -- Function: void lw6_print_list_quick ()
     Displays the list of 'quick' options.

     *Return value:*  none

 -- Function: void lw6_print_list_doc ()
     Displays the list of 'doc' options.

     *Return value:*  none

 -- Function: void lw6_print_list_show ()
     Displays the list of 'show' options.

     *Return value:*  none

 -- Function: void lw6_print_list_path ()
     Displays the list of 'path' options.

     *Return value:*  none

 -- Function: void lw6_print_list_players ()
     Displays the list of 'players' options.

     *Return value:*  none

 -- Function: void lw6_print_list_input ()
     Displays the list of 'input' options.

     *Return value:*  none

 -- Function: void lw6_print_list_graphics ()
     Displays the list of 'graphics' options.

     *Return value:*  none

 -- Function: void lw6_print_list_sound ()
     Displays the list of 'sound' options.

     *Return value:*  none

 -- Function: void lw6_print_list_network ()
     Displays the list of 'network' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map ()
     Displays the list of 'map' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_rules ()
     Displays the list of 'map rules' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_hints ()
     Displays the list of 'map hints' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_style ()
     Displays the list of 'amp style' options.

     *Return value:*  none

 -- Function: void lw6_print_list_funcs ()
     Displays the list of 'funcs'.

     *Return value:*  none

 -- Function: void lw6_print_list_hooks ()
     Displays the list of 'hooks'.

     *Return value:*  none

 -- Function: void lw6_print_list_tuning ()
     Displays the list of 'tuning' options.

     *Return value:*  none

 -- Function: void lw6_print_list_aliases ()
     Displays the list of options aliases.

     *Return value:*  none

 -- Function: void lw6_print_list ()
     Displays the list of all known options.

     *Return value:*  none

 -- Function: void lw6_print_about (char * KEYWORD)
     Displays the about message for a keyword.

     *Return value:*  none

 -- Function: void lw6_print_hello (int ARGC, char * [] ARGV)
     Displays 'hello' at the beginning of the program.

     *Return value:*  none

 -- Function: void lw6_print_goodbye ()
     Displays 'goodbye', typically use at end of program to know it's
     over and everything went fine.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_dsp (lw6dsp_backend_t * C_DSP)
     C_DSP:  the display object

     Creates an SCM 'dsp' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6dsp_backend_t * lw6_scm_to_dsp (SCM DSP)
     DSP:  the dsp to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'dsp'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_dsp_smob (lw6_dsp_smob_t * DSP_SMOB)
     DSP_SMOB:  the smob to free

     Frees a dsp smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_snd (lw6snd_backend_t * C_SND)
     C_SND:  the sound object

     Creates an SCM 'snd' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6snd_backend_t * lw6_scm_to_snd (SCM SND)
     SND:  the snd to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'snd'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_snd_smob (lw6_snd_smob_t * SND_SMOB)
     SND_SMOB:  the smob to free

     Frees a snd smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_map (lw6map_level_t * C_MAP)
     C_MAP:  the map object

     Creates an SCM 'map' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6map_level_t * lw6_scm_to_map (SCM MAP)
     MAP:  the map to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'map'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_map_smob (lw6_map_smob_t * MAP_SMOB)
     MAP_SMOB:  the smob to free

     Frees a map smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_menu (lw6gui_menu_t * C_MENU)
     C_MENU:  the menu object

     Creates an SCM 'menu' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6gui_menu_t * lw6_scm_to_menu (SCM MENU)
     MENU:  the menu to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'menu'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_menu_smob (lw6_menu_smob_t * MENU_SMOB)
     MENU_SMOB:  the smob to free

     Frees a menu smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_game_struct (lw6ker_game_struct_t *
          C_GAME_STRUCT, SCM MAP)
     C_GAME_STRUCT:  the game struct object

     MAP:  the map (SCM object) referenced

     Creates an SCM 'game-struct' object from C data.  Passing the map
     object enables the garbage collector not to free the map until the
     game struct is freed.

     *Return value:*  the SCM object

 -- Function: lw6ker_game_struct_t * lw6_scm_to_game_struct (SCM
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_struct' object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_struct_smob (lw6_game_struct_smob_t *
          GAME_STRUCT_SMOB)
     GAME_STRUCT_SMOB:  the smob to free

     Frees a game_struct smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_game_state (lw6ker_game_state_t *
          C_GAME_STATE, SCM GAME_STRUCT)
     C_GAME_STATE:  the game state object

     GAME_STRUCT:  the game struct (SCM object) referenced

     Creates an SCM 'game_state' object from C data.  Passing
     game_struct enables the garbage collector not to free the
     game_struct until the game_state is freed.

     *Return value:*  the SCM object

 -- Function: lw6ker_game_state_t * lw6_scm_to_game_state (SCM
          GAME_STATE)
     GAME_STATE:  the game_state to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_state' object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_state_smob (lw6_game_state_smob_t *
          GAME_STATE_SMOB)
     GAME_STATE_SMOB:  the smob to free

     Frees a game_state smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_pilot (lw6pil_pilot_t * C_PILOT)
     C_PILOT:  the pilot object

     Creates an SCM 'pilot' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6pil_pilot_t * lw6_scm_to_pilot (SCM PILOT)
     PILOT:  the pilot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'pilot'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_pilot_smob (lw6_pilot_smob_t * PILOT_SMOB)
     PILOT_SMOB:  the smob to free

     Frees a pilot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_bot (lw6bot_backend_t * C_BOT, SCM
          GAME_STATE, SCM PILOT)
     C_BOT:  the bot object

     GAME_STATE:  the game state

     PILOT:  the pilot

     Creates an SCM 'bot' object from C data.  Passing game_state and
     pilot enables the garbage collector not the free them until bot is
     freed.

     *Return value:*  the SCM object

 -- Function: lw6bot_backend_t * lw6_scm_to_bot (SCM BOT)
     BOT:  the bot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'bot'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_bot_smob (lw6_bot_smob_t * BOT_SMOB)
     BOT_SMOB:  the smob to free

     Frees a bot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_look (lw6gui_look_t * C_LOOK)
     C_LOOK:  the look object

     Creates an SCM 'look' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6gui_look_t * lw6_scm_to_look (SCM LOOK)
     LOOK:  the look to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'look'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_look_smob (lw6_look_smob_t * LOOK_SMOB)
     LOOK_SMOB:  the smob to free

     Frees a look smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_loader (lw6tsk_loader_t * C_LOADER)
     C_LOADER:  the loader object

     Creates an SCM 'loader' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6tsk_loader_t * lw6_scm_to_loader (SCM LOADER)
     LOADER:  the loader to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'loader'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_loader_smob (lw6_loader_smob_t *
          LOADER_SMOB)
     LOADER_SMOB:  the smob to free

     Frees a loader smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_db (lw6p2p_db_t * C_DB)
     C_DB:  the database object

     Creates an SCM 'db' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6p2p_db_t * lw6_scm_to_db (SCM DB)
     DB:  the db to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'db'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_db_smob (lw6_db_smob_t * DB_SMOB)
     DB_SMOB:  the smob to free

     Frees a db smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_node (lw6p2p_node_t * C_NODE, SCM DB)
     C_NODE:  the node object

     DB:  the db (SCM object) referenced

     Creates an SCM 'node' object from C data.  Passing db enables the
     garbage collector not to free db until node is freed.

     *Return value:*  the SCM object

 -- Function: lw6p2p_node_t * lw6_scm_to_node (SCM NODE)
     NODE:  the node to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'node'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_node_smob (lw6_node_smob_t * NODE_SMOB)
     NODE_SMOB:  the smob to free

     Frees a node smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: int lw6_register_smobs ()
     Register all smobs to Guile.

     *Return value:*  1 on success, 0 if failed.

 -- Function: int lw6_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the liquidwar6 core module test suite, this will mostly test
     how Guile script integration works, loading a sample script and
     running it. It does not launch all the other sub modules tests.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.2 libbot
-------------

 -- Function: int lw6bot_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `bot' module test suite. Will try several engines and
     query basic moves.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.3 libcfg
-------------

 -- Function: int lw6cfg_parse_command_line (void * CONTEXT)
     CONTEXT:  opaque pointer on a context

     Overwrites any existing option with command line args

     *Return value:*  1 if success, 0 if error

 -- Function: int lw6cfg_defaults (void * CONTEXT)
     CONTEXT:  opaque pointer on a context

     Sets all values to their defaults.

     *Return value:*  1 if success, 0 if error

 -- Function: int lw6cfg_merge_env (void * CFG_CONTEXT)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     Overwrites any existing vale in the config with environment
     variables prefixed by LW6_.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: char * lw6cfg_format (char * KEY, char * VALUE,
          lw6hlp_type_t TYPE)
     KEY:  the key of the value to format

     VALUE:  the value to format

     TYPE:  the type of the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on. This is a
     performance killer but will ensure everything is correct.

     *Return value:*  a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: char * lw6cfg_format_guess_type (char * KEY, char * VALUE)
     KEY:  the key of the value to format

     VALUE:  the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on. This is a
     performance killer but will ensure everything is correct. This
     function will automatically guess the type of the value from its
     description in the help system.

     *Return value:*  a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: int lw6cfg_load (void * CFG_CONTEXT, char * FILENAME)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     FILENAME:  a file path, absolute or relative

     Loads the given config file, and stores its values into the current
     context. Parameters which are both in the config file and given as
     command line parameters, will be taken from the command-line.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: int lw6cfg_save (void * CFG_CONTEXT, char * FILENAME)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     FILENAME:  a file path, absolute or relative

     Save current options into the given config file. Before saving the
     file, all command line arguments will be read and will override
     current values. This means the saved file will contain values
     given as command line arguments.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: void * lw6cfg_init (int ARGC, char * [] ARGV)
     ARGC:  number of command line arguments, as given to `main'

     ARGV:  a list of command line arguments, as given to `main'

     Initializes a config context object. This object is hidden behind
     an opaque void * pointer to avoid direct access to its elements.

     *Return value:*  an opaque pointer, must be freed with
     `lw6cfg_quit'.

 -- Function: void lw6cfg_quit (void * CFG_CONTEXT)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     Frees a config cfg_context object. You must call this once you're
     done with the context.

     *Return value:*  none.

 -- Function: void lw6cfg_reset (int ARGC, char * [] ARGV)
     ARGC:  number of command line arguments, as given to `main'

     ARGV:  a list of command line arguments, as given to `main'

     Overwrites the config file with defaults.  Use this to get rid of
     old configurations.

 -- Function: int lw6cfg_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cfg' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: char * lw6cfg_unified_get_value (int ARGC, char * []
          ARGV, char * KEY)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     KEY:  the key to query

     Unified "value" getter, which gets informations from environment
     variables, command line, and config file. The rules is that the
     command-line argument always has the last word. It will override
     any other value.  Follows environment variables, which will be
     used if no command-line argument is supplied. Note that these are
     "LW6_" prefixed and uppercased environment variables as opposed to
     lowercased and "dash-separated" keys. Finally, if there's no
     environment variable, nor any config-file corresponding entry, the
     value will be searched in the config file.  If there's no
     information in the config file, NULL is returned.

     *Return value:*  a string with the value. Can be NULL. Must be
     freed.

 -- Function: char * lw6cfg_unified_get_user_dir (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_USER_DIR" env value, the "-user-dir" command-line
     paramater and the LW6DEF_USER_DIR config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_log_file (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the log file, taking all parameters in account, that's to say
     the "LW6_LOG_FILE" env value, the "-log-file" command-line
     paramater and the LW6DEF_LOG_FILE config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_music_path (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MUSIC_PATH" env value, the "-music-path" command-line
     paramater and the LW6DEF_MUSIC_PATH config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_map_path (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MAP_PATH" env value, the "-map-path" command-line
     paramater and the LW6DEF_MAP_PATH config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

4.15.4 libcli
-------------

 -- Function: int lw6cli_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cli' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.5 libcns
-------------

 -- Function: int lw6cns_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cns' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.6 libdsp
-------------

 -- Function: lw6dsp_backend_t * lw6dsp_create_backend (int ARGC, char
          * [] ARGV, char * GFX_BACKEND_NAME)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     GFX_BACKEND_NAME:  the id/name of the gfx backend to use

     Creates a dsp_backend object. The created object won't be
     displaying things until `lw6dsp_init' is called. No thread is
     created, but the graphics backend is loaded into memory. If video
     mode is not available, it will appear later, when trying to start
     displaying things, this function only allocates memory and checks
     code is available in case of a dynamically loaded gfx backend.

     *Return value:*  a newly allocated object.

 -- Function: void lw6dsp_destroy_backend (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend object to free

     Frees all ressources used by a dsp_backend object. Note that you
     must call this on a inactive 'stopped' dsp_backend object.

     *Return value:*  none.

 -- Function: char * lw6dsp_repr (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the object to represent

     Gives a short human-readable description of the object.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: int lw6dsp_init (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM, lw6gui_resize_callback_func_t
          RESIZE_CALLBACK)
     DSP_BACKEND:  the dsp_backend to start

     PARAM:  parameters to pass to the display funcs

     RESIZE_CALLBACK:  a function which will be called when there's a
     resize event

     Starts a dsp_backend object, that is, fire a separate thread and
     start rendering. This will set up a video mode, so it's very
     likely to fail if for some reason the video context isn't right,
     for instance if you try to set up graphical stuff but only have
     console access.

     *Return value:*  1 if success, 0 if error.

 -- Function: void lw6dsp_quit (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to stop

     Stops a dsp_backend, that is, cancel rendering and unset the video
     mode, hardware shouldn't be used any more after this call.

     *Return value:*  none.

 -- Function: int lw6dsp_update (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM)
     DSP_BACKEND:  the dsp_backend to update

     PARAM:  parameters to pass to the dsp_backend funcs

     Passes a new set of parameters to the display function.  This is
     in fact the only way to pass informations to the dsp_backend
     object once it's been started. This function will acquire a mutex,
     copy parameters, then give control back to the main thread while
     display keeps on going with new parameters in the background. It
     will get input informations.  You really must call it often
     otherwise the screen won't get updated, or, at least, it will
     always display the same informations.  It should be reasonnable to
     call this 10 or 20 times per second, the display itself can be
     faster, run at 60 or 100 fps to show smooth animation (eye candy).

     *Return value:*  1 if success, 0 if error.

 -- Function: int lw6dsp_get_nb_frames (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the number of frames displayed since the display was
     started.

     *Return value:*  the number of frames displayed.

 -- Function: int lw6dsp_get_last_frame_rendering_time
          (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the rendering time of the last frame. Gives clues about
     performance.

     *Return value:*  the number of milliseconds it took to draw screen

 -- Function: int lw6dsp_get_instant_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is the
     instant value, it changes very often even if display seems smooth.

     *Return value:*  the current instant display rate.

 -- Function: int lw6dsp_get_average_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is not
     absolutely accurate but fits for displaying info to the player,
     it's an average.

     *Return value:*  the current averaged display rate.

 -- Function: int lw6dsp_get_video_mode (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     DSP_BACKEND:  the dsp_backend to query

     VIDEO_MODE:  a structure which will contain the results

     Returns the current video mode, the one obtained by the driver.
     This function is also a way to know wether display is running
     correcly or not, by testing its return value.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: int lw6dsp_get_fullscreen_modes (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     DSP_BACKEND:  the dsp_backend to query

     FULLSCREEN_MODES:  a structure which will contain the results

     Returns the current available fullscreen modes. Note that this one
     will only work if display is started, unlike
     `lw6gfx_get_fullscreen_modes' which is used internally. The reason
     is that in this dsp module context, we need the thread to be
     launched, and the thread does start/stop display on its own.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: void lw6dsp_param_zero (lw6dsp_param_t * PARAM)
     PARAM:  the structure to initialize

     Fills a display param struct with zeros, this is mandatory before
     any use. Think of it as a raw memset.

     *Return value:*  none.

 -- Function: int lw6dsp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the test suite for the dsp module. In check (0) mode, won't
     test much to avoid failure because of missing graphical
     environment.

     *Return value:*  1 if OK, 0 if error.

4.15.7 libdyn
-------------

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend_so (char *
          SO_FILE)
     Opens a .so file directly, using a valid (full) path name.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend (int ARGC,
          char * [] ARGV, char * TOP_LEVEL_LIB, char * BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     Opens a .so file corresponding to the given backend, it is capable
     to search for system libraries installed after "make install" but
     if not found, it will also search in the current build directory,
     finding the .so files in hidden .libs subdirectories.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: int lw6dyn_dlclose_backend (lw6dyn_dl_handle_t * HANDLE)
     HANDLE:  the backend to close.

     Closes an opened backend. Note that you must call any backend
     specific clear, destroy, deinit, exit, function before.

     *Return value:*  1 if success, 0 on error.

 -- Function: void * lw6dyn_dlsym (lw6dyn_dl_handle_t * HANDLE, char *
          FUNC_NAME)
     HANDLE:  the backend concerned

     FUNC_NAME:  the function name, as a NULL terminated string

     Finds a C function in the given backend.

     *Return value:*  a pointer to the function, NULL if not found.

 -- Function: lw6sys_assoc_t * lw6dyn_list_backends (int ARGC, char *
          [] ARGV, char * TOP_LEVEL_LIB)
     ARGC:  the number of command line args, as passed to main

     ARGV:  the commind line args, as passed to main

     TOP_LEVEL_LIB:  the library category to query (gfx, snd, cli, srv
     ...)

     Returns an assoc which lists all the available modules. The key of
     the assoc entries in the module internal name such as 'gl' and the
     value associated is a NULL terminated string describing the
     module, for instance 'OpenGL'.

     *Return value:*  an assoc object containing key/label pairs.

 -- Function: char * lw6dyn_path_find_backend (int ARGC, char * []
          ARGV, char * TOP_LEVEL_LIB, char * BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     BACKEND_NAME:  the actual name of the backend, this is the name of
     the .so file, between "libmod_" and ".so". For instance, to find
     "libmod_gl.so", the right argument is "gl".

     Get the full path to a .so file corresponding to the given backend,
     it is capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current
     build directory, finding the .so files in hidden .libs
     subdirectories.

     *Return value:*  the full path of the .so file, needs to be freed.

 -- Function: int lw6dyn_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `dyn' module test suite, testing most (if not all...)
     functions. Will try to load libraries and query them for standard
     LW6-expected functions.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.8 libgfx
-------------

 -- Function: int lw6gfx_init (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     BACKEND:  the graphical backend to use

     VIDEO_MODE:  the video mode to use at start up

     RESIZE_CALLBACK:  a callback function which will be called at each
     resize event

     Sets up the graphical backend for good, initializing a video mode
     and allocating ressources. This call can typically fail if there's
     no device available, if the user doesn't have enough rights to
     access the hardware, and so on.

     *Return value:*  1 on success, 0 if not

 -- Function: void lw6gfx_quit (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to free

     Uninitializes the backend, that is, exits the graphical mode. All
     threads that use graphics must be closed when this is called.

     *Return value:*  none.

 -- Function: char * lw6gfx_repr (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to represent

     Returns a readable version of the backend object.

     *Return value:*  a newly allocated pointer.

 -- Function: int lw6gfx_set_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the new video mode

     This function changes the video mode. Note that the first time you
     set up the graphical environment you must call `lw6gfx_init' but
     to change the current mode, use this function. It should reload
     backend data automatically if needed (textures for instance). Note
     that before giving up and failing this function will try alternate
     video modes, and you're not garanteed to have the right mode after
     the call, even if it returns true. To check this, use
     `lw6gfx_get_video_mode'.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the current video mode (will be overwritten, out
     parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_fullscreen_modes (lw6gfx_backend_t *
          BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     BACKEND:  the backend to use

     FULLSCREEN_MODES:  the available fullscreen modes (will be
     overwritten, out parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: lw6gui_input_t * lw6gfx_pump_events (lw6gfx_backend_t *
          BACKEND)
     BACKEND:  the backend to use

     This function "pumps" events, that is gets pending events, puts
     them in queues, maintains internal states up to date. You really
     must call this very often or no input will be processed at all.

     *Return value:*  a pointer on the internal input state, musn't be
     freed.

 -- Function: int lw6gfx_display (lw6gfx_backend_t * BACKEND, int MASK,
          lw6gui_look_t * LOOK, lw6map_level_t * LEVEL,
          lw6ker_game_struct_t * GAME_STRUCT, lw6ker_game_state_t *
          GAME_STATE, lw6pil_local_cursors_t * LOCAL_CURSORS,
          lw6gui_menu_t * MENU, float PROGRESS, float FPS, float MPS,
          char ** LOG_LIST, int CAPTURE, int GFX_DEBUG, int
          DEBUG_TEAM_ID, int DEBUG_LAYER_ID)
     BACKEND:  the graphical backend to use

     MASK:  display flag, tells what to display

     LOOK:  the look, the skin, contains display options

     LEVEL:  the level to display

     GAME_STRUCT:  the game_struct associated with the level

     GAME_STATE:  the game_state associated with the level

     LOCAL_CURSORS:  the cursor to center the focus on

     MENU:  the menu to display

     PROGRESS:  the value of the progress indicator

     FPS:  the number of frames per second to display

     MPS:  the number of moves per second to display

     LOG_LIST:  log messages to display

     CAPTURE:  wether to enable capture mode or not

     GFX_DEBUG:  wether to enable gfx debugging tools

     DEBUG_TEAM_ID:  for debug display, team to display informations
     about

     DEBUG_LAYER_ID:  for debug display, layer to display

     This is the major drawing function, the one that encapsulates all
     others. As the program uses a separate thread to display things,
     we just pass this function many parameters, and let it do its job
     alone. So many parameters might sometimes be useless. It also
     allows the graphics backend decide wether menus and hud and
     background should interact. Or not.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6gfx_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `gfx' module test suite. In check-only mode, this
     function won't test many things, for it requires a graphical mode
     to be available to perform the complete test.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.9 libgui
-------------

 -- Function: void lw6gui_button_register_down (lw6gui_button_t *
          BUTTON, int64_t TIMESTAMP)
     BUTTON:  the button to update

     TIMESTAMP:  the current ticks (milliseconds)

     Registers a "down" (press) event on a button.

     *Return value:*  none.

 -- Function: void lw6gui_button_register_up (lw6gui_button_t * BUTTON)
     BUTTON:  the button to update

     Registers a "up" (release) event on a button.

     *Return value:*  none.

 -- Function: int lw6gui_button_is_pressed (lw6gui_button_t * BUTTON)
     BUTTON:  the button to query

     Tells wether a button is pressed or not.

     *Return value:*  1 if pressed, 0 if not.

 -- Function: int lw6gui_button_pop_press (lw6gui_button_t * BUTTON)
     BUTTON:  the button to query

     Tells how many times the button has been pressed. Typical usage:
     the button is pressed, released, pressed, released several times.
     Then, after all this, you want to know how many times it has been
     pressed.  Querying its state with `lw6gui_button_is_pressed' won't
     tell you much but this `pop_press' function will return 1 for each
     press there's been.

     *Return value:*  1 if there's a press event in the queue, 0 if
     empty.

 -- Function: void lw6gui_button_update_repeat (lw6gui_button_t *
          BUTTON, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     BUTTON:  the button to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a button, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_button_sync (lw6gui_button_t * DST,
          lw6gui_button_t * SRC)
     DST:  the target button object

     SRC:  the source button object

     Synchronizes two button objects. This is typically used to pass
     data from one thread to another. This is not a simple copy, it
     will handle data such as "when was it pressed last" it an
     intelligent manner, popping src data to put it in dst, and
     clearing src.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_coord_calc_xy (float * DST_X, float * DST_Y,
          float DST_X0, float DST_Y0, float DST_W, float DST_H, float
          SRC_X, float SRC_Y, float SRC_X0, float SRC_Y0, float SRC_W,
          float SRC_H)
     DST_X:  the x coord to return

     DST_Y:  the y coord to return

     DST_X0:  the x coord of point 0 in destination coord system

     DST_Y0:  the y coord of point 0 in destination coord system

     DST_W:  the width of the area in destination coord system

     DST_H:  the width of the area in destination coord system

     SRC_X:  the x coord in source coord system

     SRC_Y:  the y coord in source coord system

     SRC_X0:  the x coord of point 0 in source coord system

     SRC_Y0:  the y coord of point 0 in source coord system

     SRC_W:  the width of the area in source coord system

     SRC_H:  the width of the area in source coord system

     Registers a "down" (press) event on a button.

     *Return value:*  none.

 -- Function: int lw6gui_input_init (lw6gui_input_t * INPUT)
     INPUT:  the input struct to initialise

     Initialises an input structure, don't use twice, it won't free a
     previous init.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_input_quit (lw6gui_input_t * INPUT)
     INPUT:  the input struct to uninitialise

     Unitialises an input structure, need to call it to free event
     queue.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: lw6gui_input_t * lw6gui_input_new ()
     Creates an input structure, which can be used to handle input
     state & buffer.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_input_free (lw6gui_input_t * INPUT)
     INPUT:  the input object to free.

     Deletes an input structure.

     *Return value:*  none.

 -- Function: int lw6gui_input_reset (lw6gui_input_t * INPUT)
     INPUT:  the input struct to reset

     Resets an input structure. Must have been initialized before. It
     will empty all queues and mark everything as unpressed.

     *Return value:*  1 on success, 0 if failure.

 -- Function: void lw6gui_input_update_repeat (lw6gui_input_t * INPUT,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     INPUT:  the input to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for an input, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: void lw6gui_input_register_change (lw6gui_input_t * INPUT)
     INPUT:  the input to update

     Tells an input object that one of its descendants has been
     modified. This will affect the return value of
     `lw6gui_input_need_sync'

     *Return value:*  none.

 -- Function: int lw6gui_input_need_sync (lw6gui_input_t * INPUT)
     INPUT:  the input to test

     Tests wether an input object contains was modified and needs
     synchronisation.

     *Return value:*  1 if sync is need, 0 if not.

 -- Function: int lw6gui_input_sync (lw6gui_input_t * DST,
          lw6gui_input_t * SRC)
     DST:  the target input object

     SRC:  the source input object

     Synchronizes two input objects. This is typically used to pass
     data from one thread to another. This is not a copy, it will
     brute-force copy the static data such as mouse position, but
     anything like a queue will be treated in a "empty source and fill
     target with data" scheme. So source will be affected by this, the
     key buffer will be emptied, and so on.  And if there are key in
     the target buffer, they won't be overwritten but kept in front of
     the FIFO list.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_input_poll_quit (lw6gui_input_t * INPUT)
     INPUT:  the input to query

     Asks the display manager wether a quit event (usually CTRL-C or
     click on close button) has been detected.

     *Return value:*  1 if quit was receivedm 0 if not

 -- Function: void lw6gui_input_send_quit (lw6gui_input_t * INPUT)
     INPUT:  the input to send an event to

     Artificially send a QUIT event (equivalent of CTRL-C or click on
     close button). This allow a uniform treatment of game stopping.

     *Return value:*  none

 -- Function: int lw6gui_joystick_check_index (int I)
     I:  index to check

     Checks wether the index is correct. Does not mean the joystick
     exists, it's just to avoid out of bounds errors.

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_x (lw6gui_joystick_t *
          JOYSTICK, int X, int LIMIT, int64_t TIMESTAMP)
     JOYSTICK:  joystick to update

     X:  x-axis position, as returned by the driver

     LIMIT:  the limit, under this, buttons are considered unpressed.

     TIMESTAMP:  current ticks (timestamp in ms)

     Updates the x axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like
     information such as "pressed in that direction".

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_y (lw6gui_joystick_t *
          JOYSTICK, int Y, int LIMIT, int64_t TIMESTAMP)
     JOYSTICK:  joystick to update

     LIMIT:  the limit, under this, buttons are considered unpressed.

     TIMESTAMP:  current ticks (timestamp in ms)

     Updates the y axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like
     information such as "pressed in that direction".

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_repeat (lw6gui_joystick_t *
          JOYSTICK, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     JOYSTICK:  the joystick to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a joystick, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_joystick_sync (lw6gui_joystick_t * DST,
          lw6gui_joystick_t * SRC)
     DST:  the target joystick object

     SRC:  the source joystick object

     Synchronizes two joystick objects. This is typically used to pass
     data from one thread to another.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_joystick_get_move_pad (lw6gui_joystick_t *
          JOYSTICK, lw6gui_move_pad_t * MOVE_PAD)
     JOYSTICK:  the joystick to query

     MOVE_PAD:  the structure which will contain the results

     Returns the state of the joystick in a uniform, non-device
     specific structure containing only the up/down/left/right
     information.

     *Return value:*  none, the value are stored in `move_pad'.

 -- Function: int lw6gui_keyboard_check_keysym (int KEYSYM)
     KEYSYM:  the keysym to check

     Tells wether the keysym is valid or not.

     *Return value:*  1 if valid, 0 if not

 -- Function: lw6gui_keypress_t * lw6gui_keyboard_pop_keypress
          (lw6gui_keyboard_t * KEYBOARD)
     KEYBOARD:  the keyboard structure which stores keyboard state

     Pops (in FIFO mode) a keypress stored in the keyboard buffer. You
     must free the obtained keypress object after you're done with it.

     *Return value:*  a newly allocated pointer, or NULL if no keypress
     pending.

 -- Function: int lw6gui_keyboard_is_pressed (lw6gui_keyboard_t *
          KEYBOARD, int KEYSYM)
     KEYBOARD:  the keyboard structure which stores keyboard state

     Tells wether a key is pressed or not. The function will test out of
     bound values.

     *Return value:*  1 if pressed, 0 if not.

 -- Function: int lw6gui_keyboard_register_key_down (lw6gui_keyboard_t
          * KEYBOARD, int KEYSYM, int UNICODE, char * LABEL, int64_t
          TIMESTAMP)
     KEYBOARD:  the keyboard structure which will store the keypress

     KEYSYM:  the keysym for the keypress

     UNICODE:  the ASCII/unicode code for the keypress

     LABEL:  the label for the keypress

     TIMESTAMP:  the current ticks (timestamp in ms)

     Registers a keypress event, that is, puts it in the event queue.
     This function does not take an `lw6gui_keypress_t' structure but
     separated args, this is because it will construct the object
     internally. You may free `label' after calling this, an internal
     copy will be done.  This function will also maintain the array of
     key states up to date.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_keyboard_register_key_up (lw6gui_keyboard_t *
          KEYBOARD, int KEYSYM)
     KEYBOARD:  the keyboard structure which will store the keypress

     KEYSYM:  the keysym for the keypress

     Registers a key release event.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_keyboard_update_repeat (lw6gui_keyboard_t *
          KEYBOARD, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     KEYBOARD:  the keyboard to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a keyboard, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_keyboard_sync (lw6gui_keyboard_t * DST,
          lw6gui_keyboard_t * SRC)
     DST:  the target keyboard object

     SRC:  the source keyboard object

     Synchronizes two keyboard objects. This is typically used to pass
     data from one thread to another. Will pop the src queue to fill
     the dst queue.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_keyboard_get_move_pad (lw6gui_keyboard_t *
          KEYBOARD, lw6gui_move_pad_t * MOVE_PAD)
     KEYBOARD:  the keyboard to query

     MOVE_PAD:  the structure which will contain the results

     Returns the state of the keyboard in a uniform, non-device
     specific structure containing only the up/down/left/right
     information.

     *Return value:*  none, the value are stored in `move_pad'.

 -- Function: lw6gui_keypress_t * lw6gui_keypress_new (int KEYSYM, int
          UNICODE, char * LABEL)
     KEYSYM:  the keysym to use

     UNICODE:  the unicode value for this keysym

     LABEL:  the label (optional, might be NULL)

     Creates a keypress structure, the only reason for needing a
     contructor is that the label field needs be duplicated.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_keypress_free (lw6gui_keypress_t * KEYPRESS)
     KEYPRESS:  the keypress object to free.

     Deletes a keypress structure.

     *Return value:*  none.

 -- Function: char * lw6gui_keypress_repr (lw6gui_keypress_t * KEYPRESS)
     KEYPRESS:  the keypress to work on

     Returns a human-readable representation of the keypress.

     *Return value:*  a newly allocated string

 -- Function: lw6gui_menu_t * lw6gui_menu_new (char * TITLE, char *
          ESC, int ENABLE_ESC)
     TITLE:  the string to be displayed, what the user sees. Can be
     freed after the call is done, function will make a copy internally.

     ESC:  the label to be displayed in the ESC button

     ENABLE_ESC:  wether to enable the escape button.

     Constructs a new menu object. Note that you can always call other
     functions to modify it afterwards.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_menu_free (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Frees the menu, checking if things are OK before doing so.

     *Return value:*  none.

 -- Function: int lw6gui_menu_memory_footprint (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Gets the memory occupied by the menu. Could be usefull to help a
     garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:*  the number of bytes used.

 -- Function: char * lw6gui_menu_repr (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Constructs a readable description of the object. Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the
     object, but helps knowing what it is.

     *Return value:*  a string describing the object, must be freed.

 -- Function: void lw6gui_menu_set_title (lw6gui_menu_t * MENU, char *
          TITLE)
     MENU:  a pointer to the menu.

     TITLE:  the new title, you can free it after calling the function,
     an internal copy will be made.

     Change the title of the menu. That is to say, its title.  Use this
     function to change the title, don't try to access the struct
     directly. The idea is to have safe memory management.

     *Return value:*  none

 -- Function: lw6gui_menuitem_t * lw6gui_menu_get_item (lw6gui_menu_t *
          MENU, int POSITION)
     MENU:  the menu we want to query

     POSITION:  the order of the item we want

     Gets the menu item at the given position. First item is 0, last is
     N-1.  Returns a pointer on the real object, not a copy.

     *Return value:*  a pointer to a menu item, NULL if out of range.

 -- Function: int lw6gui_menu_select (lw6gui_menu_t * MENU, int
          POSITION, int ALLOW_SCROLL, int64_t NOW)
     MENU:  the menu we want to modify

     POSITION:  the position of the item we want to select

     ALLOW_SCROLL:  wether scrolling should be allowed when displaying
     it

     NOW:  the current time, as a timestamp.

     Selects the item at the given position. Use this function to be
     sure that only one item is selected, and all other states are
     consistent.  Timestamp is needed for the sake of eye-candy.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_select_esc (lw6gui_menu_t * MENU, int
          STATE, int64_t NOW)
     MENU:  the menu we want to modify

     STATE:  1 to select, 0 to unselect

     NOW:  the current time, as a timestamp.

     Selects the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:*  none.

 -- Function: void lw6gui_menu_enable_esc (lw6gui_menu_t * MENU, int
          STATE, int64_t NOW)
     MENU:  the menu we want to modify

     STATE:  1 to enable, 0 to disable

     NOW:  the current time, as a timestamp.

     Enables the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:*  none.

 -- Function: int lw6gui_menu_scroll_up (lw6gui_menu_t * MENU)
     MENU:  the menu to scroll

     Scrolls a menu up, used as a callback for mouse wheel up for
     instance.  The idea is just to decrement the first displayed item
     index.

     *Return value:*  1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_scroll_down (lw6gui_menu_t * MENU)
     MENU:  the menu to scroll

     Scrolls a menu down, used as a callback for mouse wheel down for
     instance.  The idea is just to increment the first displayed item
     index.

     *Return value:*  1 if OK, 0 if failed (out of range).

 -- Function: void lw6gui_menu_center (lw6gui_menu_t * MENU, int
          POSITION, int MAX_DISPLAYED_ITEMS)
     MENU:  the menu to center

     POSITION:  the position of the menuitem to be put in the center

     MAX_DISPLAYED_ITEMS:  the maximum number of items displayed

     Centers the menu on a given menuitem. Typically used when pushing
     a menu with a menuitem selected 'anywhere' in the list.

     *Return value:*  none.

 -- Function: int lw6gui_menu_insert (lw6gui_menu_t * MENU,
          lw6gui_menuitem_t * MENUITEM, int POSITION, int64_t NOW)
     MENU:  the menu we want to modify

     MENUITEM:  the item to insert

     POSITION:  the position the new item will occupy ("insert before"
     mode)

     NOW:  the current time, as a timestamp.

     Inserts the given item in the menu. All items starting at the
     insert position will be "pushed" (that is, their position
     incremented by 1).  Once the menuitem is inserted, the menu object
     will take care of memory management and automatically free it when
     needed.

     *Return value:*  1 if success, 0 if failure (memory problem, out
     of range).

 -- Function: int lw6gui_menu_append (lw6gui_menu_t * MENU,
          lw6gui_menuitem_t * MENUITEM, int64_t NOW)
     MENU:  the menu we want to modify

     MENUITEM:  the item to insert

     NOW:  the current time, as a timestamp.

     Appends the given item to the menu.  Once the menuitem is
     appended, the menu object will take care of memory management and
     automatically free it when needed.

     *Return value:*  1 if success, 0 if failure (memory problem).

 -- Function: int lw6gui_menu_remove (lw6gui_menu_t * MENU, int
          POSITION, int64_t NOW)
     MENU:  the menu we want to modify

     POSITION:  the item to insert

     NOW:  the current time, as a timestamp.

     Removes an item from the menu. It will automatically be freed.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_update_display_range (lw6gui_menu_t *
          MENU, int MAX_DISPLAYED_ITEMS)
     MENU:  the menu concerned

     MAX_DISPLAYED_ITEMS:  the maximum number of items to display at
     once

     Updates the display range. The reason for having this is that the
     first item, that is, how far we scroll in a very long menu, depends
     on the previous position. Plus you have to handle limit cases
     (begin/end).  Thus, this function, which will automatically
     pick-up a suitable position. Of course, `first_item_displayed' is
     not necessarly equal to `selected_item'.

     *Return value:*  none.

 -- Function: int lw6gui_menu_insert_for_id_use (lw6gui_menu_t * MENU,
          char * LABEL, int VALUE, int ENABLED, int SELECTED, int
          COLORED, int POSITION, int64_t NOW)
     MENU:  the menu to work on

     LABEL:  the label of the menuitem to append

     VALUE:  the value of the menuitem to append

     ENABLED:  wether the inserted menuitem should be enabled

     SELECTED:  wether the inserted menuitem should be selected

     COLORED:  wether the inserted menuitem should use value as its
     color

     NOW:  current time (timestamp)

     Inserts a menu item at the given position. The idea is that the
     menu item object is automatically constructed on the fly, and an
     id is returned, which can be passed to '_using_id' menu-related
     functions. This is typically for using in scripts. The idea is
     that the script just keeps a copy of the id returned, and can this
     way operate directly on the menuitem without keeping a pointer, a
     smob or anything internally. From the C point of view, having a
     real C structure enables persistent data from one display to the
     other, and this is nice and conveninent. I acknowledge the
     prototype is scary.

     *Return value:*  0 if error, or else an id which will later be
     used with '_using_id' functions.

 -- Function: int lw6gui_menu_append_for_id_use (lw6gui_menu_t * MENU,
          char * LABEL, int VALUE, int ENABLED, int SELECTED, int
          COLORED, int64_t NOW)
     MENU:  the menu to work on

     LABEL:  the label of the menuitem to append

     VALUE:  the value of the menuitem to append

     ENABLED:  wether the appended menuitem should be enabled

     SELECTED:  wether the appended menuitem should be selected

     COLORED:  wether the appended menuitem should use value as its
     color

     NOW:  current time (timestamp)

     Appends a menuitem using the same logic as
     `lw6gui_menu_insert_for_id_use' that is to say a parameter is
     returned which can later be used to directly operate on a given
     menuitem, without having its pointer, and even if its position
     changes.

     *Return value:*  0 if error, or else an id which will later be
     used with '_using_id' functions.

 -- Function: int lw6gui_menu_remove_using_id (lw6gui_menu_t * MENU,
          int MENUITEM_ID, int64_t NOW)
     MENU:  the menu to work on

     MENUITEM_ID:  the id of the menuitem to remove

     NOW:  current time (timestamp)

     Deletes the menuitem with the given id. Very important: the id is
     not the position. Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_sync_using_id (lw6gui_menu_t * MENU, int
          MENUITEM_ID, char * LABEL, int VALUE, int ENABLED, int
          SELECTED, int COLORED, int64_t NOW)
     MENU:  the menu to work on

     MENUITEM_ID:  the id of the menuitem to synchronize

     NOW:  current time (timestamp)

     Updates the menuitem with the given id. Very important: the id is
     not the position. Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.  In practice, it's heavily used
     in the game to transmit informations from the scripts to the core
     C engine. Additionnaly, this function will automatically
     synchronize the `selected_item' field of the menu struct.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_is_same (lw6gui_menu_t * MENU_A,
          lw6gui_menu_t * MENU_B)
     MENU_A:  first item to compare

     MENU_B:  second item to compare

     Compares two menus.

     *Return value:*  1 if they are the same, 0 if not

 -- Function: lw6gui_menu_t * lw6gui_menu_dup (lw6gui_menu_t * MENU)
     MENU:  the menu to duplicate

     Duplicates a menu structure.

     *Return value:*  a pointer to the new menu.

 -- Function: int lw6gui_menu_sync (lw6gui_menu_t * DST, lw6gui_menu_t
          * SRC)
     DST:  the target menu

     SRC:  the source menu

     Synchronizes two menus, this supposes that they represent the same
     menu, but simply in a different state. This function does not
     really copy src to dst, it has a special behavior, indeed
     everything is copied from src to dst, except the
     `first_item_displayed' and `nb_items_displayed' which are taken
     from dst and copied to src. This is because in practise, those
     values are updated in the display loop/thread, which is the one
     which uses the target. This is not very orthodox, but should work.

     *Return value:*  1 if success, 0 if failure

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_new (char * LABEL,
          int VALUE, int ENABLED, int SELECTED, int COLORED)
     LABEL:  the string to be displayed, what the user sees. Can be
     freed after the call is done, function will make a copy internally.

     VALUE:  the value. No GUI function uses this, this is the "real"
     value associated to the item.

     ENABLED:  wether the menu item can be selected, used, and so on

     SELECTED:  wether the menu item is the item selected among all
     menu items.

     COLORED:  wetherr the menu item must, when drawn, be colored
     according to its value.

     Constructs a new menuitem object. Note that you can always call
     other functions to modify these values afterwards, this might
     change rendering since `lw6gui_menuitem_set_value' or
     `lw6gui_menuitem_set_label' will, for instance, modify the "when
     was that item last modified" information.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_menuitem_free (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Frees the menuitem, checking if things are OK before doing so.

     *Return value:*  none.

 -- Function: int lw6gui_menuitem_memory_footprint (lw6gui_menuitem_t *
          MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Gets the memory occupied by the menuitem. Could be usefull to help
     a garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:*  the number of bytes used.

 -- Function: char * lw6gui_menuitem_repr (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Constructs a readable description of the object. Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the
     object, but helps knowing what it is.

     *Return value:*  a string describing the object, must be freed.

 -- Function: void lw6gui_menuitem_set_label (lw6gui_menuitem_t *
          MENUITEM, char * LABEL, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     LABEL:  the new label, you can free it after calling the function,
     an internal copy will be made.

     NOW:  the current time, as a timestamp.

     Change the label of the menu item. That is to say, what the user
     sees.  Use this function to change the menuitem value, don't try
     to access the struct directly. The idea is 1) to have safe memory
     management and 2) to keep the `last_change' member up to date.  It
     can be later used for eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_set_value (lw6gui_menuitem_t *
          MENUITEM, int VALUE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     NOW:  the current time, as a timestamp.

     Changes the value of a menuitem. This is the internal value, not
     what the user sees. Use this function to change the menuitem
     value, don't try to access the struct directly. The idea is to keep
     the `last_change' member up to date.  It can be later used for
     eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_select (lw6gui_menuitem_t *
          MENUITEM, int STATE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     STATE:  1 to select, 0 to unselect

     NOW:  the current time, as a timestamp.

     Switches the menuitem to (un)selected state. Use this function,
     don't try to modify the struct members directly. The idea is to
     have the `last_select' parameter up to date.  It can be later used
     for eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_enable (lw6gui_menuitem_t *
          MENUITEM, int STATE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     STATE:  1 to enable, 0 to disable

     NOW:  the current time, as a timestamp.

     Switches the menuitem to enabled/disabled state. Use this
     function, don't try to modify the struct members directly. The
     idea is to have the `last_select' parameter up to date.  It can be
     later used for eye-candy effects.

     *Return value:*  none

 -- Function: u_int32_t lw6gui_menuitem_checksum (lw6gui_menuitem_t *
          MENUITEM, lw6gui_look_t * LOOK)
     MENUITEM:  the menuitem we want to identify

     Returns a checksum which can be used to know, for instance, wether
     the menuitem has changed or not, and if we should redraw it.

     *Return value:*  a checksum.

 -- Function: int lw6gui_menuitem_is_same (lw6gui_menuitem_t *
          MENUITEM_A, lw6gui_menuitem_t * MENUITEM_B)
     MENUITEM_A:  first item to compare

     MENUITEM_B:  second item to compare

     Compares two menuitems.

     *Return value:*  1 if they are the same, 0 if not

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_dup
          (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  the menuitem to duplicate

     The menuitem to duplicate.

     *Return value:*  a pointer to the duplicted menuitem.

 -- Function: int lw6gui_menuitem_sync (lw6gui_menuitem_t * DST,
          lw6gui_menuitem_t * SRC)
     DST:  the target menuitem

     SRC:  the source menuitem

     Synchronizes two menuitems, this supposes that they represent the
     same item, but simply in a different state.

     *Return value:*  1 if success, 0 if failure

 -- Function: void lw6gui_mouse_register_move (lw6gui_mouse_t * MOUSE,
          int X, int Y, int64_t TIMESTAMP)
     MOUSE:  the mouse object to work on

     X:  the x position

     Y:  the y position

     TIMESTAMP:  current timestamp

     Registers a mouse move event.

     *Return value:*  note.

 -- Function: int lw6gui_mouse_poll_move (lw6gui_mouse_t * MOUSE, int *
          X, int * Y)
     MOUSE:  the mouse object to poll

     X:  pointer to the x position (can be NULL), will be updated even
     if no move

     Y:  pointer to the y position (can be NULL), will be updated even
     if no move

     Asks wether the mouse has moved or not.

     *Return value:*  1 if mouse was moved since last call, 0 if not.

 -- Function: void lw6gui_mouse_update_repeat (lw6gui_mouse_t * MOUSE,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     MOUSE:  the mouse to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a mouse, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_mouse_sync (lw6gui_mouse_t * DST,
          lw6gui_mouse_t * SRC)
     DST:  the target mouse object

     SRC:  the source mouse object

     Synchronizes two mouse objects. This is typically used to pass
     data from one thread to another. Will handle "mouse move"
     attribute and clear it in src if needed while setting it in dst.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_smoother_init (lw6gui_smoother_t * SMOOTHER,
          float VALUE, int DURATION)
     SMOOTHER:  the structure to initialize

     VALUE:  the value to use for now

     DURATION:  the duration of a standard move, in ticks (msec)

     Initializes a smoother object, with a default value. The important
     point is the duration which will condition all the behavior of the
     object.

     *Return value:*  none.

 -- Function: void lw6gui_smoother_immediate_force (lw6gui_smoother_t *
          SMOOTHER, float VALUE)
     SMOOTHER:  the structure to use

     VALUE:  the target value

     Forces a smoother object to immediately point on a value.

     *Return value:*  none.

 -- Function: void lw6gui_smoother_set_target (lw6gui_smoother_t *
          SMOOTHER, float VALUE, int64_t NOW)
     SMOOTHER:  the structure to use

     VALUE:  the target value

     NOW:  the current timestamp

     Sets a new target, will automatically calculate current speed to
     smooth the next returned values.

     *Return value:*  none.

 -- Function: float lw6gui_smoother_get_value (lw6gui_smoother_t *
          SMOOTHER, int64_t NOW)
     SMOOTHER:  the structure to use

     NOW:  the current timestamp

     Returns the current value of the smoother.

     *Return value:*  a float.

 -- Function: int lw6gui_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Run tests in the gui module.

     *Return value:*  1 if successfull, 0 if failed.

 -- Function: int lw6gui_video_mode_find_closest (lw6gui_video_mode_t *
          CLOSEST, lw6gui_video_mode_t * WISHED, lw6sys_list_t *
          AVAILABLE)
     CLOSEST:  the closest video_mode found

     WISHED:  the wished video_mode

     AVAILABLE:  a list of available video_modes (list of
     lw6gui_video_mode_t *)

     Finds the closest video_mode available, this is just a small
     utility to cope with different screen shapes and avoid requesting
     640x480 when it's just not available but there's a 640x400 instead.

     *Return value:*  1 if the wished video_mode exists in available
     list and was found, else 0 if the wished video_mode doesn't exist
     and an approximative match was picked.

 -- Function: int lw6gui_video_mode_is_same (lw6gui_video_mode_t *
          MODE_A, lw6gui_video_mode_t * MODE_B)
     MODE_A:  first mode to compare

     MODE_B:  second mode to compare

     Compares two video modes, to know if they're the same.

     *Return value:*  1 if equal, 0 if not.

 -- Function: int lw6gui_video_mode_sync_ratio (lw6gui_video_mode_t *
          DST, lw6gui_video_mode_t * SRC)
     DST:  the target video mode

     SRC:  the source video mode

     Applies the ratio of src to dst, for instance if src is 16/9, then
     dst will be made 16/9 too, trying to keep the same surface.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6gui_viewport_init (lw6gui_viewport_t * VIEWPORT,
          int SCREEN_W, int SCREEN_H, float DRAWABLE_X1, float
          DRAWABLE_Y1, float DRAWABLE_X2, float DRAWABLE_Y2, float
          CENTER_X, float CENTER_Y, int MAP_W, int MAP_H, int
          X_POLARITY, int Y_POLARITY, int X_WRAP, int Y_WRAP, int
          KEEP_RATIO, float GLOBAL_ZOOM)
     VIEWPORT:  the viewport to initalize

     SCREEN_W:  screen width

     SCREEN_H:  screen height

     DRAWABLE_X1:  viewport min x

     DRAWABLE_Y1:  viewport min y

     DRAWABLE_X2:  viewport max x

     DRAWABLE_Y2:  viewport max y

     CENTER_X:  center of display (in map coordinates)

     CENTER_Y:  center of display (in map coordinates)

     MAP_W:  map width (shape)

     MAP_H:  map height (shape)

     X_POLARITY:  x polarity

     Y_POLARITY:  y polarity

     X_WRAP:  wether to wrap horizontally

     Y_WRAP:  wether to wrap vertically

     KEEP_RATIO:  wether to adapt to viewport shape or keep original

     GLOBAL_ZOOM:  global zoom is style_zoom * dynamic_zoom

     Initializes all the (jumbo?) viewport structure which will contain
     valuable informations for a simple "flat" display.  Special
     renderers might not find usefull some fields and handle wrapping
     and zooming their own way, but this offers a basic skeleton.

     *Return value:*  1 if ok, 0 on failure

 -- Function: void lw6gui_viewport_map_to_screen (lw6gui_viewport_t *
          VIEWPORT, float * SCREEN_X, float * SCREEN_Y, float MAP_X,
          float MAP_Y, int CLIP)
     VIEWPORT:  the viewport to use

     SCREEN_X:  the x coord on the screen

     SCREEN_Y:  the y coord on the screen

     MAP_X:  the x coord in map coordinates

     MAP_Y:  the y coord in map coordinates

     CLIP:  wether to clip returned values

     Translates from map coords to screen coords. Returned values might
     be outside screen boundaries if clip is 0. If screen coords are
     outside drawable area anc clip is 1, then they will be clipped.

     *Return value:*  NULL

 -- Function: void lw6gui_viewport_screen_to_map (lw6gui_viewport_t *
          VIEWPORT, float * MAP_X, float * MAP_Y, float SCREEN_X, float
          SCREEN_Y, int WRAP)
     VIEWPORT:  the viewport to use

     MAP_X:  the x coord in map coordinates

     MAP_Y:  the y coord in map coordinates

     SCREEN_X:  the x coord on the screen

     SCREEN_Y:  the y coord on the screen

     WRAP:  wether to use polarity informations to wrap coords.

     Translates from screen coords to map coords. If wrap is set, it
     will interpret coords the way `lw6map_coords_fix_xy' would, only
     it can still be formally outside map boundaries for it can return
     a value exactly equal to w,h while in interger mode it would be
     w-1,h-1.

     *Return value:*  NULL

 -- Function: void lw6gui_zone_init_x1y1x2y2 (lw6gui_zone_t * ZONE,
          float X1, float Y1, float X2, float Y2)
     ZONE:  the structure to initialize

     X1:  x for top left corner

     Y1:  y for top left corner

     X2:  x for bottom right corner

     Y2:  y for bottom right corner

     Initializes a zone structure, will calculate w & h.

     *Return value:*  none.

 -- Function: void lw6gui_zone_init_xywh (lw6gui_zone_t * ZONE, float
          X, float Y, float W, float H)
     ZONE:  the structure to initialize

     X:  x for top left corner

     Y:  y for top left corner

     W:  width

     H:  height

     Initializes a zone structure, will calculate x2 & y2.

     *Return value:*  none.

 -- Function: void lw6gui_zone_clip (lw6gui_zone_t * DST, lw6gui_zone_t
          * SRC, lw6gui_zone_t * CLIP)
     DST:  the structure which will contain the result

     SRC:  the source zone

     CLIP:  the clipping zone (boundaries)

     Clips a zone (think of rectangle clips).

     *Return value:*  none.

4.15.10 libhlp
--------------

 -- Function: int lw6hlp_is_documented (char * KEYWORD)
     KEYWORD:  the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:*  1 if documented, 0 if not.

 -- Function: char * lw6hlp_about (lw6hlp_type_t * TYPE, char **
          DEFAULT_VALUE, int * MIN_VALUE, int * MAX_VALUE, char *
          KEYWORD)
     TYPE:  the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE:  the default value for the keyword, will be written

     MIN_VALUE:  the min value for the keyword, will be written

     MAX_VALUE:  the max value for the keyword, will be written

     KEYWORD:  the keyword we want help about

     Returns the documentation string associated to a keyword. The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without
     checking it. String is localized if a translation is available.
     It's safe to call this function with type or other parameters
     being NULL.

     *Return value:*  a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (char * KEYWORD)
     KEYWORD:  the keyword we want the type of

     Returns the type of a keyword. Calls lw6hlp_about internally.

     *Return value:*  the type, might be LW6HLP_TYPE_VOID.

 -- Function: char * lw6hlp_get_default_value (char * KEYWORD)
     KEYWORD:  the keyword we want the default for

     Returns the default value for a keyword. Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:*  a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (char * KEYWORD)
     KEYWORD:  the keyword we want the min for

     Returns the min value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: int lw6hlp_get_max_value (char * KEYWORD)
     KEYWORD:  the keyword we want the max for

     Returns the max value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: char * lw6hlp_get_credits (int ID)
     ID:  the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on. One can pass an arbitraty high `id', no
     risk.

     *Return value:*  the string, must be freed.

 -- Function: int lw6hlp_match (char * KEYWORD1, char * KEYWORD2)
     KEYWORD1:  the 1st keyword

     KEYWORD2:  the 2nd keyword

     Checks wether a keyword matches another. Not only a string
     comparison, will also try and guess if the error is only about
     dash "-" replaced by underscode "_", for instance.

     *Return value:*  1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list ()
     Returns a list of all available keywords.

     *Return value:*  a list containing all the keywords. Strings are
     not dynamically allocated, you can't modify them.

 -- Function: void lw6hlp_print_keyword (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list. One keyword per line.

     *Return value:*  none.

 -- Function: void lw6hlp_print_content (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file. Output is formatted to fit on the
     standard terminal/console.

     *Return value:*  none.

 -- Function: void lw6hlp_print_about (char * KEYWORD, FILE * F)
     KEYWORD:  the keyword to print help about

     F:  the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:*  none

 -- Function: int lw6hlp_reference_init ()
     Initializes the help reference, this must be called before any
     call to lw6hlp_about or such help related functions.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit ()
     Un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:*  1 on success, 0 if failed

 -- Function: int lw6hlp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `hlp' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.11 libimg
--------------

 -- Function: int lw6img_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `img' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.12 libker
--------------

 -- Function: int lw6ker_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ker' module test suite. Will perform deep checksums and
     *really* check many things. If this passes, the algorithm is fine.
     What could make it fail is a serious bug and/or some weird
     combination of endianess, byte alignment...

     *Return value:*  1 if test is successfull, 0 on error.

4.15.13 libldr
--------------

 -- Function: int lw6ldr_body_read (lw6map_body_t * BODY, char *
          DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float RATIO, int BENCH_VALUE, int
          MAGIC_NUMBER, lw6sys_progress_t * PROGRESS)
     BODY:  the body to read, must point to allocated memory

     DIRNAME:  the directory of the map

     PARAM:  map parameters

     HINTS:  map hints

     DISPLAY_W:  the display width

     DISPLAY_H:  the display height

     RATIO:  wished map ratio

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6map_style_t * STYLE,
          lw6ldr_hints_t * HINTS)
     STYLE:  the style structure to process.

     HINTS:  additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed. The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed. Note that the background
     color itself is not changed by this function. Background can only
     be guessed from texture.

     *Return value:*  none.

 -- Function: void lw6ldr_free_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to free

     Frees a map entry.

     *Return value:*  none.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (char * MAP_PATH, char
          * RELATIVE_PATH)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     Lists all maps in a given directory. Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps. Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:*  a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (char * MAP_PATH, char *
          RELATIVE_PATH, int RECURSIVE, lw6sys_list_callback_func_t
          CALLBACK_FUNC, void * FUNC_DATA)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     RECURSIVE:  if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC:  the function which will be called on each entry

     FUNC_DATA:  an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:*  none.

 -- Function: int lw6ldr_grease_apply (lw6map_layer_t * LAYER,
          lw6map_rules_t * RULES, lw6ldr_hints_t * HINTS,
          lw6sys_progress_t * PROGRESS)
     LAYER:  the layer on which to apply the grease

     RULES:  map rules

     HINTS:  map hints

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: int lw6ldr_hints_read (lw6ldr_hints_t * HINTS, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the hints (hints.xml) of a map. Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6ldr_hints_t * HINTS, char * KEY,
          char * VALUE)
     HINTS:  the hints to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a hints structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_hints_update (lw6ldr_hints_t * HINTS,
          lw6sys_assoc_t * VALUES)
     HINTS:  the hints struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides hints with values. Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_meta_layer_read (lw6map_meta_layer_t *
          META_LAYER, char * FILENAME, int TARGET_W, int TARGET_H, int
          ANALOG)
     META_LAYER:  the meta layer to read

     FILENAME:  the file to open

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6map_meta_layer_t
          * META_LAYER, char * DIRNAME, char * FILE_ONLY, int TARGET_W,
          int TARGET_H, int ANALOG)
     META_LAYER:  the meta layer to read

     DIRNAME:  the map directory

     FILE_ONLY:  the meta-layer file name only (without the path)

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters. This function is different from
     `lw6ldr_meta_layer_read' for it will 1) concatenate `dirname' and
     `file_only' and 2) return OK (1) if file does not exist.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_param_read (lw6map_param_t * PARAM, char *
          DIRNAME)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     DIRNAME:  the directory of the map

     Read the parameters associated to a map. Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6map_param_t * PARAM,
          lw6sys_assoc_t * VALUES)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides param with values. Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:*  1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_hints_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_style_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map style.xml file.

     *Return value:*  none.

 -- Function: int lw6ldr_print_examples (char * USER_DIR)
     USER_DIR:  the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (char * DIRNAME,
          lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t *
          FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, lw6sys_progress_t * PROGRESS)
     DIRNAME:  the directory containing the map

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  information used to handle the progress bar

     Loads a map from dist. The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps. 1st, a default value is picked by
     the program.  2nd, any value in `default_param' replaces previous
     values. 3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in `forced_param' replaces previous
     values. In practice, the `default_param' allows the user to set
     defaults which can still be overwritten by the map, while
     `forced_param' is a definitive 'ignore what is is defined in the
     map' way of doing things.  See also `lw6ldr_read_relative'.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (char * MAP_PATH,
          char * RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM,
          lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H,
          int BENCH_VALUE, int MAGIC_NUMBER, lw6sys_progress_t *
          PROGRESS)
     MAP_PATH:  a collection of paths where to find maps

     RELATIVE_PATH:  something which will be appended to a `map_path'
     member

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file. `default_param' and `forced_param'
     work as in the function `lw6ldr_read'.

     *Return value:*  1 if success, 0 if failure.

 -- Function: int lw6ldr_rules_read (lw6map_rules_t * RULES, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the rules (rules.xml) of a map. Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6map_rules_t * RULES,
          lw6sys_assoc_t * VALUES)
     RULES:  the rules struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides rules with values. Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6map_style_t * STYLE, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the style (style.xml) of a map. Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6map_style_t * STYLE, char * KEY,
          char * VALUE)
     STYLE:  the style to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a style structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6map_style_t * STYLE,
          lw6sys_assoc_t * VALUES)
     STYLE:  the style struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides style with values. Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ldr' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_use_update (lw6ldr_use_t * USE, lw6sys_assoc_t
          * VALUES)
     USE:  the use struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides use with values. Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:*  1 if success, 0 if failed.

4.15.14 libmap
--------------

 -- Function: void lw6map_body_builtin_custom (lw6map_body_t * BODY,
          int W, int H, int D, int NOISE_PERCENT, lw6map_rules_t *
          RULES)
     BODY:  the body to initialize

     W:  the width

     H:  the height

     D:  the depth

     NOISE_PERCENT:  the noise level to fill meta layers with

     RULES:  the map rules

     Sets up a default body structure.

     *Return value:*  none

 -- Function: void lw6map_body_clear (lw6map_body_t * BODY)
     BODY:  the structure to clear

     Clears a body structure.

     *Return value:*  none.

 -- Function: void lw6map_body_fix_checksum (lw6map_body_t * BODY)
     BODY:  the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:*  none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6map_body_t *
          BODY, lw6map_rules_t * RULES)
     BODY:  the structure to update

     RULES:  the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected. If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:*  none.

 -- Function: int lw6map_body_coord_from_texture (lw6map_level_t *
          LEVEL, int * BODY_X, int * BODY_Y, int TEXTURE_X, int
          TEXTURE_Y)
     LEVEL:  the level to work on

     BODY_X:  the body (logical) x coord

     BODY_Y:  the body (logical) y coord

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:*  1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6map_level_t * LEVEL, int TEXTURE_X, int TEXTURE_Y, int Z)
     LEVEL:  the level to work on

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Z:  the z position (depth related)

     Tells wether a given map position is free or not, but using
     texture coords.

     *Return value:*  1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6map_color_couple_t * COLOR)
     COLOR:  the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:*  none.

 -- Function: int lw6map_color_is_same (lw6map_color_couple_t * COLOR1,
          lw6map_color_couple_t * COLOR2)
     COLOR1:  1st color to compare

     COLOR2:  2nd color to compare

     Compares two colors.

     *Return value:*  1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (char * KEY)
     KEY:  key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:*  an integer.

 -- Function: lw6map_level_t * lw6map_dup (lw6map_level_t * SOURCE,
          lw6sys_progress_t * PROGRESS)
     SOURCE:  the map to copy

     PROGRESS:  to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:*  a newly allocated map, may be NULL.

 -- Function: char * lw6map_to_hexa (lw6map_level_t * LEVEL)
     Converts a map to something that is later readable by
     `lw6map_from_hexa' to reproduce the exact same map. Just a
     serializer.

     *Return value:*  a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (char * HEXA)
     HEXA:  an hexadecimal ASCII string, created by `lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     `lw6map_to_hexa'. Just an un-serializer.

     *Return value:*  a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6map_layer_t * LAYER,
          int W, int H)
     LAYER:  the layer to init

     W:  width

     H:  height

     Creates a default layer. This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:*  none

 -- Function: void lw6map_layer_clear (lw6map_layer_t * LAYER)
     LAYER:  the layer to init

     Clears a layer struct. This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:*  none

 -- Function: lw6map_level_t * lw6map_new ()
     Creates a new empty map. This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:*  a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults ()
     Creates a map, set to defaults. This is usefull mostly for testing.
     This builtin map has walls, paths, it's playable.

     *Return value:*  a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (int W, int H, int
          D, int NOISE_PERCENT)
     W:  the width of the map

     H:  the height of the map

     D:  the depth (number of layers) of the map

     NOISE_PERCENT:  percentage of noise to use for metalayers

     Creates a map, set to defaults. This is usefull mostly for testing.
     This one, unlike `lw6map_builtin_defaults'  will let you give a
     width, height and a depth.

     *Return value:*  a newly allocated map.

 -- Function: void lw6map_free (lw6map_level_t * LEVEL)
     Frees a map and releases all its internal ressources.

     *Return value:*  none.

 -- Function: int lw6map_memory_footprint (lw6map_level_t * LEVEL)
     Reports how many bytes the map needs, in memory. Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6map_level_t * LEVEL)
     Returns a string describing the map. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: int lw6map_is_same (lw6map_level_t * LEVEL_A,
          lw6map_level_t * LEVEL_B)
     LEVEL_A:  the first level to compare

     LEVEL_B:  the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:*  1 if they're the same, 0 if not.

 -- Function: int lw6map_local_info_set_music_dir (lw6map_local_info_t
          * LOCAL_INFO, char * MUSIC_DIR)
     LOCAL_INFO:  the structure to modify

     MUSIC_DIR:  the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6map_local_info_t *
          LOCAL_INFO)
     LOCAL_INFO:  the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:*  none

 -- Function: void lw6map_meta_layer_set (lw6map_meta_layer_t *
          META_LAYER, int X, int Y, u_int8_t VALUE)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     VALUE:  the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:*  none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6map_meta_layer_t *
          META_LAYER, int X, int Y)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     Simple getter for the meta_layer struct.

     *Return value:*  the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6map_meta_layer_t *
          META_LAYER)
     META_LAYER:  the meta_layer to clear

     Clears a meta_layer struct. This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:*  none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6map_meta_layer_t
          * META_LAYER, int W, int H, int ANALOG, int NOISE_PERCENT,
          int SEED)
     META_LAYER:  the object to init

     W:  width

     H:  height

     ANALOG:  wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT:  the quantity of noise to initialise the layer with

     SEED:  a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with. If noise is 100
     then metalayer is "full". If noise is 0, then meta layer is empty.

     *Return value:*  1 if OK, 0 on failure.

 -- Function: void lw6map_param_defaults (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:*  none

 -- Function: void lw6map_param_clear (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Resets a param structure to nothing. Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:*  none

 -- Function: void lw6map_param_copy (lw6map_param_t * DST,
          lw6map_param_t * SRC)
     DST:  the destination param struct

     SRC:  the source param struct

     Copies parameters. Both structures must be zeroed or correctly
     initialized.

     *Return value:*  none

 -- Function: int lw6map_param_set (lw6map_param_t * PARAM, char * KEY,
          char * VALUE)
     PARAM:  the param struct to modify

     KEY:  the name of the parameter to modify

     VALUE:  the value of the parameter to modify

     Sets an entry in a param struct. All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance. It will also dispatch
     automatically between rules and style.

     *Return value:*  1 if parameter successfully set, 0 on error.

 -- Function: int lw6map_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `map' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.15 libnet
--------------

 -- Function: int lw6net_last_error ()
     Reports the last network error. This is basically a debug function,
     designed mostly for Microsoft Winsock API, but can be safely called
     on any platform.

     *Return value:*  the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local ()
     Guess the local IP address. This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on. But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed. Will return NULL if interface can't
     be guessed.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (char * BIND_IP, int
          BIND_PORT)
     BIND_IP:  the IP address used to bind on

     BIND_PORT:  the IP port used to bind on

     Guess the server public url, based on `lw6net_if_guess_local'
     which tries to find a valid local IP address which is not
     loopback. This is only in case `bind_ip' is 0.0.0.0 (listen on all
     addresses) else it will just use `bind_ip' as you would expect.
     Function isn't foolproof, that's why one can override its default
     with a user settings.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (int SOCK)
     SOCK:  the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (int SOCK, char * LINE)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket,
     that is, stream oriented. The "\n" is automatically added, do not
     bother sending it.

     *Return value:*  non-zero if success

 -- Function: char * lw6net_recv_line_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_udp (int SOCK, char * LINE, char *
          IP, int PORT)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     IP:  the IP address of the target

     PORT:  the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket,
     that is, datagram oriented. The "\n" is automatically added, do
     not bother sending it.

     *Return value:*  the number of bytes sent, 0 if failure

 -- Function: char * lw6net_password_checksum (char * SEED, char *
          PASSWORD)
     SEED:  a seed to blur the password, can be NULL

     PASSWORD:  the password, can be NULL

     Calculates the checksum of a password, and returns it as a string,
     ready to be sent on the network.  If password is empty or NULL,
     then an empty (but not NULL unless internal error) string will be
     returned. All LW6 protocols should send these checksums instead of
     real passwords, then on server side value can be checked against
     both real password and its checksum. The seed is here so that
     eavesdropper can't reuse the checksum to connect on random
     sessions. Seed can typically be the node 'public_url' value.

     *Return value:*  a dynamically allocated string

 -- Function: int lw6net_password_verify (char * SEED, char *
          PASSWORD_HERE, char * PASSWORD_RECEIVED)
     SEED:  a seed to blur the password, can be NULL

     PASSWORD_HERE:  the local password, can be NULL

     PASSWORD_RECEIVED:  the password received from network

     Tells wether a password received over the network is valid.  The
     `password_here' argument (the local password) will be checksumed
     so that `password_received' is checked against both clear and
     checksumed values, so it can be in any form.

     *Return value:*  1 if OK, passwords are the same, 0 if not.

 -- Function: int lw6net_init (int ARGC, char * [] ARGV)
     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:*  non-zero if success

 -- Function: void lw6net_quit ()
     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:*  void

 -- Function: int lw6net_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `net' module test suite. This one could fail if some
     sockets are already bound, for instance. It's still run even in
     check-only (mode=0) mode.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.16 libnod
--------------

 -- Function: void lw6nod_dyn_info_free (lw6nod_dyn_info_t * DYN_INFO)
     DYN_INFO:  the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     `lw6nod_info_dup_dyn' for instance.

     *Return value:*  none

 -- Function: lw6nod_info_t * lw6nod_info_new (u_int64_t ID, char *
          URL, char * TITLE, char * DESCRIPTION, int BENCH, int
          IDLE_SCREENSHOT_SIZE, void * IDLE_SCREENSHOT_DATA)
     ID:  the node id

     URL:  the node public url

     TITLE:  the node title

     DESCRIPTION:  the node description

     BENCH:  the node bench

     IDLE_SCREENSHOT_SIZE:  the size (bytes) of the image to display
     when game is idle

     IDLE_SCREENSHOT_DATA:  the data (jpeg) of the image to display
     when game is idle

     Creates a node info object. The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     `lw6nod_info_update' which can be called later.

     *Return value:*  newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6nod_info_t * INFO)
     INFO:  the node info to free

     Frees a node info object.

     *Return value:*  none

 -- Function: int lw6nod_info_lock (lw6nod_info_t * INFO)
     INFO:  the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:*  1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6nod_info_t * INFO)
     INFO:  the node info to unlock

     Unlocks a node info object, this is the compation of the
     `lw6nod_info_lock' function.

     *Return value:*  1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6nod_info_t * INFO)
     INFO:  the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values. This is what we want when the node is idle,
     not playing.

     *Return value:*  none.

 -- Function: int lw6nod_info_update (lw6nod_info_t * INFO, char *
          LEVEL, int REQUIRED, int LIMIT, int COLORS, int NODES, int
          CURSORS, int GAME_SCREENSHOT_SIZE, void *
          GAME_SCREENSHOT_DATA)
     INFO:  the node info to update

     LEVEL:  the name of the current level (map)

     REQUIRED:  the bench required to connect

     LIMIT:  the max number of colors

     NODES:  the number of colors

     CURSORS:  the number of cursors

     GAME_SCREENSHOT_SIZE:  size of screenshot (bytes)

     GAME_SCREENSHOT_DATA:  screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes. Call this whenever the
     node has changed some parameter. Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:*  1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6nod_info_t *
          INFO)
     INFO:  the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it,
     this is to avoid protection fault error when concurrent threads
     access this info.

     *Return value:*  newly allocated object, must be freed.

 -- Function: int lw6nod_info_add_discovered_node (lw6nod_info_t *
          INFO, char * PUBLIC_URL)
     INFO:  the node info to update

     PUBLIC_URL:  the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting. We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards. This is also a good way to avoid trivial DOS attacks.

     *Return value:*  1 if OK, O if error.

 -- Function: char * lw6nod_info_pop_discovered_node (lw6nod_info_t *
          INFO)
     INFO:  the node info to query

     Gets the next discovered node, one would typically call this until
     it returns NULL to test all of the nodes. When it returns NULL,
     the list is empty, will be populated (or not) later when new
     servers connect.

     *Return value:*  the public URL of a node, or NULL if empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6nod_info_t * INFO,
          lw6sys_list_t * LIST)
     INFO:  the node info to modify

     LIST:  the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page. We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very
     important about this function is that `list' will be freed by
     function, that is, if you call this, then you can (you should)
     forget your object, it will disappear any time soon.

     *Return value:*  1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6nod_info_t *
          INFO, lw6sys_list_callback_func_t FUNC, void * FUNC_DATA)
     INFO:  the node info concerned

     FUNC:  the function to apply

     FUNC_DATA:  arbitrary pointer holding data to pass to function

     Calls `lw6sys_list_map' on every member of the list of verified
     ndoes. The reason there's a function for this is that it is very
     important that list object is locked when doing this.  This
     function does perform a lock/unlock so it is safe.

     *Return value:*  none.

 -- Function: int lw6nod_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite. This one could fail if some
     sockets are already bound, for instance. It's still run even in
     check-only (mode=0) mode.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.17 libp2p
--------------

 -- Function: lw6p2p_db_t * lw6p2p_db_open (int ARGC, char * [] ARGV,
          char * NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Creates a new database object. Normally there's only one object
     like this at a given time, it can be shared among various nodes.
     The database name is appended to user directory path, this allows
     different databases to be created, in theory.

     *Return value:*  a pointer on the newly created object.

 -- Function: void lw6p2p_db_close (lw6p2p_db_t * DB)
     DB:  the db to close

     Closes a db object, memory ressources will be freed.

     *Return value:*  none.

 -- Function: char * lw6p2p_db_repr (lw6p2p_db_t * DB)
     DB:  the db to work on

     Gives a readable representation of the db

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_db_reset (int ARGC, char * [] ARGV, char *
          NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Clears the database. Simply removes the db file, in fact. Do not
     call while database is used...

     *Return value:*  1 on success, 0 if failed.

 -- Function: char * lw6p2p_db_default_name ()
     Returns the default database name, should be p2p.db (this is a
     relative path, not an absolute path, will be appended to user dir).

     *Return value:*  the default database name, need not (must not) be
     freed.

 -- Function: lw6p2p_node_t * lw6p2p_node_new (int ARGC, char * []
          ARGV, lw6p2p_db_t * DB, char * CLIENT_BACKENDS, char *
          SERVER_BACKENDS, char * BIND_IP, int BIND_PORT, u_int64_t
          NODE_ID, char * PUBLIC_URL, char * PASSWORD, char * TITLE,
          char * DESCRIPTION, int BENCH)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     DB:  the database to use

     CLIENT_BACKENDS:  the list of client backends to use

     SERVER_BACKENDS:  the list of server backends to use

     BIND_IP:  the IP address to bind on

     BIND_PORT:  the IP port to listen on

     NODE_ID:  the server unique ID

     PUBLIC_URL:  the public URL we want to show

     PASSWORD:  the password to use

     TITLE:  the title of the node

     DESCRIPTION:  the description of the node

     BENCH:  the bench of the node (its power)

     Creates a new "pear to pear" node. This will fire the server and
     allow client access, on demand. A lot of stuff can be done in the
     background once this is called.

     *Return value:*  a pointer on the newly created objects.

 -- Function: void lw6p2p_node_free (lw6p2p_node_t * NODE)
     NODE:  the node to free

     Frees a node object, all network communications will be shut.

     *Return value:*  none.

 -- Function: char * lw6p2p_node_repr (lw6p2p_node_t * NODE)
     NODE:  the node to work on

     Gives a readable representation of the node

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_node_poll (lw6p2p_node_t * NODE)
     NODE:  the node to poll

     Polls a p2p node. This must be called on a regular basis, else
     network communication is stalled.

     *Return value:*  1 on success, 0 on error.

 -- Function: void lw6p2p_node_close (lw6p2p_node_t * NODE)
     NODE:  the node to close

     Closes a p2p node. Closing is necessary in some contexts, for
     instance scheme/smob instanciation when you want to release the
     object ressources (sockets, ports, threads...) *before* it is
     deleted by, for instance, a garbage collector.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6p2p_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `p2p' module test suite. This test can fail if one cannot
     bind on some network port, in a general manner it is dependent on
     the network environment, so it's better if there's some sort of
     human control on it.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.18 libpil
--------------

 -- Function: int lw6pil_bench (float * BENCH_RESULT, lw6sys_progress_t
          * PROGRESS)
     BENCH_RESULT:  pointer to float, will contain the bench result

     PROGRESS:  to inform the caller of the process advancement

     Runs a standard, normalized bench on a default map. Results can be
     interpreted as an estimated speed/power of your computer.

     *Return value:*  1 on success, 0 if failure

 -- Function: void lw6pil_coords_fix (lw6map_rules_t * RULES,
          lw6sys_whd_t * SHAPE, float * X, float * Y, float * Z)
     RULES:  the set of rules to use (defines polarity)

     SHAPE:  the shape of the map (logical part)

     X:  the x coord to fix

     Y:  the y coord to fix

     Z:  the z coord to fix

     Similar to `lw6map_coords_fix' but using floats, this function can
     be used to check cursor position boundaries. Any float pointer can
     be NULL.

     *Return value:*  none.

 -- Function: void lw6pil_local_cursors_reset (lw6pil_local_cursors_t *
          LOCAL_CURSORS)
     Resets a local cursors struct. Note that this need not be called
     very often, in fact the local cursors can cope with "dead" cursors
     easily. In practise, in a local game, there are only 4 of them,
     great maximum.

     *Return value:*  none.

 -- Function: lw6pil_local_cursor_t * lw6pil_local_cursors_get_cursor
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t CURSOR_ID)
     CURSOR_ID:  the id of the cursor to query

     Returns a pointer on the cursor with the given id.

     *Return value:*  a pointer (must *not* be freed) which is NULL is
     cursor does not exist.

 -- Function: int lw6pil_local_cursors_get_info (lw6pil_local_cursors_t
          * LOCAL_CURSORS, int * X, int * Y, int * MOUSE_CONTROLLED,
          u_int16_t CURSOR_ID)
     X:  a pointer to the x position, may be NULL

     Y:  a pointer to the y position, may be NULL

     MOUSE_CONTROLLED:  a pointer to the mouse_controlled flag, may be
     NULL

     CURSOR_ID:  the id of the cursor to query

     Gets the x,y position of the cursor, and tells if it's mouse
     controlled.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_xy (lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID, int X, int Y)
     CURSOR_ID:  the id of the cursor to modify

     X:  the x position

     Y:  the y position

     Sets the position of a cursor in the local cursors struct. If
     cursor does not exists, it's appended to the list.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_mouse_controlled
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t CURSOR_ID,
          int MOUSE_CONTROLLED)
     CURSOR_ID:  the id of the cursor to modify

     MOUSE_CONTROLLED:  the mouse_controlled attribute

     Sets which cursor is mouse controlled. If mouse_controlled is 1,
     the flag is set for this cursor and cleared for all others. If set
     to 0, only this cursor's flag is cleared.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_get_main_info
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t *
          CURSOR_ID, int * X, int * Y, int * MOUSE_CONTROLLED)
     CURSOR_ID:  the id of the main cursor, may be NULL

     X:  a pointer to the x position, may be NULL

     Y:  a pointer to the y position, may be NULL

     MOUSE_CONTROLLED:  a pointer to the mouse_controlled flag, may be
     NULL

     Gets the x,y position of the main cursor, and tells if it's mouse
     controlled.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_main (lw6pil_local_cursors_t
          * LOCAL_CURSORS, u_int16_t CURSOR_ID)
     CURSOR_ID:  the id of the cursor to be labelled as main cursor

     Sets the main cursor attribute, the main cursor is later used, for
     instance, to decide how to display the map (centered on it, for
     instance).

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: lw6pil_pilot_t * lw6pil_pilot_new (lw6ker_game_state_t *
          GAME_STATE, int64_t TIMESTAMP, lw6sys_progress_t * PROGRESS)
     GAME_STATE:  the game state we're going to work on

     TIMESTAMP:  the current ticks (1000 ticks per sec, used to
     calibrate)

     PROGRESS:  object used to show the advancement of the process

     Initializes a 'pilot' object, this object is responsible for
     interpreting messages, transform them into low-level 'ker' module
     function calls, and handle all the thread-spooky stuff.

     *Return value:*  a working pilot object. May be NULL on memory
     failure.

 -- Function: void lw6pil_pilot_free (lw6pil_pilot_t * PILOT)
     PILOT:  the object to free.

     Frees a 'pilot' object, note that this might involve joining some
     threads, so it can 'take some time'.

     *Return value:*  none.

 -- Function: int lw6pil_pilot_send_command (lw6pil_pilot_t * PILOT,
          char * COMMAND_TEXT, int VERIFIED)
     PILOT:  the object to send commands to.

     COMMAND_TEXT:  the text of the command, as received form network

     VERIFIED:  wether we're sure this message is valid.

     Sends a command and handles it internally.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_local_command (lw6pil_pilot_t * PILOT,
          char * COMMAND_TEXT)
     PILOT:  the object to apply the local command on

     COMMAND_TEXT:  the command text

     This function is used to fix the annoying fact that by only sending
     commands a limited number of times per sec to the game state, the
     display always reflect an outdated position for cursors. But
     players do not want to see this, they want to see the cursor in
     the right place.  So what we do is that the pilot can process
     "local" commands which have absolutely no effect on the game but
     simply update a local cursor state, only used for display. It's
     here in the pil module for it's where the command interpreting
     code is, and the fact that there's this lag is directly linked
     with the pilot way of doing things.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6pil_pilot_commit (lw6pil_pilot_t * PILOT)
     PILOT:  the object to commit.

     Commits all commands sent and actually send them to the
     corresponding threads. This commit system allows better performance
     by sending, for instance, all the commands for a given round
     together.

     *Return value:*  none.

 -- Function: int lw6pil_pilot_make_backup (lw6pil_pilot_t * PILOT)
     PILOT:  the object to perform the backup on

     Makes a new backup in the pilot, that is, copy 'reference' to
     'backup'.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_can_sync (lw6ker_game_state_t * TARGET,
          lw6pil_pilot_t * PILOT)
     TARGET:  the target game_state we would sync on

     PILOT:  the object to perform the backup on

     Tests wether sync functions are callable with a given game state.
     It verifies if the internal game_state and the target look the
     same.

     *Return value:*  1 if sync functions can be called, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_backup (lw6ker_game_state_t *
          TARGET, lw6pil_pilot_t * PILOT)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     Gets the backup from the pilot object. This is the last snapshot
     taken by `make_backup' or, by default, the game_state the pilot
     was constructed with.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_reference (lw6ker_game_state_t
          * TARGET, lw6pil_pilot_t * PILOT)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     Gets the latest reference game_state, that is, a stable snapshot
     of the game, with no inconsistency, a game position that exists
     and that we can rely on. Note that getting this can take time
     since a global mutex is required, and computations must end before
     you get the data.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_draft (lw6ker_game_state_t *
          TARGET, lw6pil_pilot_t * PILOT, int DIRTY_READ)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     DIRTY_READ:  wether to allow dirty read or not

     Gets the informations from the pilot object, not being worried
     about game consistency, this one will just return the latest
     version available.  It might even be in an inconsistent state, the
     position could reflect a position which will never exist. Still,
     the data returned will not correspond to a half-spread or
     half-moved game_state if dirty_read is set to 0. In this case the
     data has at least some basic consistency and getting this does
     require some mutex lock, however wait time should be fairly small
     (max. a round). But, in a general manner, this function is only
     used for display, and we do not care much if there's a small
     glitch, we prefer fast & smooth display.

     *Return value:*  1 if OK, 0 if not.

 -- Function: lw6ker_game_state_t * lw6pil_pilot_dirty_read
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to get informations from.

     Returns a direct access to the most up-to-date game_state, without
     locking anything whatsoever. This is clearly to implement a dirty
     read mode as the name of the function suggests.

     *Return value:*  1 if OK, 0 if not.

 -- Function: char * lw6pil_pilot_repr (lw6pil_pilot_t * PILOT)
     Returns a string describing the pilot. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: void lw6pil_pilot_calibrate (lw6pil_pilot_t * PILOT,
          int64_t TIMESTAMP, int ROUND)
     PILOT:  the object to calibrate

     TIMESTAMP:  the current ticks setting (1000 ticks per second)

     ROUND:  the round expected to be returned with this ticks value

     Calibrates the pilot, that is, initializes it so that subsequent
     calls to `lw6pil_pilot_get_round' return consistent values.

     *Return value:*  none.

 -- Function: void lw6pil_pilot_speed_up (lw6pil_pilot_t * PILOT, int
          ROUND_INC)
     PILOT:  the pilot to speed up

     ROUND_INC:  the number of rounds

     Re-calibrates the pilot so that it speeds up a bit.  This will
     basically increase next_round by round_inc.

     *Return value:*  none.

 -- Function: void lw6pil_pilot_slow_down (lw6pil_pilot_t * PILOT, int
          ROUND_DEC)
     PILOT:  the pilot to speed up

     ROUND_DEC:  the number of rounds

     Re-calibrates the pilot so that it slows down a bit.  This will
     basically decrease next_round by round_inc.

     *Return value:*  none.

 -- Function: int lw6pil_pilot_get_next_round (lw6pil_pilot_t * PILOT,
          int64_t TIMESTAMP)
     PILOT:  the object to query

     TIMESTAMP:  the current ticks setting (1000 ticks per second)

     Returns the round one should use to generate new events/commands
     at a given time (given in ticks).

     *Return value:*  none.

 -- Function: int lw6pil_pilot_get_last_commit_round (lw6pil_pilot_t *
          PILOT)
     PILOT:  the object to query

     Returns the round of the last commit (reference game_state) for
     this object.

     *Return value:*  the commit round (reference object)

 -- Function: int lw6pil_pilot_get_reference_target_round
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the round which is targetted in the reference game_state,
     this is 'how far computation will go in the reference game_state
     if no new commands are issued'. Note that there can always be some
     commands which are not yet processed, so you should not rely on
     this too heavily, however it gives a good idea of how things are
     going.

     *Return value:*  the target round (reference object)

 -- Function: int lw6pil_pilot_get_reference_current_round
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the current round in the reference game_state. There's no
     lock on this call so don't rely on this too heavily, it just gives
     you an idea of wether the pilot is very late on its objectives or
     just on time.

     *Return value:*  the current round (reference object)

 -- Function: int lw6pil_pilot_get_max_round (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the max current round in the reference or draft game
     states. No lock on this call so don't rely on this too heavily, it
     just gives you an idea of computation state.

     *Return value:*  the current round (reference object)

 -- Function: int lw6pil_pilot_is_over (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Tells wether the game is over or not.

     *Return value:*  1 if over, 0 if not

 -- Function: int lw6pil_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `pil' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

4.15.19 libsnd
--------------

 -- Function: int lw6snd_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `snd' module test suite. If run in check mode (0), won't
     really perform the test, since it could fail because of hardware
     problems, context, permissions...

     *Return value:*  1 if test is successfull, 0 on error.

4.15.20 libsrv
--------------

 -- Function: lw6srv_oob_t * lw6srv_oob_new (char * REMOTE_IP, int
          REMOTE_PORT, int SOCK)
     REMOTE_IP:  remote IP address

     REMOTE_PORT:  remote port

     SOCK:  the socket handler (either TCP or UDP)

     Create a new OOB structure, copying required objects.  We need to
     make copies for this is for usage in a separate thread. The thread
     member is not set here since the right way to do things is first to
     set up data then to fire the thread.

     *Return value:*  new object

 -- Function: void lw6srv_oob_free (lw6srv_oob_t * OOB)
     OOB:  the object to free

     Frees an OOB structure.

     *Return value:*  none

 -- Function: lw6srv_tcp_accepter_t * lw6srv_tcp_accepter_new (char *
          CLIENT_IP, int CLIENT_PORT, int SOCK)
     CLIENT_IP:  the client ip, will be freed when accepter is freed,
     do not copy it

     CLIENT_PORT:  the client port

     SOCK:  the socket used

     Creates a tcp_accepter object.

     *Return value:*  none

 -- Function: void lw6srv_tcp_accepter_free (lw6srv_tcp_accepter_t *
          TCP_ACCEPTER)
     TCP_ACCEPTER:  the object to free

     Frees a tcp_accepter object.

     *Return value:*  none

 -- Function: int lw6srv_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `srv' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: lw6srv_udp_buffer_t * lw6srv_udp_buffer_new (char *
          CLIENT_IP, int CLIENT_PORT, char * LINE)
     CLIENT_IP:  the client ip, will be freed when object is freed, do
     not copy it

     CLIENT_PORT:  the client port

     LINE:  the line received, will be freed when object is freed, do
     not copy it

     Creates an udp_buffer object.

     *Return value:*  none

 -- Function: void lw6srv_udp_buffer_free (lw6srv_udp_buffer_t *
          UDP_BUFFER)
     UDP_BUFFER:  the object to free

     Frees a udp_buffer object.

     *Return value:*  none

4.15.21 libsys
--------------

 -- Function: int lw6sys_arg_match (char * KEYWORD, char * ARGV_STRING)
     KEYWORD:  the option to match, without the prefix "-" or "-"

     ARGV_STRING:  the argv value, for instance argv[1]

     This is an utility function which allow the program to handle
     options in a uniform manner. Key comparison is insensitive, that
     is, -option and -OPTION are equivalent. Besides, -option and
     -OPTION are equivalent too. Liquid War 6 documentation mentions
     options in lowercase with a double dash (-option) by default, but
     it's a fact, the program supports variants. This is just for
     convenience, the philosophy behind this behavior is "be as
     permissive as possible when interpreting input, and as strict as
     possible when generating output". In fact, it's even said that
     Liquid War 6 will accept the argument without any prefix dash as
     being valid... This is to say running "liquidwar6 -option" is the
     same as running "liquidwar6 option". But, this is a secret 8-)

     *Return value:*  non zero if it matches, 0 if it doesn't.

 -- Function: int lw6sys_arg_exists (int ARGC, char * [] ARGV, char *
          KEYWORD)
     ARGC:  the number of arguments, as passed to `main'

     ARGV:  an array of arguments, as passed to `main'

     KEYWORD:  the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key[=...]" entry.

     *Return value:*  1 if key is present, 0 if not.

 -- Function: char * lw6sys_arg_get_value (int ARGC, char * [] ARGV,
          char * KEYWORD)
     ARGC:  the number of arguments, as passed to `main'

     ARGV:  an array of arguments, as passed to `main'

     KEYWORD:  the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key=value" pair, and returns the value.

     *Return value:*  a pointer to the value. May be NULL. Must be
     freed.

 -- Function: char * lw6sys_arg_get_value_with_env (int ARGC, char * []
          ARGV, char * KEYWORD)
     ARGC:  the number of arguments, as passed to `main'

     ARGV:  an array of arguments, as passed to `main'

     KEYWORD:  the keyword to match

     Parses all command-line arguments, searching for one precise
     "-key=value" pair, and returns the value.  If a corresponding
     environment variable is available, but no command-line parameter
     was passed, the environment variable is intepreted. Such
     environment variables are uppercased, prefixed by "LW6_" and "_"
     replaces "-". The environment variable will be overriden if the
     command-line parameter is present.

     *Return value:*  a pointer to the value. May be NULL. Must be
     freed.

 -- Function: int lw6sys_arg_test_mode (int ARGC, char * [] ARGV)
     ARGC:  argc as passed to main

     ARGV:  argv as passed to main

     Chooses between the two test modes "check" or "test". Check (value
     0) is a lighter test which should never fail even if some special
     hardware or environment is missing. Test (value 1) is a more
     complete test which does things which *can* require some special
     conditions.  Function will log and be verbose is syntax is not
     correct.

     *Return value:*  1 if complete test must be run, 0 is only check

 -- Function: lw6sys_assoc_t * lw6sys_assoc_new (lw6sys_free_func_t
          FREE_FUNC)
     FREE_FUNC:  optional callback used to free memory when stored date
     is a pointer. Can be NULL when one stores non dynamically
     allocated data, such as an integer or a static array.

     Creates an empty assoc. There's a difference between NULL and an
     empty assoc. The empty assoc would (in Scheme) be '() whereas NULL
     corresponds to undefined "is not a assoc and will generate errors
     if you ever call assoc functions on it". Such created assoc are
     not performant hash tables but slowish "strcmp me for each key"
     associative arrays, the key being a "char *" string and the value
     a "void *" pointer.

     *Return value:*  a pointer to the newly allocated associative
     array. Must be freed with `lw6sys_assoc_free'.

 -- Function: void lw6sys_assoc_free (lw6sys_assoc_t * ASSOC)
     ASSOC:  the assoc to be freed.

     The function will cascade  delete all elements, using (if not
     NULL...)  the callback passed when first creating the assoc.

     *Return value:*  void

 -- Function: int lw6sys_assoc_has_key (lw6sys_assoc_t * ASSOC, char *
          KEY)
     ASSOC:  the assoc to test

     KEY:  the key to search

     Not a very fast function, since on a "big" assoc, strcmp will be
     called internally until the key is found.

     *Return value:*  non-zero if there's an entry with the
     corresponding key.

 -- Function: void * lw6sys_assoc_get (lw6sys_assoc_t * ASSOC, char *
          KEY)
     ASSOC:  the assoc to query

     KEY:  the key of which we want the value

     *Return value:*  a void pointer to the data contained in the
     assoc. Note that the pointer on the actual data is returned, that
     is, if it's static data, you must not try to free it... As long as
     memory management is concerned, destroying the assoc will actually
     free the data if needed.

 -- Function: void lw6sys_assoc_set (lw6sys_assoc_t ** ASSOC, char *
          KEY, void * VALUE)
     ASSOC:  the assoc to modify

     KEY:  the key we want to updated

     VALUE:  the new value

     Sets a value in an associative array. The key pointer need not be
     persistent, it can be freed after affectation. In fact a new
     string will be created internally. This is not true for the value,
     it's hard to find way to copy "any object".  So if you want an
     associative array of strings, key can disappear after calling this
     function, but not value. The function passed as free_func when
     creating the assoc will be used to free stuff whenever needed
     (unset or free).

     *Return value:*  void

 -- Function: void lw6sys_assoc_unset (lw6sys_assoc_t * ASSOC, char *
          KEY)
     ASSOC:  the assoc concerned

     KEY:  the key to unset

     Clears an entry in an associative array. The callback passed when
     creating the assoc will be called if needed, to free the data
     automatically.

     *Return value:*  void

 -- Function: lw6sys_list_t * lw6sys_assoc_keys (lw6sys_assoc_t * ASSOC)
     ASSOC:  the assoc to work on

     Returns a list containing all the keys of the assoc. The list must
     be free with lw6sys_list_free by the caller.  This list copies all
     the keys of the assoc, so it is safe to use it once the assoc is
     deleted. However the keys will of course be of little interest in
     this case.  But the program won't segfault.

     *Return value:*  the list of keys.

 -- Function: void lw6sys_assoc_map (lw6sys_assoc_t * ASSOC,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     ASSOC:  the assoc to work on

     FUNC:  a callback to call on each entry

     FUNC_DATA:  a pointer on some data which will be passed to the
     callback

     Executes a function on all assoc items.  The func_data parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global...

     *Return value:*  void

 -- Function: void lw6sys_assoc_sort_and_map (lw6sys_assoc_t * ASSOC,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     ASSOC:  the assoc to work on

     FUNC:  a callback to call on each entry, may be NULL

     FUNC_DATA:  a pointer on some data which will be passed to the
     callback

     Executes a function on all assoc items, like
     `lw6sys_assoc_sort_and_map' but befor doing so, sorts all entries
     in alphabetical order.

     *Return value:*  void

 -- Function: lw6sys_assoc_t * lw6sys_assoc_dup (lw6sys_assoc_t *
          ASSOC, lw6sys_dup_func_t DUP_FUNC)
     ASSOC:  the assoc to duplicate, can be NULL

     DUP_FUNC:  the function which will be called to duplicate data

     Duplicates an assoc. All keys will be copied so that if the first
     assoc is deleted, the duplicated one is fine. Additionnaly,
     dup_func will be called with all data fields. If dup_func is NULL,
     then data values will simply be copied. This is likely to be
     usefull when data is not dynamically allocated.

     *Returned value:*  a newly allocated assoc.

 -- Function: int lw6sys_default_memory_bazooka ()
     Will set up a default memory bazooka, a slow yet convenient tool
     to track down and hopefully kill memory leaks.  Named bazooka
     after a night wasted to track down an unfoundable leak...
     BAZOOOOOOKA!!!

     *Return value:*  1 if success, 0 if failed.

 -- Function: void lw6sys_clear_memory_bazooka ()
     Clears the memory bazooka.

     *Return value:*  none.

 -- Function: int lw6sys_set_memory_bazooka_size (int SIZE)
     SIZE:  number of items (calls to malloc) to keep

     Resizes, the memory bazooka. What's this? It's an inelegant yet
     efficient tool to track down memory leak. Memory bazooka will keep
     track of every call to malloc, keeping a trace of what has been
     malloced, where it has been called (from which file, which line),
     how much memory was allocated, it will even show you what's at the
     address in a 0-terminated string-friendly fashion. Of course this
     slows down the program, so in production, you might set this to 0,
     but for debugging, a million bazooka is worth the megabytes and
     CPU cycles it wastes.

     *Return value:*  1 if success, 0 if failure.

 -- Function: int lw6sys_get_memory_bazooka_size ()
     The companion of `lw6sys_set_memory_bazooka_size'. This function
     will return how many calls to malloc can be traced. A return value
     of 0 indicates that feature is disabled.

     *Return value:*  size of the bazooka array.

 -- Function: int lw6sys_set_memory_bazooka_eraser (int STATE)
     STATE:  the state of the eraser

     Sets the memory bazooka eraser state. Note that to really work, it
     requires the memory bazooka to be "big enough".

     *Return value:*  1 if activated, 0 if not. Note that the main
     reason for it not to be activated is if the memory bazooka has
     zero size.

 -- Function: int lw6sys_get_memory_bazooka_malloc_count ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     how many times `malloc' has been called.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_free_count ()
     Provided you have always called the `LW6SYS_FREE' macro to free
     memory, this function will tell you how many times `free' has been
     called.

     *Return value:*  the number of calls to `lw6sys_free' since
     program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_current_count ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     the current number of pointer returned by `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC', currently alive on the heap.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_max_count ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     the maximum of pointers returned by `malloc' that were present at
     the same time on the heap.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_megabytes ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     how many bytes `malloc' has reserved.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_free_megabytes ()
     Provided you have always called the `LW6SYS_FREE' macro to free
     memory, this function will tell you how many bytes `free' has
     freed.

     *Return value:*  the number of calls to `lw6sys_free' since
     program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_current_bytes ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     the current number of bytes returned by `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC', currently alive on the heap.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_get_memory_bazooka_malloc_max_bytes ()
     Provided you have always called the `LW6SYS_MALLOC' an
     `LW6SYS_CALLOC' to allocate memory, this function will tell you
     the maximum bytes returned by `malloc' that were present at the
     same time on the heap.

     *Return value:*  the number of calls to `lw6sys_malloc' or
     `lw6sys_calloc' since program was started.

 -- Function: int lw6sys_is_memory_bazooka_trustable ()
     Returns true if memory bazooka data are perfectly trustable, that
     is, it has never been resetted or resized.

     *Return value:*  1 if trustable, 0 if not.

 -- Function: int lw6sys_memory_bazooka_report ()
     Reports memory bazooka diagnostics on the console. Carefull, this
     one is not reentrant, call at the end of your program when all
     threads are joined.

     *Return value:*  1 if no allocated stuff left, 0 if there are
     still malloc'ed stuff

 -- Function: char * lw6sys_build_get_package_tarname ()
     Returns the name of the package. This is the `PACKAGE_TARNAME'
     constant defined by the GNU Autoconf ./configure script. While
     it's always possible to use the defined constant directly, using
     this function will return the value defined when compiling the
     binary, not the one you're using when compiling another program
     relying on Liquid War as a library.

     *Return value:*  a non-NULL string "liquidwar6", must not be freed.

 -- Function: char * lw6sys_build_get_package_name ()
     Returns the name of the package, in a user friendly form, which can
     include spaces, for instance. This is the `PACKAGE_NAME' constant
     defined by the GNU Autoconf ./configure script. While it's always
     possible to use the defined constant directly, using this function
     will return the value defined when compiling the binary, not the
     one you're using when compiling another program relying on Liquid
     War as a library.

     *Return value:*  a non-NULL string "Liquid War 6", must not be
     freed.

 -- Function: char * lw6sys_build_get_package_string ()
     Returns the description of the package. This is the
     `PACKAGE_STRING' constant defined by the GNU Autoconf ./configure
     script. It's the concatenation of `PACKAGE_NAME' and `VERSION'.
     While it's always possible to use the defined constant directly,
     using this function will return the value defined when compiling
     the binary, not the one you're using when compiling another
     program relying on Liquid War as a library.

     *Return value:*  a non-NULL string "Liquid War 6 <version>", must
     not be freed.

 -- Function: char * lw6sys_build_get_version ()
     Returns the version of the program. This is the `VERSION' constant
     defined by the GNU Autoconf ./configure script. Same as
     `PACKAGE_VERSION'.  Note that while using a function to get
     `PACKAGE_TARNAME' might seem useless, having both ways to get the
     version, that is, a function and a constant, is very usefull.
     Think, for instance, that a dynamically loaded shared library
     might need to check its own version against the version of the
     core program.

     *Return value:*  a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_codename ()
     Returns the the program codename. This is the little name of the
     version. It's been decided that all LW6 releases would take the
     name of a famous general, warrior, whatever. For instance, it could
     be "Napoleon".

     *Return value:*  a non-NULL string, traditionnally the name of a
     famous general, someone which has been involved in war. Must not
     be freed (I mean, the string, not the general).

 -- Function: char * lw6sys_build_get_stamp ()
     Returns the program stamp. This is like a serial number. It's is
     not the same as the version. The version is meant to be set to
     something readable. This is just a cryptic thing, incremented at
     each ./configure or each developper's "I feel like it needs to be
     incremented". The idea is just to keep (one more...) track of
     which source code is build.  Ideally, this would be plugged to the
     source revision control system but this has some drawbacks,
     including that it would require it to modify files before
     commiting them, which is not safe, and almost impossible if you
     sign archives. One more point: this is a string. It's true the
     return value is actually a string containing the representation of
     an integer, but because all other build parameters are strings, and
     because we don't know what the future reserves, it's a string.

     *Return value:*  a non-NULL string like "42", which must not be
     freed.

 -- Function: char * lw6sys_build_get_md5sum ()
     Returns an md5 checkum which is caculated from C (.c and .h) source
     files. This is complementary with the build stamp. By default the
     stamp will be enough to check what has been compiled, but one can
     always imagine a case where Bob compiles something a little
     different than Alice, with the same stamp, incremented by 1 from a
     common source tree. They apply their own patches, for instance.
     This md5sum double-checks that two binaries have been built from
     the same sources. Note that this is not the md5 checksum of the
     generated binary. Nor does it include any information about scheme
     scripts and data.

     *Return value:*  a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_copyright ()
     Returns a (very) short copyright information about the program.

     *Return value:*  a non-NULL string, single line whithout '\n' at
     the end.  Must not be freed.

 -- Function: char * lw6sys_build_get_license ()
     Returns the license for the program (GNU GPL v3 or later).

     *Return value:*  a non-NULL string, single line whithout '\n' at
     the end.  Must not be freed.

 -- Function: char * lw6sys_build_get_url ()
     Returns the URL of the game, its homepage.

     *Return value:*  a non-NULL string, single line whithout '\n' at
     the end.  Must not be freed.

 -- Function: char * lw6sys_build_get_configure_args ()
     Returns the arguments passed to the GNU Autoconf ./configure
     script when buildling the game. Very usefull to know how the
     binary was generated, that is, what kind of optimizations are
     peculiar settings it uses.

     *Return value:*  a non-NULL string, which, passed to ./configure
     again, would hopefully generate the same binary. Must not be freed.

 -- Function: char * lw6sys_build_get_gcc_version ()
     Returns __VERSION__ GCC preprocessor value, that is, the human
     readable version of the compiler.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_cflags ()
     Returns the arguments which would allow another program to use
     liquidwar6 as a library. Typically, pass this to gcc when
     compiling your sources. Basically contains "-I" switches which
     tell where the headers are.

     *Return value:*  a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_ldflags ()
     Returns the arguments which would allow another program to link
     against liquidwar6. Pass this to gcc or libtool when compiling
     your program. Basically contains a "-L" option which says where
     the library is. Note that this will only allow you to link against
     the main libliquidwar6 library, but not the dynamically loaded
     modules.

     *Return value:*  a non-NULL string, which must not be freed.

 -- Function: char * lw6sys_build_get_hostname ()
     Returns the value return by the standard shell `hostname' command
     on the machine where the game has been built. Usefull to track
     binaries and know where do they come from.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_date ()
     Returns the compilation date. While this information can easily be
     obtained with the C `__DATE__' macro, having this function is
     convenient for it returns a value which is the same for the whole
     program, and does not possibly change in every file.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_time ()
     Returns the compilation date. While this information can easily be
     obtained with the C `__TIME__' macro, having this function is
     convenient for it returns a value which is the same for the whole
     program, and does not possibly change in every file.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_host_cpu ()
     Returns the CPU this program is designed for. Convenient on i386
     compatible CPUs to know which flavor (i386, i586...) the binary is
     made for.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_endianness ()
     Returns the endianness of the computer.

     *Return value:*  'little' (x86-like) or 'big' (ppc-like), as a
     string.  Must not be freed.

 -- Function: int lw6sys_build_get_pointer_size ()
     Returns the system pointer size, in bytes.

     *Return value:*  4 for 32-bit, 8 for 64-bit.

 -- Function: int lw6sys_build_is_x86 ()
     Tells wether CPU belongs to x86 family or not.

     *Return value:*  1 if x86, 0 if not

 -- Function: char * lw6sys_build_get_host_os ()
     Returns the OS this program is designed for. Usefull for bug
     reports.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: int lw6sys_build_is_ms_windows ()
     Tells wether the program was compiled for Microsoft Windows, or
     not.

     *Return value:*  1 if compiled on windows, 0 if not

 -- Function: int lw6sys_build_is_mac_os_x ()
     Tells wether the program was compiled for Mac OS X, or not.

     *Return value:*  1 if compiled on OS X, 0 if not

 -- Function: int lw6sys_build_is_gp2x ()
     Tells wether the program was compiled for GP2X, or not.

     *Return value:*  1 if compiled on OS X, 0 if not

 -- Function: char * lw6sys_build_get_top_srcdir ()
     Returns the top source directory, when the game was built. This can
     seem useless and non relevant on the end-user's machine, but...
     it's a must-have for developpers and packagers. Without this,
     binaries would never find their associated data, especially when
     building outside the source tree. Or, testing the game would be
     impossible without installing it, given the fact that most of the
     code is in scripts that are stored in /usr/local by default, this
     would be painfull. So this function is here to help finding data
     within the source tree when the game is not installed yet. Note
     that the function is rather clever, since it will automatically
     try to remove useless '../' sequences at the beginning of a
     possibly relative path.

     *Return value:*  a non-NULL string, must not be freed.

 -- Function: char * lw6sys_build_get_prefix ()
     Returns the `prefix' value as given to the GNU Autoconf
     ./configure script.  Used to deduce the path to other directories
     and files.

     *Return value:*  a non-NULL string, "/usr/local" by default.  Must
     not be freed.

 -- Function: char * lw6sys_build_get_datadir ()
     Returns the `datadir' value defined by the GNU Autoconf
     ./configure script.  This is not the value which can be overriden
     by the Liquid War 6 specific.  "-data-dir" option. `datadir' is
     usually something like "/usr/local/share" while the actual Liquid
     War 6 defined data dir is a more profound path which includes the
     name of the package, its version, and so on.

     *Return value:*  a non-NULL string, "/usr/local/share" by default.
     Must not be freed.

 -- Function: char * lw6sys_build_get_libdir ()
     Returns the `libdir' value defined by the GNU Autoconf ./configure
     script.  This is not the value which can be overriden by the
     Liquid War 6 specific.  "-mod-dir" option. `libdir' is usually
     something like "/usr/local/lib" while the actual Liquid War 6
     defined module dir is a more profound path which includes the name
     of the package, its version, and so on.

     *Return value:*  a non-NULL string, "/usr/local/lib" by default.
     Must not be freed.

 -- Function: char * lw6sys_build_get_includedir ()
     Returns the `includedir' value defined by the GNU Autoconf
     ./configure script.  As for other options, it's interesting to
     have this value, this enables the program to inform people who
     want to hack the game of the place headers are supposed to be
     installed.

     *Return value:*  a non-NULL string, "/usr/local/include" by
     default.  Must not be freed.

 -- Function: char * lw6sys_build_get_localedir ()
     Returns the `localedir' value defined by the GNU Autoconf
     ./configure script.  Used as an argument for gettext / libintl
     functions.

     *Return value:*  a non-NULL string, "/usr/local/share/locale" by
     default.  Must not be freed.

 -- Function: char * lw6sys_build_get_docdir ()
     Returns the `docdir' value defined by the GNU Autoconf ./configure
     script.  Used to write consistent XML file headers.

     *Return value:*  a non-NULL string,
     "/usr/local/share/doc/liquidwar6" by default.  Must not be freed.

 -- Function: char * lw6sys_build_get_enable_console ()
     Tells wether console is enabled or not.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gtk ()
     Tells wether gtk is enabled or not.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_gl ()
     Tells wether the graphical mod-gl backend was compiled.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_csound ()
     Tells wether the audio mod-csound backend was compiled.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_ogg ()
     Tells wether the audio mod-ogg backend was compiled.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_mod_http ()
     Tells wether the network mod-http backend was compiled.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_optimize ()
     Tells wether the game was compiled in optimize mode.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_allinone ()
     Tells wether the game was compiled in allinone mode.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_fullstatic ()
     Tells wether the game was compiled in fullstatic mode.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_paranoid ()
     Tells wether the game was compiled with paranoid memory management.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gprof ()
     Tells wether the game was compiled with suitable informations for
     gprof.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_instrument ()
     Tells wether the game was compiled with the
     '-finstrument-fonctions' GCC flag.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_profiler ()
     Tells wether the game was compiled for later use with Google
     Profiler support.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_gcov ()
     Tells wether the game was compiled with suitable informations for
     gcov.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: char * lw6sys_build_get_enable_valgrind ()
     Tells wether the game was compiled for later use with valgrind.

     *Return value:*  "yes" or "no", must no be freed.

 -- Function: int lw6sys_build_get_bin_id ()
     Returns the internal bin-id value, which does not mean anything
     but changes at each build.

     *Return value:*  an integer

 -- Function: void lw6sys_build_log_all ()
     Dumps in the log file the whole program pedigree, host, modules,
     that is, what are the values of all the build options.  Usefull
     for bug reports.

     *Return value:*  none.

 -- Function: u_int32_t lw6sys_checksum (unsigned char * DATA, int LEN)
     DATA:  the data to process

     LEN:  the length, in bytes, of the data to process

     Creates a checksum from a byte array. This could be mapped on any
     standard CRC-32 and/or MD5 algorithm, but licence issues for those
     are such a headache that for the sake of simplicity, it's wrapped
     here. In LW6 context, we do not really really fear any attack for
     these checksums are used internally to track bugs and check, for
     instance, that two game states are actually the same on two
     distant computers in a network game.  Data encryption and security
     of network links is another debate.  Additionnally, this function
     returns an integer, easier to handle in standard C than any
     malloc'ed stuff.

     *Return value:*  the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_str (char * VALUE)
     VALUE:  the string to process

     Creates a checksum from a string. This is a convenience function
     to save the programmer the hassle of calling strlen before any
     checksum calculation.

     *Return value:*  the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_int32 (u_int32_t VALUE)
     VALUE:  the integer to process

     Creates a checksum from an integer. This is a convenience function
     to save the programmer the hassle of passing a pointer to the
     integer with the size of it each time there's a checksum to do.
     Additionnally, with this one you can pass an int8 or an int16, and
     function will work just the same indenpendantly of endianness.

     *Return value:*  the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_int64 (u_int64_t VALUE)
     VALUE:  the integer to process

     Creates a checksum from an integer. This is a convenience function
     to save the programmer the hassle of passing a pointer to the
     integer with the size of it each time there's a checksum to do.
     This function handles 64-bit long long integers..

     *Return value:*  the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_whd (lw6sys_whd_t * WHD)
     WHD:  a pointer to the wh struct to be processed

     Creates a checksum from the given structure. Convenience function
     to save the hassle of passing a pointer to and the size of the
     `lw6sys_wh_t' struct each time, knowing that there are very often
     checksums calculated on it. Also avoids endianess issues.

     *Return value:*  the checksum, as an integer.

 -- Function: u_int32_t lw6sys_checksum_xyz (lw6sys_xyz_t * XYZ)
     XYZ:  a pointer to the xy struct to be processed

     Creates a checksum from the given structure. Convenience function
     to save the hassle of passing a pointer to and the size of the
     `lw6sys_xy_t' struct each time, knowing that there are very often
     checksums calculated on it. Also avoids endianess issues.

     *Return value:*  the checksum, as an integer.

 -- Function: void lw6sys_checksum_update (u_int32_t * CHECKSUM,
          unsigned char * DATA, int LEN)
     CHECKSUM:  a pointer to the previous checksum

     DATA:  the data to process

     LEN:  the length, in bytes, of the data to process

     Creates a checksum from the given data. The difference with
     `lw6sys_checksum' is that this one updates an existing checksum,
     thus enabling the programmer to call it sequentially and get a
     global checksum on different sources.

     *Return value:*  none.

 -- Function: void lw6sys_checksum_update_str (u_int32_t * CHECKSUM,
          char * VALUE)
     CHECKSUM:  a pointer to the previous checksum

     VALUE:  the string to process

     Creates a checksum from the given string. The difference with
     `lw6sys_checksum_str' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:*  none.

 -- Function: void lw6sys_checksum_update_int32 (u_int32_t * CHECKSUM,
          int32_t VALUE)
     CHECKSUM:  a pointer to the previous checksum

     VALUE:  the integer to process

     Creates a checksum from the given integer. The difference with
     `lw6sys_checksum_int32' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:*  none.

 -- Function: void lw6sys_checksum_update_int64 (u_int32_t * CHECKSUM,
          int64_t VALUE)
     CHECKSUM:  a pointer to the previous checksum

     VALUE:  the integer to process

     Creates a checksum from the given integer. The difference with
     `lw6sys_checksum_int64' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:*  none.

 -- Function: void lw6sys_checksum_update_whd (u_int32_t * CHECKSUM,
          lw6sys_whd_t * WHD)
     CHECKSUM:  a pointer to the previous checksum

     WHD:  a pointer to the wh struct to be processed

     Creates a checksum from the given structure. The difference with
     `lw6sys_checksum_whd' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:*  none.

 -- Function: void lw6sys_checksum_update_xyz (u_int32_t * CHECKSUM,
          lw6sys_xyz_t * XYZ)
     CHECKSUM:  a pointer to the previous checksum

     XYZ:  a pointer to the xy struct to be processed

     Creates a checksum from the given structure. The difference with
     `lw6sys_checksum_xyz' is that this one updates an existing
     checksum, thus enabling the programmer to call it sequentially and
     get a global checksum on different sources.

     *Return value:*  none.

 -- Function: u_int8_t lw6sys_color_float2char (float F)
     F:  the value to convert, from 0.0f to 1.0f

     Converts a floating point value between 0.0f and 1.0f to its 8-bit
     equivalent between 0 and 255. Usefull in color conversion.

     *Return value:*  an integer between 0 and 255.

 -- Function: float lw6sys_color_char2float (u_int8_t I)
     I:  the value to convert, from 0 to 255

     Converts an 8-bit value between 0 and 255 to its floating-point
     equivalent between 0.0f and 1.0f. Usefull in color conversion.

     *Return value:*  a float between 0.0f and 1.0f.

 -- Function: lw6sys_color_8_t lw6sys_color_f_to_8 (lw6sys_color_f_t *
          COLOR_F)
     COLOR_F:  the color to convert

     Converts a color from floating point format to the integer "0 to
     255" common format.  All fields (RGBA) are converted.

     *Return value:*  the color in 8-bit format.

 -- Function: void lw6sys_color_8_to_f (lw6sys_color_f_t * COLOR_F,
          lw6sys_color_8_t COLOR_8)
     COLOR_F:  the converted color (pointer must point to writable
     memory)

     COLOR_8:  the color to convert

     Converts a color from the integer "0 to 255" common format to
     floating point format.  All fields (RGBA) are converted.

     *Return value:*  none.

 -- Function: u_int32_t lw6sys_color_f_to_i (lw6sys_color_f_t * COLOR_F)
     COLOR_F:  the color to convert

     Converts a color from floating point format to a single integer,
     where all fields (RGBA) are serialized. This serialization is
     endianess independant. Could be used directly by low-level
     libraries such as SDL.

     *Return value:*  the color serialized in an integer.

 -- Function: u_int32_t lw6sys_color_8_to_i (lw6sys_color_8_t COLOR_8)
     COLOR_8:  the color to convert

     Converts a color from common "0 to 255" structured format to a
     single integer, where all fields (RGBA) are serialized. This
     serialization is endianess independant. Could be used directly by
     low-level libraries such as SDL.

     *Return value:*  the color serialized in an integer.

 -- Function: void lw6sys_color_i_to_f (lw6sys_color_f_t * COLOR_F,
          u_int32_t COLOR_I)
     COLOR_F:  the converted color (point must point to writable memory)

     COLOR_I:  the color to convert

     Converts a color from a serialized integer format to a floating
     point structure.

     *Return value:*  none.

 -- Function: lw6sys_color_8_t lw6sys_color_i_to_8 (u_int32_t COLOR_I)
     COLOR_I:  the color to convert

     Converts a color from a serialized integer format to a "0 to 255"
     based structure.

     *Return value:*  the converted color (structure).

 -- Function: lw6sys_color_8_t lw6sys_color_a_to_8 (char * ASCII)
     ASCII:  the color to convert

     Converts a color from a human readable string to a "0 to 255"
     based structure. The string must be of the form "#RRGGBBAA" or
     "#RGB", in a general manner any HTML-valid value should work.

     *Return value:*  the converted color (structure).

 -- Function: void lw6sys_color_a_to_f (lw6sys_color_f_t * COLOR_F,
          char * ASCII)
     COLOR_F:  the converted color (pointer must point to writable
     memory)

     ASCII:  the color to convert

     Converts a color from a human readable string to a float based
     structure. The string must be of the form "#RRGGBBAA" or "#RGB",
     in a general manner any HTML-valid value should work.

     *Return value:*  none.

 -- Function: char * lw6sys_color_8_to_a (lw6sys_color_8_t COLOR_8)
     COLOR_8:  the color to convert

     Converts a color from a "0 - 255" integer based structure to its
     readable form "#RRGGBBAA". If alpha is 255 (0xFF), that is, if
     it's opaque, then the "AA" part is ommitted.

     *Return value:*  a newly allocated string.

 -- Function: void lw6sys_color_rgb_to_hsv (lw6sys_color_hsv_t *
          COLOR_HSV, lw6sys_color_8_t COLOR_8)
     COLOR_HSV:  the target color, in HSV format

     COLOR_8:  the source color, in RGB 256 format

     Converts from HSV to RGB. Usefull for color manipulation, since
     most colors are stored in RGB but HSV is convenient for
     transformation. Alpha layer is kept as is.

     *Return value:*  none.

 -- Function: lw6sys_color_8_t lw6sys_color_hsv_to_rgb
          (lw6sys_color_hsv_t * COLOR_HSV)
     COLOR_HSV:  the source color, in HSV format

     Converts from RGB to HSV. Usefull to make colors transformed in HSV
     format usable again by all display routines, which consume RGB.
     Alpha layer is kept as is.

     *Return value:*  the RGB color.

 -- Function: lw6sys_color_8_t lw6sys_color_average (int SIZE,
          lw6sys_color_8_t * COLORS)
     SIZE:  number of the color array (number of items)

     COLORS:  the colors to compute

     Tries to find out the "average" color from an array of colors.
     The algorithm is far from perfect, but should output a color which
     reflects the colors passed in.

     *Return value:*  the (inexact) average color.

 -- Function: lw6sys_color_8_t lw6sys_color_ponderate (lw6sys_color_8_t
          COLOR1, lw6sys_color_8_t COLOR2, float COEFF)
     COLOR1:  first color

     COLOR2:  second color

     COEFF:  the ponderation coefficient

     Tries to find a color between the two colors passed as an argument.
     The coefficient can be used, to set the relative weight of each
     color.  Using 0 will return color1, 1 will return color2 and 0.5
     will make an average between the two colors. Any value between 0
     and 1 can be used.

     *Return value:*  the (inexact) ponderated color.

 -- Function: float lw6sys_color_distance (lw6sys_color_8_t COLOR1,
          lw6sys_color_8_t COLOR2)
     COLOR1:  first color

     COLOR2:  second color

     Calculates the distance between two colors. The unit is arbitrary,
     a big value means "colors are different", 0 means they are the
     same. A distance of 1 corresponds to colors which have barely
     anything in common, but the result can still be greater than 1.
     Alpha layer is not taken in account.

     *Return value:*  the distance.

 -- Function: int lw6sys_color_is_same (lw6sys_color_8_t COLOR1,
          lw6sys_color_8_t COLOR2)
     COLOR1:  the first color to compare

     COLOR2:  the second color to compare

     Compares two colors.

     *Return value:*  1 if they are the same, 0 if not.

 -- Function: void lw6sys_color_8_solid (lw6sys_color_8_t * COLOR)
     color: the color to modify

     Make a color "solid" that is make it not transparent at all.

     *Return value:*  none.

 -- Function: void lw6sys_color_f_solid (lw6sys_color_f_t * COLOR)
     color: the color to modify

     Make a color "solid" that is make it not transparent at all.

     *Return value:*  none.

 -- Function: int lw6sys_atoi (char * STR)
     STR:  string to convert

     Just a plain wrapper on `atoi', it's here for API consistency.

     *Return value:*  an integer.

 -- Function: int lw6sys_atob (char * STR)
     STR:  string to convert

     Transform a string into a boolean value. Accepts "0"/"1" in input,
     but also y/n, yes/no, true/false, on/off.

     *Return value:*  an integer, 0 or 1.

 -- Function: float lw6sys_atof (char * STR)
     STR:  string to convert

     A wrapper on `atof', makes sure the locale used is C (default) and
     won't change the decimal separator whatsoever. Usefull for
     serialization for instance.

     *Return value:*  a float.

 -- Function: char * lw6sys_itoa (int VALUE)
     VALUE:  the integer to convert

     Converts an integer to a string, the advantage of this function is
     it allocates memory, and does the dirty job.

     *Return value:*  a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: char * lw6sys_btoa (int VALUE)
     VALUE:  the boolean to convert

     Converts a boolean to a string, the advantage of this function is
     it allocates memory, and does the dirty job.

     *Return value:*  a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: char * lw6sys_ftoa (float VALUE)
     VALUE:  the float to convert

     Converts a float to a string, the advantage of this function is it
     allocates memory, and does the dirty job.

     *Return value:*  a newly allocated pointer, must be freed, may be
     NULL.

 -- Function: int lw6sys_debug_get ()
     Gets the debug mode.

 -- Function: void lw6sys_debug_set (int MODE)
     MODE:  the debug mode, 1 if set, 0 if not.

     Sets the debug mode.

 -- Function: void lw6sys_dump_clear (char * USER_DIR)
     USER_DIR:  the user directory, where user can write data.

     Clears the dump file. That is, resets it to a "0 byte" file.

     *Return value:*  none.

 -- Function: int lw6sys_dump (char * USER_DIR, char * CONTENT)
     USER_DIR:  the user directory, where user can write data.

     CONTENT:  the content to be written in the dump file.

     Writes the dump file onto the disk. The dump is used for special
     error messages which do not really fit in the standard log, and
     require a special treatment. In pratice, it's used to log fatal
     script (Guile) errors.

     *Return value:*  1 if success, 0 if failure.

 -- Function: char lw6sys_env_separator_char ()
     Gets the ENV separator, that is, for instance, the character used
     to separate paths in environment variables. Typically, this would
     be ":" on GNU and ";" on Microsft platforms.

     *Return value:*  the ascii character code.

 -- Function: char * lw6sys_env_separator_str ()
     Gets the ENV separator, that is, for instance, the character used
     to separate paths in environment variables. Typically, this would
     be ":" on GNU and ";" on Microsft platforms.

     *Return value:*  a pointer to a single 0-terminated character
     string which contains the character. Must not be freed.

 -- Function: char * lw6sys_env_concat (char * VALUE1, char * VALUE2)
     VALUE1:  the left part to be concatenated

     VALUE2:  the right part to be concatenated

     Concatenates two values and puts the ENV separator, as returned by
     `lw6sys_env_separator_char' between them.

     *Return value:*  the concatenated string, must be freed.

 -- Function: int lw6sys_env_exists_prefixed (char * KEYWORD)
     KEYWORD:  the keyword to be searched in the environment variables.

     Searches environment variables for the given keyword. The keyword
     will be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters. Characters will be changed to
     uppercase. Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added. That is to say, calling
     this function with "my-param" will search for the "LW6_MY_PARAM"
     environment variable.

     *Return value:*  1 if the environment variable exists, 0 if not.

 -- Function: char * lw6sys_getenv (char * KEY)
     KEY:  the environment variable to get.

     Searches environment variables for the given value.  This is a
     wrapper over the standard C getenv, the difference is it will
     return a dynamically allocated pointer, and on some platforms will
     query specific OS functions.

     *Return value:*  the value for the given keyword. May be NULL.
     Must be freed.

 -- Function: char * lw6sys_getenv_prefixed (char * KEYWORD)
     KEYWORD:  the keyword to be searched in the environment variables.

     Searches environment variables for the given value. The keyword
     will be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters. Characters will be changed to
     uppercase. Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added. That is to say, calling
     this function with "my-param" will search for the "LW6_MY_PARAM"
     environment variable.

     *Return value:*  the value for the given keyword. May be NULL.
     Must be freed.

 -- Function: int lw6sys_setenv (char * KEYWORD, char * VALUE)
     KEYWORD:  the environment variable to set

     VALUE:  the value of the environment variable to set

     Sets the environment variable to a given value. If value is NULL,
     variable is unset. Note that unlike lw6sys_getenv_prefixed, this
     function does not transform the keyword into "LW6_..."  before
     setting the value, so it's your responsability to call
     "lw6sys_keyword_as_env" if needed.

     *Return value:*  1 if success, 0 if failed

 -- Function: int lw6sys_setenv_prefixed (char * KEYWORD, char * VALUE)
     KEYWORD:  the keyword to be searched in the environment variables.

     VALUE:  the value of the environment variable to set

     Sets the environment variable to the given value. The keyword will
     be fixed so that all dashes "-" characters are replaced by
     underscores "_" characters. Characters will be changed to
     uppercase. Any non alphanumeric character will be replaced by "_".
     Finally, an "LW6_" prefix will be added. That is to say, calling
     this function with "my-param" will set the "LW6_MY_PARAM"
     environment variable.

     *Return value:*  1 if success, 0 if failure

 -- Function: lw6sys_list_t * lw6sys_env_split (char * VALUE)
     VALUE:  the value, a list of item separated by... the separator

     Splits the environment value into a list of strings containing
     each element. All strings are dynamically allocated, but they will
     be freed automatically when the list is freed.

     *Return value:*  a list of strings.

 -- Function: char * lw6sys_get_home ()
     Gets the home directory of the user. Used internally to calculate
     the `user'-dir value. Note that Liquid War 6, by default, never
     stores files under '$HOME', instead it put things in
     '$HOME/.liquidwar6', that is 'user-dir'. If the environment
     variable 'HOME' is not set, will return '.'.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_get_username ()
     Gets the name of the current user. Difference with the standard
     function `getlogin' is that this function will returned a
     dynamically allocated pointer, and provide a default value if it's
     undefined.  Also, if will look at the content of the 'LOGNAME'
     environment variable if needed, and will even provide a default
     value.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_get_hostname ()
     Gets the name of the current host. The name of the computer.
     Might not work perfectly, this function is just used to provide
     default values for player names and such things.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_exec_find_myself (int ARGC, char * [] ARGV)
     ARGC:  number of args as passed to main

     ARGV:  array of args as passed to main

     Finds the path of the program currently run, this is typically to
     pass it to `lw6sys_exec_again' and run it again.

     *Return value:*  the path (newly allocated string).

 -- Function: int lw6sys_is_executed_again (int ARGC, char * [] ARGV)
     ARGC:  number of args as passed to main

     ARGV:  array of args as passed to main

     Tells wether the program is already executed by itself by
     `lw6sys_exec_again' function. Based on environment and command
     switches.

     *Return value:*  1 if executed again, 0 if not.

 -- Function: int lw6sys_exec_again (int ARGC, char * [] ARGV)
     ARGC:  number of args as passed to main

     ARGV:  array of args as passed to main

     Runs the program from itsef, that is fires a new program (the same
     running) and ends up the current one. This is used to fix some
     environment variable issues. If LW6_EXECUTED_AGAIN (environment
     variable) is set, will not run the program so this is not really
     like `exec' as in the C standard library, this function will
     actually return and be successfull even if no other process was
     started. It's just designed to bootstrap/launch the process once.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sys_clear_file (char * FILENAME)
     FILENAME:  absolute or relative filename

     Clears a file, that is, make it a 0 byte file, empty, ready to be
     filled if needed. If this function is called successfully, program
     can reasonnably assume file will be writable during its execution.

     *Return value:*  1 if success, 0 if failure.

 -- Function: char * lw6sys_read_file_content (char * FILENAME)
     FILENAME:  absolute or relative filename

     Reads the content of a file, and returns it as a string.  Note
     that content might or might not be ascii or binary, the function
     will however put a tailing 0 character at the end so that
     low-level standard C functions do not segfault when used with the
     returned value.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: void * lw6sys_read_file_content_bin (int * FILESIZE, char
          * FILENAME)
     FILESIZE:  will contain the file size, in bytes

     FILENAME:  absolute or relative filename

     Reads the content of a file, and returns it as a binary buffer.
     Even if not ascii or binary, the function will however put a
     tailing 0 character at the end so that low-level standard C
     functions do not segfault when used with the returned value. This
     0 character is not included in `filesize' so if there are 4 bytes
     in the file the 5 bytes will be allocated, this is just for string
     functions not to explode if called by accident. The `filesize' can
     be NULL, in that case function is just like the
     `lw6sys_read_file_content' function.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: int lw6sys_write_file_content (char * FILENAME, char *
          CONTENT)
     FILENAME:  absolute or relative filename

     CONTENT:  the content to be written.

     Writes the content into the file. Content is assumed to be a
     string, function will segfault if it's not correctly 0 terminated
     as in C string convention. So this function will not allow you to
     write down arbitrary binary data, however LW6 uses mostly text
     files to store information, and opaque binary data usage is not
     recommended.

 -- Function: lw6sys_hash_t * lw6sys_hash_new (lw6sys_free_func_t
          FREE_FUNC, int SIZE)
     FREE_FUNC:  optional callback used to free memory when stored date
     is a pointer. Can be NULL when one stores non dynamically
     allocated data, such as an integer or a static array.

     SIZE:  the estimated size of the hash table. Note that this is an
     estimation only. You could theorically fit 1000000 objects in a
     3-sized hash. Problem -> this is inefficient, you'd better use an
     assoc or a bigger hash. If you store 3 elements in a 1000000-sized
     hash, you'll waste memory. It might be wise to use a prime number
     as the estimated size. 421 is prime ;)

     Creates an empty hash. There's a difference between NULL and an
     empty hash.

     *Return value:*  a pointer to the newly allocated hash table.
     Must be freed with `lw6sys_hash_free'.

 -- Function: void lw6sys_hash_free (lw6sys_hash_t * HASH)
     HASH:  the hash to be freed.

     The function will cascade  delete all elements, using (if not
     NULL...)  the callback passed when first creating the hash.

     *Return value:*  void

 -- Function: int lw6sys_hash_has_key (lw6sys_hash_t * HASH, char * KEY)
     HASH:  the hash to test

     KEY:  the key to search

     Not a very fast function, since on a "big" hash, strcmp will be
     called internally until the key is found.

     *Return value:*  non-zero if there's an entry with the
     corresponding key.

 -- Function: void * lw6sys_hash_get (lw6sys_hash_t * HASH, char * KEY)
     HASH:  the hash to query

     KEY:  the key of which we want the value

     *Return value:*  a void pointer to the data contained in the hash.
     Note that the pointer on the actual data is returned, that is, if
     it's static data, you must not try to free it... As long as memory
     management is concerned, destroying the hash will actually free
     the data if needed.

 -- Function: void lw6sys_hash_set (lw6sys_hash_t * HASH, char * KEY,
          void * VALUE)
     HASH:  the hash to modify

     KEY:  the key we want to updated

     VALUE:  the new value

     Sets a value in a hash table. The key pointer need not be
     persistent, it can be freed after affectation. In fact a new
     string will be created internally. This is not true for the value,
     it's hard to find way to copy "any object".  So if you want a hash
     table of strings, key can disappear after calling this function,
     but not value. The function passed as free_func when creating the
     hash will be used to free stuff whenever needed (unset or free).

     *Return value:*  void

 -- Function: void lw6sys_hash_unset (lw6sys_hash_t * HASH, char * KEY)
     HASH:  the hash concerned

     KEY:  the key to unset

     Clears an entry in a hash table. The callback passed when creating
     the hash will be called if needed, to free the data automatically.

     *Return value:*  void

 -- Function: lw6sys_list_t * lw6sys_hash_keys (lw6sys_hash_t * HASH)
     HASH:  the hash to work on

     Returns a list containing all the keys of the hash. The list must
     be free with lw6sys_list_free by the caller.  This list copies all
     the keys of the hash, so it is safe to use it once the hash is
     deleted. However the keys will of course be of little interest in
     this case.  But the program won't segfault.

     *Return value:*  the list of keys.

 -- Function: void lw6sys_hash_map (lw6sys_hash_t * HASH,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     HASH:  the hash to work on

     FUNC:  a callback to call on each entry

     FUNC_DATA:  a pointer on some data which will be passed to the
     callback

     Executes a function on all hash items.  The func_data parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global...

     *Return value:*  void

 -- Function: void lw6sys_hash_sort_and_map (lw6sys_hash_t * HASH,
          lw6sys_assoc_callback_func_t FUNC, void * FUNC_DATA)
     HASH:  the hash to work on

     FUNC:  a callback to call on each entry, may be NULL

     FUNC_DATA:  a pointer on some data which will be passed to the
     callback

     Executes a function on all hash items, like
     `lw6sys_hash_sort_and_map' but befor doing so, sorts all entries
     in alphabetical order.

     *Return value:*  void

 -- Function: lw6sys_hash_t * lw6sys_hash_dup (lw6sys_hash_t * HASH,
          lw6sys_dup_func_t DUP_FUNC)
     HASH:  the hash to duplicate, can be NULL

     DUP_FUNC:  the function which will be called to duplicate data

     Duplicates an hash. All keys will be copied so that if the first
     hash is deleted, the duplicated one is fine. Additionnaly, dup_func
     will be called with all data fields. If dup_func is NULL, then data
     values will simply be copied. This is likely to be usefull when
     data is not dynamically allocated.

     *Returned value:*  a newly allocated hash.

 -- Function: lw6sys_hexa_serializer_t * lw6sys_hexa_serializer_new
          (char * HEXA_STRING)
     HEXA_STRING:  an initialization string, can be NULL.

     Creates an hexa serializer object. It can be initialized or not,
     if an initialization string is provided it must of course be valid
     hexadecimal ascii code, and all serialized content will simply be
     appended to it.

     *Return value:*  a newly allocated object.

 -- Function: void lw6sys_hexa_serializer_free
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     HEXA_SERIALIZER:  an hexa serializer object

     Frees an hexa serializer object.

     *Return value:*  none.

 -- Function: void lw6sys_hexa_serializer_rewind
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     HEXA_SERIALIZER:  an hexa serializer object

     Rewinds the serializer pointer, that is, make it point to start.
     Usefull before calling pop functions, when one wants to be sure to
     get the first object.

     *Return value:*  none.

 -- Function: int lw6sys_hexa_serializer_eof (lw6sys_hexa_serializer_t
          * HEXA_SERIALIZER)
     HEXA_SERIALIZER:  an hexa serializer object

     Tests wether we're at EOF. Usefull when one wants to know if
     there's still some data or if all objects have been correctly
     popped.

     *Return value:*  1 if at end of file, 0 if not.

 -- Function: char * lw6sys_hexa_serializer_as_string
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER)
     HEXA_SERIALIZER:  an hexa serializer object

     Exports the current content of the serializer as a string.  String
     can then safely be sent on the network, for instance.  String is
     copied from internal value, so it's safe to use it after
     serializer has been freed or modified.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: int lw6sys_hexa_serializer_push_int64
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int64_t VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a 64 bit integer in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int32
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int32_t VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a 32 bit integer in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int16
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int16_t VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a 16 bit integer in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_int8
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int8_t VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes an 8 bit integer in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_float
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, float VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a floating point value in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_str
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, char * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a string in the serializer object. Note that the string is
     not directly copied in the serializer, instead all its characters
     are converted to their ASCII equivalent, then appended.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_xyz
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_xyz_t
          VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a lw6sys_xyz_t structure in the serializer object.  Calling
     this avoids calling push for 2 integers separately.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_whd
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_whd_t
          VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a lw6sys_whd_t structure in the serializer object.  Calling
     this avoids calling push for 2 integers separately.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_push_color
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_color_8_t
          VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to push

     Pushes a color structure in the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int64
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int64_t * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a 64 bit integer from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int32
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int32_t * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a 32 bit integer from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int16
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int16_t * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a 16 bit integer from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_int8
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, int8_t * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops an 8 bit integer from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_float
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, float * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a floating point value from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_str
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, char ** VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a string from the serializer object. The returned value is a
     newly allocated pointer, which must be freed, you don't need to
     provide a buffer, just a valid pointer on a NULL pointer.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_xyz
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_xyz_t *
          VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a lw6sys_xyz_t structure from the serializer object.  Avoids
     calling two integer pops.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_whd
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_whd_t *
          VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a lw6sys_whd_t structure from the serializer object.  Avoids
     calling two integer pops.

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6sys_hexa_serializer_pop_color
          (lw6sys_hexa_serializer_t * HEXA_SERIALIZER, lw6sys_color_8_t
          * VALUE)
     HEXA_SERIALIZER:  an hexa serializer object

     VALUE:  value to pop (returned value)

     Pops a color from the serializer object.

     *Return value:*  1 if success, 0 if failure

 -- Function: void * lw6sys_hexa_str_to_ptr (char * STR)
     STR:  the string containing an hexa representation of pointer

     Transforms a string into a pointer, this is typically used to
     store pointers in temporary agnostic storage such as a database.
     Beware not to use that to exchange data with other computers
     and/or use it for persistent data. This is a high-risk function as
     it lets you do real dirty stuff but it really does save time
     compared to using a key returned by the database engine and then
     search this key in a user-space hash table. Direct pointer access
     is definitely faster.

     *Return value:*  the pointer, or NULL is str is invalid.

 -- Function: char * lw6sys_hexa_ptr_to_str (void * PTR)
     PTR:  pointer to convert into string representation

     Transforms a pointer into a string, this is typically used to
     store pointers in temporary agnostic storage such as a database.
     Beware not to use that to exchange data with other computers
     and/or use it for persistent data. This is a high-risk function as
     it lets you do real dirty stuff but it really does save time
     compared to using a key returned by the database engine and then
     search this key in a user-space hash table. Direct pointer access
     is definitely faster.

     *Return value:*  the string, can be NULL on errror, must be freed.

 -- Function: void lw6sys_history_init ()
     Initializes the history system. Not initializing won't cause any
     segfault, but data will be inconsistent.

     *Return value:*  none.

 -- Function: void lw6sys_history_register (char * MSG)
     MSG:  the message to register.

     Registers a message in the history log, that is, adds it.

     *Return value:*  none.

 -- Function: char_ptr_t * lw6sys_history_get (int64_t TIMEOUT)
     TIMEOUT:  the message age limit.

     Get all the messages that are younger than timeout (in seconds).

     *Return value:*  a pointer on string pointers. May be NULL. Last
     pointer is NULL too, that's how you know the array is over.

 -- Function: void lw6sys_history_free (char ** HISTORY)
     HISTORY:  the data to free

     Frees a pointer returned by `lw6sys_history_get'.

     *Return value:*  none.

 -- Function: char * lw6sys_locale_to_utf8 (char * STRING)
     STRING:  the string to convert

     Used to force strings into UTF-8 mode, this is basically to match
     the TTF font settings used when displaying stuff on OpenGL.
     Indeed, in this case, the standard _ gettext function won't work,
     we need to force UTF-8 mode. If the locale is UTF-8, then function
     does nothing, but at least it's transparent usage won't hurt.

     *Returned value:*  a newly allocated string, always in UTF-8 no
     matter what the locale is.

 -- Function: u_int16_t lw6sys_generate_id_16 ()
     Long 16-bit ID generator, calls the random function internally.
     As usual, those are not perfect random numbers, however the
     function implementation emphasizes more on 'real randomness'
     rather than relying on performance. Generating twice the same
     number should be fairly rare.

 -- Function: u_int32_t lw6sys_generate_id_32 ()
     Long 32-bit ID generator, calls the random function internally.
     As usual, those are not perfect random numbers, however the
     function implementation emphasizes more on 'real randomness'
     rather than relying on performance. Generating twice the same
     number should be fairly rare.

 -- Function: u_int64_t lw6sys_generate_id_64 ()
     Long 64-bit ID generator, calls the random function internally.
     As usual, those are not perfect random numbers, however the
     function implementation emphasizes more on 'real randomness'
     rather than relying on performance. Generating twice the same
     number should be fairly rare.

 -- Function: int lw6sys_check_id_16 (u_int16_t ID_16)
     ID_16:  the id to check

     Checks wether the given id is a valid 16-bit id.

     *Return value:*  1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id_32 (u_int32_t ID_32)
     ID_32:  the id to check

     Checks wether the given id is a valid 32-bit id.

     *Return value:*  1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id_64 (u_int64_t ID_64)
     ID_64:  the id to check

     Checks wether the given id is a valid 64-bit id.

     *Return value:*  1 if OK, 0 if not a valid id.

 -- Function: int lw6sys_check_id (u_int64_t ID)
     ID:  the id to check

     Checks wether the given id is a valid id (16, 32 or 64-bit).

     *Return value:*  1 if OK, 0 if not a valid id.

 -- Function: char * lw6sys_id_ltoa (u_int64_t ID)
     id: the id to convert

     Transform an id into its string representation. Error checking is
     done, if the id is invalid, returned value is NULL.  All ids (16,
     32 and 64-bit) are handled.

     *Return value:*  a newly allocated string, might be NULL.

 -- Function: u_int64_t lw6sys_id_atol (char * ID)
     id: the id to convert

     Transform an id into a long integer. Error checking is done, if
     the id is invalid, returned value is 0.  All ids (16, 32 and
     64-bit) are handled.

     *Return value:*  the id as a long integer, 0 if incorrect source
     id.

 -- Function: char * lw6sys_keyword_as_key (char * KEYWORD)
     KEYWORD:  the keyword to transform

     Transforms a keyword into a "key", that is, removes all heading
     dashes, switches to lowercase, and other stuff. This is used
     internally to match options and config file parameters, for
     instance.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_arg (char * KEYWORD)
     KEYWORD:  the keyword to transform

     Transforms a keyword into a command-line parameter to be matched.
     Does the same as `lw6sys_keyword_as_key', and adds a "-" prefix.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_env (char * KEYWORD)
     KEYWORD:  the keyword to transform

     Transforms a keyword into the corresponding environment variable
     name.  It will uppercase the name, replace "-" by "_", and add a
     "LW6_" prefix. "my-param" will become "LW6_MY_PARAM".

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_keyword_as_xml (char * KEYWORD)
     KEYWORD:  the keyword to transform

     Transforms a keyword into the corresponding config file entry.  In
     practice, just the same as `lw6sys_keyword_as_key'.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: lw6sys_list_t * lw6sys_list_new (lw6sys_free_func_t
          FREE_FUNC)
     FREE_FUNC:  a callback which will be called on data when freeing
     the list

     Creates an empty list. There's a difference between NULL and an
     empty list. The empty list would (in Scheme) be '() whereas NULL
     corresponds to undefined "is not a list and will generate errors
     if you ever call list functions on it".

     *Return value:*  a pointer to the created object, may be NULL.

 -- Function: void lw6sys_list_free (lw6sys_list_t * LIST)
     LIST:  the list to delete.

     Delete a list, this will cascade delete all the following items in
     the list.

     *Return value:*  none.

 -- Function: lw6sys_list_t * lw6sys_list_next (lw6sys_list_t * LIST)
     LIST:  the current position in the list

     It's safer to call this rather than dig right into the internals
     of the list.

     *Return value:*  a new position in the list, may be NULL.

 -- Function: int lw6sys_list_is_empty (lw6sys_list_t * LIST)
     LIST:  the list we want informations about

     Checks wether the list is empty or not. Note that being empty and
     being NULL is not the same. An empty list is a valid pointer on a
     list where there's no item, a NULL pointer is not a list at all.
     Do *NOT* call this function on NULL.

     *Return value:*  1 if empty, 0 if there is at list one item.

 -- Function: int lw6sys_list_length (lw6sys_list_t * LIST)
     LIST:  the list we want informations about

     Calculates the length of the list. This is a performance killer
     for lists are inadapted to this. But it can still be usefull.

     *Return value:*  the number of elements, 0 is none (empty list).

 -- Function: void lw6sys_list_map (lw6sys_list_t * LIST,
          lw6sys_list_callback_func_t FUNC, void * FUNC_DATA)
     LIST:  the list where elements will be taken

     FUNC:  the function which will be executed

     FUNC_DATA:  additionnal data to be passed to `func'

     Executes a function on all list items.  The `func_data' parameter
     allows you to pass extra values to the function, such as a file
     handler or any variable which can not be inferred from list item
     values, and you of course do not want to make global... Not as
     convenient as a real "for each" construct as can be found in any
     modern langage, but does the job. No return value, if you really
     want one, pass a structure in `func_data' and modify something in
     it on success, failure, whatever.

     *Return value:*  none.

 -- Function: void lw6sys_list_filter (lw6sys_list_t ** LIST,
          lw6sys_list_filter_func_t FUNC, void * FUNC_DATA)
     LIST:  the list where elements will be taken

     FUNC:  the function which will be executed

     FUNC_DATA:  additionnal data to be passed to `func'

     Executes a function on all list items and keeps only those for
     which the function returned non zero (true).  The `func_data'
     parameter allows you to pass extra values to the function, such as
     a file handler or any variable which can not be inferred from list
     item values, and you of course do not want to make global...

     *Return value:*  none.

 -- Function: void lw6sys_list_push_front (lw6sys_list_t ** LIST, void
          * DATA)
     LIST:  a pointer to the list (pointer on pointer, read/write value)

     DATA:  the data to be pushed

     Pushes data on the list. The `free_func' function is copied from
     the previous element. The pointer on the list is changed "in
     place" (in/out). Note that if there's a `malloc' problem it might
     end-up being NULL... This should be rare but it *can* happen. You
     cannot push something else than a pointer, pushing an int is a
     very bad idea. Push a pointer on the integer, and ensure it's
     always there, or `malloc' it and pass `lw6sys_free_callback' when
     creating the list.  If you think you can cast an integer into a
     pointer, think 64-bit machines...

     *Return value:*  none.

 -- Function: void * lw6sys_list_pop_front (lw6sys_list_t ** LIST)
     LIST:  a pointer to the list (pointer on pointer, read/write value)

     Pops data from the list, the returned value is what was passed to
     list_push. The pointer on the list is changed "in place" (in/out).
     When data is popped, that needs some freeing (i.e. free_func was
     not NULL when creating the list) then it's the responsibility of
     the caller to free it when popping it. One popped it's not freed,
     but it's out of the list scope. Of course the lw6sys_list_t is
     freed, but not the data.  If you happen to store non-NULL data in
     your list, you can call this function without bothering calling
     `lw6sys_list_is_empty' and assume that when you get NULL, there's
     no data left.  At this stage, the list won't exist anymore BTW,
     you won't even need to free it. The idea is: popping a list which
     has no elements left (empty list) destroys the list and returns
     NULL.

     *Return value:*  a pointer on the popped data, whatever you pushed.

 -- Function: void lw6sys_list_push_back (lw6sys_list_t ** LIST, void *
          DATA)
     LIST:  a pointer to the list (pointer on pointer, read/write value)

     DATA:  the data to be pushed

     Pushes data on the list. The `free_func' function is copied from
     the previous element. The pointer on the list is changed "in
     place" (in/out). Note that if there's a `malloc' problem it might
     end-up being NULL... This should be rare but it *can* happen. You
     cannot push something else than a pointer, pushing an int is a
     very bad idea. Push a pointer on the integer, and ensure it's
     always there, or `malloc' it and pass `lw6sys_free_callback' when
     creating the list.  If you think you can cast an integer into a
     pointer, think 64-bit machines...

     *Return value:*  none.

 -- Function: void * lw6sys_list_pop_back (lw6sys_list_t ** LIST)
     LIST:  a pointer to the list (pointer on pointer, read/write value)

     Pops data from the list, the returned value is what was passed to
     list_push. The pointer on the list is changed "in place" (in/out).
     When data is popped, that needs some freeing (i.e. free_func was
     not NULL when creating the list) then it's the responsibility of
     the caller to free it when popping it. One popped it's not freed,
     but it's out of the list scope. Of course the lw6sys_list_t is
     freed, but not the data.  If you happen to store non-NULL data in
     your list, you can call this function without bothering calling
     `lw6sys_list_is_empty' and assume that when you get NULL, there's
     no data left.  At this stage, the list won't exist anymore BTW,
     you won't even need to free it. The idea is: popping a list which
     has no elements left (empty list) destroys the list and returns
     NULL.

     *Return value:*  a pointer on the popped data, whatever you pushed.

 -- Function: lw6sys_list_t * lw6sys_list_dup (lw6sys_list_t * LIST,
          lw6sys_dup_func_t DUP_FUNC)
     LIST:  the list to duplicate, can be NULL

     DUP_FUNC:  the function which will be called to duplicate data

     Duplicates a list. All data will be copied so that if the first
     list is deleted, the duplicated one is fine. Addtionnally, dup_func
     will be called to filter all data, and possibly allocated new
     pointers if needed, for instance. If dup_func is NULL, then data
     values will simply be copied. This is likely to be usefull when
     data is not dynamically allocated.

     *Returned value:*  a newly allocated list.

 -- Function: void lw6sys_log_set_file (char * FILENAME)
     FILENAME:  the name of the log file.

     Sets up the log file. Until you call this function, messages all
     logged to the default log file, as returned by the
     `lw6sys_get_default_log_file' function.

     *Return value:*  void

 -- Function: void lw6sys_log_clear (char * FILENAME)
     FILENAME:  the name of the log file.

     Clears the log file, this function would typically be called at
     the beginning of the program. If filename is NULL, then the
     default log file is cleared.

     *Return value:*  void

 -- Function: void lw6sys_log (int LEVEL_ID, char * FILE, int LINE,
          char * FMT, ...)
     LEVEL_ID:  the log level to use. Possible values are, by order,
     LW6SYS_LOG_ERROR_ID (0), LW6SYS_LOG_WARNING_ID (1),
     LW6SYS_LOG_NOTICE_ID (2), LW6SYS_LOG_INFO_ID (3),
     LW6SYS_LOG_DEBUG_ID (4) and LW6SYS_LOG_TMP_ID (5).

     FILE:  the name of the source file where the function is called,
     one can use __FILE__

     LINE:  the line in the source file where the function is called,
     one can use __LINE__

     FMT:  a printf-like format string ...: printf-like arguments,
     corresponding to `fmt'.

     This function is usually called with the first three arguments
     packed into a single macro. For instance the `LW6SYS_LOG_WARNING'
     macro expands and fills the first 3 args, so there's no need to
     type __FILE__ and __LINE__ again and again. Note that this
     function will reset errno. The idea is to call it whenever there's
     something to do with errno (if you deal with errno, it's a good
     habit to log it) then errno is cleared so that it won't interfere
     with next log messages.

 -- Function: void lw6sys_log_critical (char * FMT, ...)
     FMT:  a printf-like format string ...: printf-like arguments,
     corresponding to `fmt'.

     This function is a special log function which will dump
     informations on the console only, without opening any log file
     whatsoever. The idea is that it's a "never fail" function.
     Additionnally, it will never return but quit the program. This can
     be used as an ultimate emergency function, use it when the program
     won't run for sure, and displaying an immediate error message is
     the only issue.

 -- Function: int lw6sys_log_get_level ()

 -- Function: void lw6sys_log_set_level (int LEVEL)
     LEVEL:  the log level, integer between 0 & 4. 4 is very verbose
     (debug), 0 displays errors only.


 -- Function: void lw6sys_math_poly_wy1y2s1 (float * Y, float * S,
          float X, float W, float Y1, float Y2, float S1)
     Y:  the return value (position, may be NULL)

     S:  the return value (speed, may be NULL)

     X:  the x parameter, the value to iterate on

     W:  the width, that is, the x value after which output is constant

     Y1:  the initial value, when v is s1 and x=0

     Y2:  the target value, when v=0 and x>=w

     S1:  the initial speed, that is dy/dx at x=0

     A function which can be used to implement smooth moving. It will
     extrapolate, for values of x>=0, an y position with a continuous
     derivate (dy/dx is continuous, function is 2nd order polynom) and
     which ends up at x=w with a constant value, that is dy/dx=v=0.
     Typically an item set with an initial speed of v with this function

 -- Function: float lw6sys_math_angle_360 (int X, int Y)
     X:  x coordinate

     Y:  y coordinate

     This is a wrapper over the standard `atan' function which will
     handle internally the special x == 0 case and the various
     positive/negative values of `x' and `y'.

     *Return value:*  the angle, in degrees

 -- Function: float lw6sys_math_heartbeat (int64_t X, int PERIOD, float
          Y1, float Y2)
     X:  the parameter (typically a timestamp)

     PERIOD:  the period (typically something like 1000 milliseconds)

     Y1:  the low value (heart at rest)

     Y2:  the high value (when bumping)

     A heartbeat function, typically usefull to power up eye-candy, but
     it could do something else.

 -- Function: int lw6sys_math_blink (int64_t X, int PERIOD)
     X:  the parameter (typically a timestamp)

     PERIOD:  the period (typically something like 1000 milliseconds)

     This function will alternatively return 1 or 0, usefull to handle
     blinking for instance.

     *Return value:*  0 or 1

 -- Function: void * lw6sys_malloc (int SIZE, char * FILE, int LINE)
     SIZE:  number of bytes to allocate.

     FILE:  name of the file calling the function, use `__FILE__'

     LINE:  line in the file calling the function, use `__LINE__'

     This is a wrapper over the standard `malloc' function.
     Additionnally it will keep track of the call with an internal
     program-wide counter, thus enabling memory leak checks. You should
     not use this function directly but use the macro `LW6SYS_MALLOC'
     which has the same syntax, without the last two parameters, which
     are automatically provided by macro expansion.

     *Return value:*  the newly allocated pointer. Data is not
     initialized.

 -- Function: void * lw6sys_calloc (int SIZE, char * FILE, int LINE)
     SIZE:  number of bytes to allocate.

     FILE:  name of the file calling the function, use `__FILE__'

     LINE:  line in the file calling the function, use `__LINE__'

     This is a wrapper over the standard `calloc' function.
     Additionnally it will keep track of the call with an internal
     program-wide counter, thus enabling memory leak checks. You should
     not use this function directly but use the macro `LW6SYS_CALLOC'
     which has the same syntax, without the last two parameters, which
     are automatically provided by macro expansion.

     *Return value:*  the newly allocated pointer. Data is filled with
     zeros.

 -- Function: void * lw6sys_realloc (void * PTR, int SIZE, char * FILE,
          int LINE)
     PTR:  the pointer to reallocate.

     SIZE:  number of bytes to allocate.

     FILE:  name of the file calling the function, use `__FILE__'

     LINE:  line in the file calling the function, use `__LINE__'

     This is a wrapper over the standard `realloc' function.  You
     should not use this function directly but use the macro
     `LW6SYS_REALLOC' which has the same syntax, without the last two
     parameters, which are automatically provided by macro expansion.

     *Return value:*  the newly allocated pointer.

 -- Function: void lw6sys_free (void * PTR, char * FILE, int LINE)
     PTR:  the pointer to free.

     FILE:  name of the file calling the function, use `__FILE__'

     LINE:  line in the file calling the function, use `__LINE__'

     This is a wrapper over the standard `free' function. Additionnally
     it will keep track of the call with an internal program-wide
     counter, thus enabling memory leak checks. You should not use this
     function directly but use the macro `LW6SYS_FREE' which has the
     same syntax, without the last two parameters, which are
     automatically provided by macro expansion.

     *Return value:*  none.

 -- Function: void lw6sys_free_callback (void * PTR)
     PTR:  the pointer to free.

     This is a callback to be used when the `lw6sys_free' does not fit.
     A good example is a list, which, to free its elements, requires
     you to provide a callback that only takes 1 arg, the pointer to
     free. Problem, `lw6sys_free' takes 3 args. And the `LW6SYS_FREE'
     macro is not usable in such a context. And you can't use standard
     `free' either for it would mess up the `malloc' / `free'
     automatical count which is so convenient to track memory leaks. So
     this callback is here, it's only drawback is that in case of an
     error, the error will not be reported with the real file and line
     parameters. It's still better than nothing.

     *Return value:*  none.

 -- Function: int lw6sys_megabytes_available ()
     Gives a raw approximation of available memory, in megabytes.
     Value is to be taken with distance, but it can give good hints
     when system is running short of ressources.

     *Return value:*  number of megabytes (physical memory) available.

 -- Function: int lw6sys_is_big_endian ()
     Checks the endianess of the machine. PPC is big endian, for
     instance.

     *Return value:*  1 if system is big endian, 0 if little endian.

 -- Function: int lw6sys_is_little_endian ()
     Checks the endianess of the machine. x86 is little endian, for
     instance.

     *Return value:*  1 if system is little endian, 0 if big endian.

 -- Function: int lw6sys_check_types_size ()
     Checks of common types and usefull structures, this is a debugging
     function which helps finding compiler strange behaviors and
     programmer's bad intuitions.

     *Return value:*  1 if everything is OK, 0 if error.

 -- Function: void * lw6sys_mutex_create ()
     Creates a mutex object.

     *Return value:*  newly allocated pointer.

 -- Function: void lw6sys_mutex_destroy (void * MUTEX)
     MUTEX:  the mutex to destroy.

     Destroys a mutex object.

     *Return value:*  none.

 -- Function: int lw6sys_mutex_lock (void * MUTEX)
     MUTEX:  the mutex to use

     Locks the mutex. Note that this should never fail unless there's a
     serious initialization problem, instead, function will wait
     forever until mutex is released.

     *Return value:*  1 if success, 0 if failure.

 -- Function: int lw6sys_mutex_trylock (void * MUTEX)
     MUTEX:  the mutex to use

     Tries to locks the mutex. That is, tells wether mutex can be
     locked immediately or not. Note that this does not mean there's
     100% chance next call to lock will terminated immediately, since
     lock can still be acquired by another thread.

     *Return value:*  1 if mutex unlocked, 0 if locked or error.

 -- Function: int lw6sys_mutex_unlock (void * MUTEX)
     MUTEX:  the mutex to use

     Unlocks a mutex.

     *Return value:*  1 if sucess, 0 if error.

 -- Function: int lw6sys_get_mutex_lock_count ()
     Returns how many mutexes have been locked since program start.
     Usefull for sanity checking when debugging.

     *Return value:*  number of calls to lock

 -- Function: int lw6sys_get_mutex_unlock_count ()
     Returns how many mutexes have been unlocked since program start.
     Usefull for sanity checking when debugging.

     *Return value:*  number of calls to unlock

 -- Function: int lw6sys_check_mutex_count ()
     Checks wether unlock has been called as many times as lock.
     Usefull for sanity checking when debugging.

     *Return value:*  1 if OK, 0 if inconsistency.

 -- Function: int lw6sys_true ()
     Function which returns always true, that is, something different
     than 0.

 -- Function: int lw6sys_false ()
     Function which returns always false, that is, 0. This can seem
     totally useless but it does have some utility. It's used for
     instance to "fool" the compiler and force it to compile and link
     functions in binaries, so that, afterwards, dynamically loaded .so
     files can find in the main binary some functions which would
     otherwise be stripped during the final link.

 -- Function: char * lw6sys_get_default_user_dir ()
     Returns the default user directory. Note that this value is not
     static, it can depend, for instance, of the environment variable
     `HOME'.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_config_file ()
     Returns the default config file. Note that this value is not
     static, it can depend, for instance, of the environment variable
     `HOME'.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_log_file ()
     Returns the default log file. Note that this value is not static,
     it can depend, for instance, of the environment variable `HOME'.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_prefix ()
     Returns the default prefix, could be /usr/local for instance.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_mod_dir ()
     Returns the default module directory (dynamically loaded
     libraries).

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_data_dir ()
     Returns the default data directory.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_music_dir ()
     Returns the default music directory.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_music_path ()
     Returns the default music path, which can be composed of several
     directories.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_map_dir ()
     Returns the default map directory.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_map_path ()
     Returns the default map path, which can be composed of several
     directories.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_default_script_file ()
     Returns the default script file.

     *Return value:*  a newly allocated string.

 -- Function: void lw6sys_options_log_defaults ()
     Logs all default values to log file. Usefull for debugging, to
     know where the program is searching for its informations.

 -- Function: char * lw6sys_get_cwd ()
     Returns the current working directory (absolute path).

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_run_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the binary directory, that is, the directory the binary is
     stored in. This is calculated dynamically, by interpreting
     command-line arguments.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_user_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the user dir, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_config_file (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the config file, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_log_file (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the log file, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_prefix (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the prefix, taking in account command-line and environment
     variables. However config file content has no impact on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_mod_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the mod dir (modules, shared .so), taking in account
     command-line and environment variables. However config file
     content has no impact on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_data_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the data dir, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_music_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the music dir, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_music_path (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the music path, taking in account command-line and
     environment variables. However config file content has no impact
     on the result. Music path can contain several directories.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_map_dir (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the map dir, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_map_path (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the map path, taking in account command-line and
     environment variables. However config file content has no impact
     on the result. Map path can contain several directories.

     *Return value:*  a newly allocated string.

 -- Function: char * lw6sys_get_script_file (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Returns the script file, taking in account command-line and
     environment variables. However config file content has no impact
     on the result.

     *Return value:*  a newly allocated string.

 -- Function: void lw6sys_options_log (int ARGC, char * [] ARGV)
     ARGC:  argc, number of arguments, as given to `main'

     ARGV:  argv, pointer to arguments, as given to `main'

     Logs all the main options values which are not config-file
     dependant but depend on built-in defaults, command-line arguments
     and environment variables. Usefull to debug and know where the
     program is searching for things.

 -- Function: int lw6sys_file_exists (char * FILENAME)
     FILENAME:  the file to test

     Tests the existence of a file on the filesystem. File is considered
     to exists if it's at least readable.

     *Return value:*  1 if OK, 0 if file doesn't exist or can't be read.

 -- Function: int lw6sys_dir_exists (char * DIRNAME)
     DIRNAME:  the directory to test

     Tests the existence of a directory on the filesystem.

     *Return value:*  1 if OK, 0 if directory doesn't exist.

 -- Function: int lw6sys_create_dir (char * DIRNAME)
     DIRNAME:  the directory to create

     Creates a directory, performing sanity checks such as verifying
     the directory really exists after being created.

     *Return value:*  1 if OK, 0 if error.

 -- Function: int lw6sys_create_dir_silent (char * DIRNAME)
     DIRNAME:  the directory to create

     Creates a directory like `lw6sys_create_dir' but this function is
     silent in the sense that it won't log any error. Usefull to create
     the log directory itself, for instance, and avoid infinite loops
     on error.

     *Return value:*  1 if OK, 0 if error.

 -- Function: char * lw6sys_path_add_slash (char * PATH)
     PATH:  a path

     Adds a slash, or in a general manner, a directory separator, at
     the end of a path, if needed. So /foo/bar will become /foo/bar/
     but /bar/foo/ will remain /bar/foo/.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_strip_slash (char * PATH)
     PATH:  a path

     Strips the slash, or in a general manner, the directory separator,
     at the end of a path, if needed. So /foo/bar/ will become /foo/bar
     but /bar/foo will remain /bar/foo.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_concat (char * PATH1, char * PATH2)
     PATH1:  left part of the path

     PATH2:  right part of the path

     Concatenates 2 parts of a path. Function will try to avoid stupid
     "double-slash" when concatenating /foo/ with /bar/ and conversely
     insert a directory separator when concatenating /foo with bar/.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: lw6sys_list_t * lw6sys_path_split (char * PATH)
     PATH:  a path

     Splits a path into all its parts. For instance /boo/bar/foo2/bar2
     returns a 4 elements list. This is more than a plain split, for
     heading and tailing slashes will be ignored, and various path
     separators will be interpreted (depends on platform).

     *Return value:*  a list containing 0-terminated strings.

 -- Function: int lw6sys_path_is_relative (char * PATH)
     PATH:  a path

     Checks wether a path is relative or absolute.

     *Return value:*  1 if relative, 0 if absolute.

 -- Function: int lw6sys_path_is_cwd (char * PATH)
     PATH:  a path

     Checks wether a path is "." or not. Will also trap "" and "./".

     *Return value:*  1 if relative, 0 if absolute.

 -- Function: char * lw6sys_path_parent (char * PATH)
     PATH:  a path

     Returns the parent path. That will return /foo when given /foo/bar
     in input.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_unparent (char * PATH)
     PATH:  a path

     Given the ../foo/bar path, will return foo/bar. Usefull to get rid
     of heading ../ when a path is known to start with it.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: char * lw6sys_path_unparent_no_malloc (char * PATH)
     PATH:  a path

     Given the ../foo/bar path, will return foo/bar. Usefull to get rid
     of heading ../ when a path is known to start with it.  This is
     different from `lw6sys_path_unparent' just because the result is
     not dynamically allocated and copied from source.

     *Return value:*  a pointer which points somewhere within the
     string passed as an argument.

 -- Function: lw6sys_list_t * lw6sys_dir_list (char * DIR,
          lw6sys_dir_list_filter_func_t FILTER_FUNC, void * FUNC_DATA,
          int * N)
     DIR:  the path of the directory to list

     FILTER_FUNC:  a function which will filter entries, can be NULL

     FUNC_DATA:  additionnal data passed to filter_func

     N:  will contain the number of items found

     This list a directory. The filter will be passed the file path as
     an argument. If it returns 1, the file is kept, if it returns 0
     it's suppressed from the list.

     *Return value:*  a list containing strings (file paths).

 -- Function: lw6sys_list_t * lw6sys_path_list (char * PATH,
          lw6sys_dir_list_filter_func_t FILTER_FUNC, void * FUNC_DATA,
          int * N)
     PATH:  the path of the path to list

     FILTER_FUNC:  a function which will filter entries, can be NULL

     FUNC_DATA:  additionnal data passed to filter_func

     N:  will contain the number of items found

     This list a directory. By path we mean here a list of separated
     directories, separated by : for instance.  The filter will be
     passed the file path as an argument. If it returns 1, the file is
     kept, if it returns 0 it's suppressed from the list. It's like
     performing a call to `lw6sys_dir_list' on each of the path members.

     *Return value:*  a list containing strings (file paths).

 -- Function: char * lw6sys_find_in_dir_and_path (char * DIR, char *
          PATH, char * FILE)
     DIR:  a directory, when to search the file first

     PATH:  the path to search too, a separated list of dirs

     FILE:  the filename to search for

     Tries to find a file in the given paths. The function is typically
     used to find music files. First it tries to find the file in dir,
     then it tries to find it in each dir of path. `file' must be only
     a file name and not contain any directory. The function will use
     the filename only anyway.

     *Return value:*  the full path of the found file.

 -- Function: void lw6sys_print_xml_header (FILE * F, char * COMMENT)
     F:  file to output content to

     Prints a standard Liquid War compliant XML header in the given
     file.

     *Return value:*  none.

 -- Function: void lw6sys_print_xml_footer (FILE * F)
     F:  file to output content to

     Prints a standard Liquid War 6 compliant XML footer in the given
     file.

     *Return value:*  none.

 -- Function: int lw6sys_profiler_check (int VERBOSE)
     VERBOSE:  wether to display informations on the console

     Checks wether Google Profiler support has been built, and if it's
     set, outputs the log file. If CPUPROFILE is defined but binary has
     no support for it, will display a warning message.

     *Return value:*  1 if google profile enabled and activated, 0 if
     not

 -- Function: void lw6sys_progress_default (lw6sys_progress_t *
          PROGRESS, float * VALUE)
     PROGRESS:  the progress struct to initialize

     VALUE:  the value to point to

     Sets a progress struct to default values, that is, ranging from
     0.0f to 1.0f.

     *Return value:*  none.

 -- Function: void lw6sys_progress_update (lw6sys_progress_t *
          PROGRESS, int MIN, int MAX, int VALUE)
     PROGRESS:  the progress struct to update

     MIN:  the min value

     MAX:  the max value

     VALUE:  the current value

     Updates a progress struct. This is typically the function used by a
     callback to show the progress of a process. Note that this is note
     an initializer. Rather, the progress struct was initialized
     before, and this call is done in a loop with min being 0, max
     being the last value in the loop, and value the current index in
     the loop. NULL pointers correctly handled internally, so call this
     with any parameters, it's safe.

     *Return value:*  none.

 -- Function: void lw6sys_progress_split (lw6sys_progress_t *
          PROGRESS1, lw6sys_progress_t * PROGRESS2, lw6sys_progress_t *
          PROGRESS_SRC)
     progress1: the first part of the splitted progress progress2: the
     second part of the splitted progress progress_src: the progress to
     split

     Utility function to split a progress struct, that is, if a
     progress was ranging from a to b, make 2 progress structs, ranging
     from a to c and from c to b, c being between a and b.

     *Return value:*  none

 -- Function: void lw6sys_progress_split_here (lw6sys_progress_t *
          PROGRESS1, lw6sys_progress_t * PROGRESS2, lw6sys_progress_t *
          PROGRESS_SRC, float HERE)
     progress1: the first part of the splitted progress progress2: the
     second part of the splitted progress progress_src: the progress to
     split here: where to split

     Utility function to split a progress struct, that is, if a
     progress was ranging from a to b, make 2 progress structs, ranging
     from a to c and from c to b, c being between a and b. The here
     value controls what c is. If here=0, then c=a. If here=1, then c=b.

     *Return value:*  none

 -- Function: void lw6sys_progress_split3 (lw6sys_progress_t *
          PROGRESS1, lw6sys_progress_t * PROGRESS2, lw6sys_progress_t *
          PROGRESS3, lw6sys_progress_t * PROGRESS_SRC)
     progress1: the first part of the splitted progress progress2: the
     second part of the splitted progress progress3: the third part of
     the splitted progress progress_src: the progress to split

     Utility function to split a progress struct, this one will split it
     into 3 equal parts.

     *Return value:*  none

 -- Function: void lw6sys_progress_split4 (lw6sys_progress_t *
          PROGRESS1, lw6sys_progress_t * PROGRESS2, lw6sys_progress_t *
          PROGRESS3, lw6sys_progress_t * PROGRESS4, lw6sys_progress_t *
          PROGRESS_SRC)
     progress1: the first part of the splitted progress progress2: the
     second part of the splitted progress progress3: the third part of
     the splitted progress progress4: the fourth part of the splitted
     progress progress_src: the progress to split

     Utility function to split a progress struct, this one will split it
     into 4 equal parts.

     *Return value:*  none

 -- Function: void lw6sys_progress_split5 (lw6sys_progress_t *
          PROGRESS1, lw6sys_progress_t * PROGRESS2, lw6sys_progress_t *
          PROGRESS3, lw6sys_progress_t * PROGRESS4, lw6sys_progress_t *
          PROGRESS5, lw6sys_progress_t * PROGRESS_SRC)
     progress1: the first part of the splitted progress progress2: the
     second part of the splitted progress progress3: the third part of
     the splitted progress progress4: the fourth part of the splitted
     progress progress5: the fourth part of the splitted progress
     progress_src: the progress to split

     Utility function to split a progress struct, this one will split it
     into 5 equal parts.

     *Return value:*  none

 -- Function: void lw6sys_progress_begin (lw6sys_progress_t * PROGRESS)
     progress: the progress to update

     Sets the progress to its min value, NULL values correctly handled.

     *Return value:*  none

 -- Function: void lw6sys_progress_half (lw6sys_progress_t * PROGRESS)
     progress: the progress to update

     Sets the progress to the average between min and max, NULL values
     correctly handled.

     *Return value:*  none

 -- Function: void lw6sys_progress_end (lw6sys_progress_t * PROGRESS)
     progress: the progress to update

     Sets the progress to its max value, NULL values correctly handled.

     *Return value:*  none

 -- Function: u_int32_t lw6sys_random (u_int32_t RANGE)
     RANGE:  the high limit for random generated numbers. If you want
     random numbers between 0 and 5, set this to 6.

     Wrapper over standard random function. This one is thread safe.
     This idea is not to provide cryptographic-proof random numbers,
     rather generate sequences which are random enough to generate
     unique server ids and such things. The function is initialized on
     its first call, and results depend on timestamp, host name, user
     name, and memory available.

 -- Function: float lw6sys_random_float (float MIN, float MAX)
     MIN:  the min value, as a float

     MAX:  the max value, as a float

     Returns a random float number between min & max. Can be equal to
     min or max.

 -- Function: int lw6sys_sdl_register ()
     Function used to avoid initializing SDL several times in a program.
     AFAIK Allegro has a `was_init' function, but SDL doesn't. With this
     function - which every LW6 sub-module should use - one can know
     globally, for the whole program, wether SDL has been initialized
     or not.

 -- Function: int lw6sys_sdl_unregister ()
     Call this whenever you are done with SDL and exit it, so that the
     `lw6sys_sdl_register' function works correctly.

     *Return value:*  1 if SDL needs to be unregistered, that is, if it
     has already been initialized, else 0.

 -- Function: void lw6sys_serialize_int64 (unsigned char * DATA,
          int64_t VALUE)
     DATA:  pointer to the data, must contain at least 8 bytes of
     writable space

     VALUE:  the integer to serialize

     Serializes a 64-bit integer in a byte buffer. Result is not
     dependant on machine endianess. Typically used for checksums or
     high-level serializations.

 -- Function: int64_t lw6sys_unserialize_int64 (unsigned char * DATA)
     DATA:  pointer to the data, must contain at least 8 bytes

     Recovers a 64-bit integer from a byte buffer created, for
     instance, with `lw6sys_serialize_int64'.

 -- Function: void lw6sys_serialize_int32 (unsigned char * DATA,
          int32_t VALUE)
     DATA:  pointer to the data, must contain at least 4 bytes of
     writable space

     VALUE:  the integer to serialize

     Serializes a 32-bit integer in a byte buffer. Result is not
     dependant on machine endianess. Typically used for checksums or
     high-level serializations.

 -- Function: int32_t lw6sys_unserialize_int32 (unsigned char * DATA)
     DATA:  pointer to the data, must contain at least 4 bytes

     Recovers a 32-bit integer from a byte buffer created, for
     instance, with `lw6sys_serialize_int32'.

 -- Function: void lw6sys_serialize_int16 (unsigned char * DATA,
          int16_t VALUE)
     DATA:  pointer to the data, must contain at least 2 bytes of
     writable space

     VALUE:  the integer to serialize

     Serializes a 16-bit integer in a byte buffer. Result is not
     dependant on machine endianess. Typically used for checksums or
     high-level serializations.

 -- Function: int16_t lw6sys_unserialize_int16 (unsigned char * DATA)
     DATA:  pointer to the data, must contain at least 2 bytes

     Recovers a 16-bit integer from a byte buffer created, for
     instance, with `lw6sys_serialize_int16'.

 -- Function: int lw6sys_shape_check_min_max_whd (lw6sys_whd_t * SHAPE,
          int MIN_WH, int MAX_WH, int MAX_D)
     SHAPE:  the dimensions to control

     MIN_WH:  the min value for w and h

     MAX_WH:  the max value for w and h

     MAX_D:  the max value for d

     Will check wether the given shape respects some basic constraints,
     being not to small and not too big.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6sys_shape_check_pos (lw6sys_whd_t * SHAPE,
          lw6sys_xyz_t * POS)
     SHAPE:  the boundary box

     POS:  the position

     Checks wether position is within the given boundary box.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6sys_shape_is_same (lw6sys_whd_t * SHAPE_A,
          lw6sys_whd_t * SHAPE_B)
     SHAPE_A:  the first shape to compare

     SHAPE_B:  the other shape to compare

     Compares two shapes.

     *Return value:*  1 if same, 0 if not.

 -- Function: int lw6sys_shape_is_same_xy (lw6sys_whd_t * SHAPE_A,
          lw6sys_whd_t * SHAPE_B)
     SHAPE_A:  the first shape to compare

     SHAPE_B:  the other shape to compare

     Compares two shapes, but ignores the z (d) parameter.

     *Return value:*  1 if same_xy, 0 if not.

 -- Function: int lw6sys_sort_int_callback (lw6sys_list_t ** LIST_A,
          lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of int item

     LIST_B:  pointer to a list of int item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of integers.

     *Return value:*  -1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', 1 if `list_a' > `list_b'

 -- Function: int lw6sys_sort_int_desc_callback (lw6sys_list_t **
          LIST_A, lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of int item

     LIST_B:  pointer to a list of int item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of integers. This one will sort in reverse mode.

     *Return value:*  1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', -1 if `list_a' > `list_b'

 -- Function: int lw6sys_sort_float_callback (lw6sys_list_t ** LIST_A,
          lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of float item

     LIST_B:  pointer to a list of float item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of floating point numbers.

     *Return value:*  -1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', 1 if `list_a' > `list_b'

 -- Function: int lw6sys_sort_float_desc_callback (lw6sys_list_t **
          LIST_A, lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of float item

     LIST_B:  pointer to a list of float item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of floating point numbers. This one will sort in
     reverse mode.

     *Return value:*  1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', -1 if `list_a' > `list_b'

 -- Function: int lw6sys_sort_str_callback (lw6sys_list_t ** LIST_A,
          lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of string item

     LIST_B:  pointer to a list of string item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of 0-terminated strings.

     *Return value:*  -1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', 1 if `list_a' > `list_b'

 -- Function: int lw6sys_sort_str_desc_callback (lw6sys_list_t **
          LIST_A, lw6sys_list_t ** LIST_B)
     LIST_A:  pointer to a list of string item

     LIST_B:  pointer to a list of string item

     A typicall sort callback function, can be passed to `lw6sys_sort'
     to sort a list of 0-terminated strings. This one will sort in
     reverse mode.

     *Return value:*  1 if `list_a' < `list_b' , 0 if `list_a' ==
     `list_b', -1 if `list_a' > `list_b'

 -- Function: void lw6sys_sort (lw6sys_list_t ** LIST,
          lw6sys_sort_callback_func_t SORT_FUNC)
     LIST:  the list to sort, might be modified by the function

     SORT_FUNC:  the callback function used to sort

     A general sorting function. Internally, will use the glibc `qsort'
     function, but this one is adapted to the LW6 specific data
     structures, more exactly, the `lw6sys_list' structure. Several
     default sort callbacks are defined, but one is free to use any
     callback, provided it has the right prototype.

 -- Function: void * lw6sys_spinlock_create ()
     Creates a spinlock object.

     *Return value:*  newly allocated pointer.

 -- Function: void lw6sys_spinlock_destroy (void * SPINLOCK)
     SPINLOCK:  the spinlock to destroy.

     Destroys a spinlock object.

     *Return value:*  none.

 -- Function: int lw6sys_spinlock_lock (void * SPINLOCK)
     SPINLOCK:  the spinlock to use

     Locks the spinlock. Note that this should never fail unless
     there's a serious initialization problem, instead, function will
     wait forever until spinlock is released.

     *Return value:*  1 if success, 0 if failure.

 -- Function: int lw6sys_spinlock_trylock (void * SPINLOCK)
     SPINLOCK:  the spinlock to use

     Tries to locks the spinlock. That is, tells wether spinlock can be
     locked immediately or not. Note that this does not mean there's
     100% chance next call to lock will terminated immediately, since
     lock can still be acquired by another thread.

     *Return value:*  1 if spinlock unlocked, 0 if locked or error.

 -- Function: int lw6sys_spinlock_unlock (void * SPINLOCK)
     SPINLOCK:  the spinlock to use

     Unlocks a spinlock.

     *Return value:*  1 if sucess, 0 if error.

 -- Function: char * lw6sys_str_copy (char * SRC)
     SRC:  the string to copy

     Duplicate a string, creating a new pointer on it, which must be
     freed afterwards. The main difference with `strdup' is that here
     we use the LW6SYS_MALLOC macro to track down possible memory leaks.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_str_concat (char * STR1, char * STR2)
     STR1:  the left part to be concatenated

     STR2:  the right part to be concatenated

     Concatenate 2 strings, and put the result in a newly allocated
     string. Unlike `strcat' which uses the same pointer.

     *Return value:*  a newly allocated pointer, must be freed.

 -- Function: char * lw6sys_new_sprintf (char * FMT, ...)
     FMT:  a format string, like the one you would pass to `printf'
     ...: optional arguments, like the ones you would pass to `printf'

     An sprintf like function, except it allocates a new string
     automatically, with "enough space". This is not a highly optimized
     function, it will allocate plenty of memory, possibly several
     times, and thus consume time and resources. But it has the great
     advantage of freeing the programmer of the dirty work of guessing
     "how log will the sprintf'ed string be?" before even generating
     it. So it's a time saver for the programmer.  Additionnally, helps
     avoiding memory leaks and buffer overflows.

     *Return value:*  a new allocated string, must be freed.

 -- Function: int lw6sys_str_is_blank (char * STR)
     STR:  the string to test

     Tests wether a string is blank, that is, if it's composed of
     space, tabs, or carriage returns only.

     *Return value:*  1 if blank, 0 if not.

 -- Function: int lw6sys_str_is_same (char * STR_A, char * STR_B)
     STR_A:  1st string to compare, can be NULL

     STR_B:  2nd string to compare, can be NULL

     Compares two strings for equality. Difference with strcmp is that
     this one won't check for alphabetical order and return -1 or +1,
     but will check for NULL args.  of space, tabs, or carriage returns
     only.

     *Return value:*  1 if same, 0 if not.

 -- Function: int lw6sys_skip_blanks (char ** STR_PTR)
     STR_PTR:  a pointer to a string pointer (read/write parameter).

     Skips blanks at the beginning of a string. The passed parameter is
     modifed in place. Usefull for parsing.

     *Return value:*  1 if blanks were found, else 0.

 -- Function: void lw6sys_str_cleanup (char * STR)
     STR:  a pointer to the string, which will be modified in-place.

     Used to clean up some strings, for instance if they come from the
     network, we don't necessarly want system chars to be displayed on
     the console. Basically it removes all characters with an ASCII
     code inferior to 32, that is, all system characters. This way,
     there won't be any tab, linefeed, or any of such characters left.

     *Return value:*  none.

 -- Function: char * lw6sys_str_reformat (char * STR, char * PREFIX,
          int NB_COLUMNS)
     STR:  a pointer to the string we want to modify

     PREFIX:  a prefix to put before each line

     Reformats a string, that is, insert newline characters in the
     right places to that it fits in a given number of columns.  A
     prefix is appended at the beginning of each line.  Will not handle
     strings which already contain newline characters perfectly.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: char * lw6sys_eol ()
     Returns the value of EOL, that is, the "end of line" sequence.
     Will simply return "\n" on UNIX and "\r\n" on Microsoft platforms.
     Note that while this is convenient to write config and example
     files, for instance, it's a bad idea to use this to generate
     network messages, because this kind of message needs to be
     platform independant. Thus any network protocol oriented string
     would use chr(10) and char(13) directly.

     *Return value:*  the EOL string, must not be freed.

 -- Function: lw6sys_list_t * lw6sys_str_split (char * STR, char C)
     STR:  a string

     C:  the delimiter to split with

     Splits a string, for instance 'foo,bar' splited with 'o' will
     return 'f', " and ',bar'.

     *Return value:*  a list containing 0-terminated strings.

 -- Function: lw6sys_list_t * lw6sys_str_split_no_0 (char * STR, char C)
     STR:  a string

     C:  the delimiter to split with

     Splits a string, ignoring empty '0-length' members. For instance
     'foo,bar' splited with 'o' will return 'f' and ',bar'.

     *Return value:*  a list containing 0-terminated strings.

 -- Function: lw6sys_list_t * lw6sys_str_split_config_item (char * STR)
     STR:  a string

     Splits a string, ignoring empty '0-length' members, and using the
     comma ',' as a separator. This is typically usefull for config
     elements such as backend lists. Only paths need another separator
     (platform-dependant).

     *Return value:*  a list containing 0-terminated strings.

 -- Function: void lw6sys_str_toupper (char * STR)
     STR:  the string to modify

     Transforms a string to upper case, the pointer must point to
     modifiable data.

     *Return value:*  none, `str' pointed data modified in-place

 -- Function: void lw6sys_str_tolower (char * STR)
     STR:  the string to modify

     Transforms a string to lower case, the pointer must point to
     modifiable data.

     *Return value:*  none, `str' pointed data modified in-place

 -- Function: int lw6sys_test_exec (int ARGC, char * [] ARGV, int MODE)
     ARGC:  number of args as passed to main

     ARGV:  array of args as passed to main

     MODE:  0 for check only, 1 for full test

     Runs the `sys' module test suite which is specific to exec
     functions, these ones require `argc' and `argv' to be correctly
     set so the extra argument justifies putting it outside
     `lw6sys_test'.  Additionnally, it's not fool proof...

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6sys_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `sys' module test suite, testing most (if not all...)
     functions. Note that some tests perform file system operations and
     might therefore fail on a read-only filesystem, or if user
     permissions are not sufficient.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: void * lw6sys_thread_create
          (lw6sys_thread_callback_func_t CALLBACK_FUNC,
          lw6sys_thread_callback_func_t CALLBACK_JOIN, void *
          CALLBACK_DATA)
     CALLBACK_FUNC:  the main callback, the function that will run the
     thread

     CALLBACK_JOIN:  function which will be called when joining, at the
     end

     CALLBACK_DATA:  data which will be passed to the callback

     Creates a thread. All threads must be joined. This is because we
     really do not want the game to leak, and detached threads are
     typically the kind of thing that leaves stuff in the heap. Note
     that callback_func is just something which will be called when
     joining it can be NULL.  The idea is to put in it free & delete
     functions, which you can't call before joining when you want the
     main thread to get the results of the callback_func.

     *Return value:*  an opaque pointer on the thread. Can be NULL if
     failed.

 -- Function: int lw6sys_thread_is_callback_done (void * THREAD_HANDLER)
     THREAD_HANDLER:  thread to work on

     Tells wether the callback is done, that is to say, wether the
     results are available, and we can join.

     *Return value:*  1 if done, else 0.

 -- Function: int lw6sys_thread_get_id (void * THREAD_HANDLER)
     THREAD_HANDLER:  thread to query

     Returns the id of the thread, this is an internal value, unique
     for each process, which can help identifying the thread.

     *Return value:*  the id, should be >0.

 -- Function: void * lw6sys_thread_get_data (void * THREAD_HANDLER)
     THREAD_HANDLER:  thread to query

     Returns the data associated to the thread, that is, the pointer
     which was passed to the callback function.

     *Return value:*  a pointer.

 -- Function: void lw6sys_thread_join (void * THREAD_HANDLER)
     THREAD_HANDLER:  thread to end

     Joins the thread, that's to say wait until the thread is over, and
     destroys the ressources associated to it. Note that if the thread
     is looping forever, this function will just wait forever.  This is
     the only way to end a thread.

     *Return value:*  none.

 -- Function: int lw6sys_get_thread_create_count ()
     Utility function used to check how many threads where created and
     joined.

     *Return value:*  how many threads were created.

 -- Function: int lw6sys_get_thread_join_count ()
     Utility function used to check how many threads where created and
     joined.

     *Return value:*  how many threads were joined.

 -- Function: int lw6sys_check_thread_count ()
     Utility function used to check how many threads where created and
     joined.  This one will compare the results of
     `lw6sys_get_thread_create_count' and
     `lw6sys_get_thread_join_count'.

     *Return value:*  1 if both are equals, 0 if not (error...).

 -- Function: int64_t lw6sys_get_timestamp ()
     Returns a 64-bit timestamp, for general purpose. The unit is
     milliseconds, should return the number of milliseconds since
     EPOCH. Don't use this for accurate date handling, but rather to
     technical stamp events.

     *Return value:*  the timestamp.

 -- Function: int64_t lw6sys_get_uptime ()
     Returns the number of milliseconds since program was started.
     Milliseconds are often referred to as 'ticks'.

     *Return value:*  the number of milliseconds (64-bit)

 -- Function: int32_t lw6sys_get_cycle ()
     Returns a 32-bit timestamp, which is likely to "loop" and have
     twice the same value during a single program execution. The idea
     here is just to provide a 32-bit value, not too big, for animation
     purposes.  The idea is that with 64-bit values, numbers are too
     big and if the goal is just to animate a cursor or spin a sphere,
     one does not care if every ten hours there's a display glitch
     because value became zero again. Besides, those values are often
     used for their "rest" in a module operation, to translate textures
     for instance, and having too big numbers causes floating point
     imprecisions. In fact those values or even only 20-bit. The
     function is based on `lw6sys_get_uptime'() so it will return 0 at
     game startup.

     *Return value:*  the cycle value, a 20-bit integer.

 -- Function: void lw6sys_timer_update (int64_t * TIMESTAMP, int64_t *
          UPTIME, int32_t * CYCLE)
     TIMESTAMP:  the timestamp in msec since EPOCH (output), can be NULL

     UPTIME:  the uptime in msec since startup (output), can be NULL

     CYCLE:  a 20-bit value for animation purpose.

     Returns timestamp & uptime with only one system call.

     *Return value:*  none (parameters modified).

 -- Function: void lw6sys_sleep (float SECONDS)
     SECONDS:  the number of seconds to wait, fractions allowed

     Will sleep for the given amount of seconds. Same as `lw6sys_delay'
     only input is provided as a floating number of seconds instead of
     ticks.

 -- Function: void lw6sys_delay (int MSEC)
     MSEC:  the number of milliseconds (ticks) to wait

     Will sleep for the given amount of seconds. Provides accurate
     timing and has "about-millisecond" precision, since it uses
     `select' internally.  Might however be interrupted in some cases,
     so consider function can always return quicker than specified. A
     common usage of this function is polling loops, where you don't
     care if 2 polls are very close, but simply want to avoid polling
     continuously, therefore consumming 100% of the CPU for nothing.

 -- Function: void lw6sys_idle ()
     Will sleep for a minimal amount of time, just giving the OS a
     chance to let other threads/processes execute themselves. This can
     make a big difference in polling loops between a process that eats
     100% CPU and a process that has a very moderate load.  of ticks.

 -- Function: void lw6sys_time_init ()
     Global initializations required to handle time properly.

 -- Function: extern char * lw6sys_url_http_from_ip_port (char * IP,
          int PORT)
     IP:  IP address

     PORT:  IP port

     *Returns an http URL pointing to ip:* port that is, adds a heading
     http:// and a trailing /, and treats port 80 as default. This is
     used to create public_url in net modules.

     *Return value:*  a newly allocated string, NULL on error.

 -- Function: int lw6sys_vthread_run (lw6sys_thread_callback_func_t
          CALLBACK_FUNC, lw6sys_thread_callback_func_t CALLBACK_JOIN,
          void * CALLBACK_DATA)
     CALLBACK_FUNC:  the main callback, the function that will run the
     thread

     CALLBACK_JOIN:  function which will be called when joining, at the
     end

     CALLBACK_DATA:  data which will be passed to the callback

     This function is similar to `lw6sys_thread_create', but it's
     dedicated to creating a unique (one per process only) thread,
     which, in turn, will be able to run commands in the main thread
     itself. This is a hack to allow apparently spawned child threads
     to be actually handled by main.  This is because some libraries,
     which LW6 uses in threads, need to be actually called in the main
     thread. SDL, for instance. Note that after running this you loose
     control on the main thread, this one will only wait for possible
     commands from the spawned thread, typically sent with the
     `lw6sys_vthread_create' function.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sys_vthread_is_running ()
     Returns true if `lw6sys_vthread_run' has been called. Note that
     this is not bullet proof, it will return true in a correct manner
     only if you call it from the vthread itself. In practise this
     shouldn't be a problem, the idea is just to write portable code
     for the main control thread and be able to decide on the fly
     wether to create a thread we should prefer the
     `lw6sys_thread_create' or its equivalent the
     `lw6sys_vthread_create' function.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sys_vthread_create (lw6sys_thread_callback_func_t
          CALLBACK_FUNC, lw6sys_thread_callback_func_t CALLBACK_JOIN,
          void * CALLBACK_DATA)
     CALLBACK_FUNC:  the main callback, the function that will run the
     thread

     CALLBACK_JOIN:  function which will be called when joining, at the
     end

     CALLBACK_DATA:  data which will be passed to the callback

     The equivalent of `lw6sys_thread_create' but for the vthread
     infrastructure.  The idea is to pretend firing a spawned thread,
     but in fact it's the main thread that runs the code. This function
     must imperatively be called within the `lw6sys_vthread_run'
     function, else it will fail or be buggy.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6sys_vthread_join ()
     The equivalent of `lw6sys_thread_join' but for the vthread
     infrastructure.  The idea is to pretend firing a spawned thread,
     but in fact it's the main thread that runs the code. This function
     must imperatively be called within the `lw6sys_vthread_run'
     function, else it will fail or be buggy.

     *Return value:*  none.

4.15.22 libtsk
--------------

 -- Function: lw6tsk_loader_t * lw6tsk_loader_new (float SLEEP, float *
          PROGRESS)
     SLEEP:  how many seconds to wait between every poll

     Creates a new loader. This object is used to do some reputed slow
     calculus in the background, in a separated thread. Typical example
     is map loading. This is a high-level objects which encapsulates
     threads and other wizardry.

     *Return value:*  a pointer to the loader, NULL if failed.

 -- Function: void lw6tsk_loader_free (lw6tsk_loader_t * LOADER)
     LOADER:  the loader to free.

     Deletes a loader. Will automatically stop the child thread, free
     data, and so on.

     *Return value:*  none.

 -- Function: char * lw6tsk_loader_repr (lw6tsk_loader_t * LOADER)
     LOADER:  the loader to represent.

     Creates a string which briefly describes the loader.

     *Return value:*  a dynamically allocated pointer, must be freed.

 -- Function: int lw6tsk_loader_get_stage (lw6tsk_loader_t * LOADER)
     LOADER:  the loader to query.

     Returns the current stage of the loader.

     *Return value:*  0 if idle, 1 if loading the map from disk, 2 if
     build dynamic stuff such as game_state.

 -- Function: int lw6tsk_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `tsk' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: 2005 .plan,  Next: Fanfic,  Up: Top

Annexe A 2005 .plan
*******************

Here's my .plan file, which describes what I (Christian Mauduit
(mailto:ufoot@ufoot.org)) have planned for Liquid War 6.  There's no
garantee that what's written here is a precise description of the real
future, however it should give a good idea of what I have in mind.

   Note that the information here was written in summer 2005, it might
or not be accurate now, as the main reason for plans to exist is that
people never follow them. I'm no exception.

A.1 Complete rewrite
====================

Liquid War 6 will be an almost complete rewrite. I mean that common
code between branches 5 and 6 might end up in representing 0% of the
total code. I think this is a wise decision, for the current code is
really hard to maintain, and would not survive any serious cleanup. LW5
was first written in 1998, for DOS, when I had much less experience in
programming. In 7 years I - and other people as well - hacked major
enhancements in it such as cross-platform support, network games, and
if you compare release 5.0 with the latest 5.x.x release, you'll see
that a bunch of things have changed. I had never expected I would patch
and fix this game for so long, and it's no surprise that it's bloated
today.

   FYI, here's a list of what makes LW5 unsuitable for major
improvements without a complete rewrite:

   * global variable hell. Lots of things are stored in globals.

   * hard-coded C GUI. Read src/level.c to get an idea of how horrible
     it is.

   * hard-coded 256 colors paletted mode. A clever bet in 1998
     (performance...). Not anymore.

   * generally bloated code. Makes bug-finding very tricky.

A.2 Technologies
================

Liquid War 6 will use a different technical framework than Liquid War 5
(http://www.ufoot.org/liquidwar/v5).

A.2.1 Script + standard C + assembly
------------------------------------

It happens that coding a large project in pure C is a waist of time, if
possible at all.

   If one applies the standard 80/20 rule to a computer game, one might
state that 80% of the code eat up 20% of the CPU and the other 20% of
the code eat up 80% of the CPU, the former being high-level glue code
and the latter being low-level algorithmic code.

   With Liquid War, one could speak of the 99/01 rule. I mean that 99%
of the CPU time concerns only 1% of the code, and vice-versa.
Basically, Liquid War has a very CPU-greedy core algorithm, still
spends a fair amount of CPU displaying stuff (but this is delegated to
the low-level game programming library) and the rest is totally
unsignificant, in terms of CPU. Point is this "rest" represents the
vast majority of the code, and also represents the very same buggy code
I spend nights to patch on Liquid War 5
(http://www.ufoot.org/liquidwar/v5). I'm talking about network code,
GUI, and other high-level glue-code which are currently being written
in C.

   This idea is to write all this in a convenient scripting language.
There won't be any impact on performances. I can't garantee Liquid War
6 will be blazingly fast, but for sure it won't be the scripting
language fault. And of course if, as in Liquid War 3 and 5, I feel the
need to implement some stuff in assembly for performances issues, I
will do it.

   We end up with a multi-language architecture: script + C + assembly.

   My guess is that I'll use Scheme
(http://www.gnu.org/software/guile/) as an extension language. Python
(http://www.python.org) would be a good choice too. Let's say I'll give
Scheme a chance, and if it's really not adapted, I'll switch back to
Python. The point is that today I know Python and don't really know
Scheme, but, well, it's always a pleasure for me to learn new things.
It's fun.

   So what is planned today is that Liquid War 6 will be a Scheme
program, which will call callbacks functions written in C and/or
assembly. These functions will do all the low-level time consuming
algorithmic and graphical stuff. The rest of the code being entirely
scripted.

A.2.2 OpenGL
------------

Liquid War is not a 3D game, so why use OpenGL?

   * it's a very convenient way to access video hardware acceleration
     with XFree86.

   * low-end computers and/or computers without 3D acceleration can
     still run Liquid War 5 (http://www.ufoot.org/liquidwar/v5).

   * I'm interested in learning/using this API 8-)

   This choice implies that I won't use Allegro
(http://alleg.sourceforge.net/) anymore. Allegro stays a very
convenient library and I would recommend it for it's excellent, easy to
learn, powerfull, and stable. But for the needs of Liquid War 6 I'll
use something else (because of OpenGL). I first thought of using GLUT
(http://freeglut.sourceforge.net/) but I might end up simply using SDL
(http://www.libsdl.org/). The idea is just fo have an OpenGL wrapper
which sets up OpenGL in a similar manner on all platforms, and handles
basic things such as mouse or keyboard.

A.2.3 CSound
------------

I've got two excellent books on Csound (http://www.csounds.com/), and
the will to learn how to use this tool.

   I'll probably use Csound for a number of things, ranging from
"bubbling sounds" to full blown music. Stay tuned 8-)

A.3 Functionnalities
====================

A.3.1 Visual enhancements
-------------------------

Of course Liquid War 6 will look nicer than Liquid War 5
(http://www.ufoot.org/liquidwar/v5), blah blah blah. What do you think?

   Maybe I'll try to use some OpenGL features to make it possible to
play on a ball, on a Moebius ring, or other fancy things. I have
zillion of ideas, future will decide which ones will be implemented
first.

   To make it clear, visual enhancements aren't my top-level priority.
However I'll try and make room for these enhancements, and prepare the
terrain correctly. So it's possible that the first releases of Liquid
War 6 won't be that much better than Liquid War 5
(http://www.ufoot.org/liquidwar/v5), but at least Liquid War 6 will
have the possibility to evolve. Something Liquid War 5
(http://www.ufoot.org/liquidwar/v5) doesn't have.

A.3.2 Rules enhancements
------------------------

There are many things that could be done easily:

   * several cursors for one team

   * alliances between teams

   * deep places on a map, where more liquid can reside

   * circular maps which "connect" the left border to the right one

   * ...

   As for graphical improvements, this is not my top-level priority.
Simply, I'll make the game ready-to-improve. Again, all these
enhancements are very hard to code in Liquid War 5
(http://www.ufoot.org/liquidwar/v5), else I would already have coded
them.  Network enhancements

   That's my top-level prioriry.

   Why is that? Well, think of Liquid War in terms of "what makes it a
good game?" and "what makes it a poor game?".

   It's a good game because:

   * the idea is original

   * the gameplay is addictive

   * you can play on a LAN

   * all the family can play

   * it's cross-platform

   * it's Free Software

   It's a poor game because:

   * it's somewhat ugly and has a retro "back in the eighties" look

   * network games are slow on Internet

   * there are not enough active Internet servers

   For the ugliness, well, OpenGL and some artwork should make it. But
for the network, what's the real problem?

   The real problem is that in the current situation, the server needs
to have all "keystrokes" before doing anything, and all players must be
connected before a game starts. Here's what I plan to do to fix this:

   * players will be able to connect on a game "on the fly". This is
     done by most online games, and it's IMHO a required features for a
     network mode to work on Internet (not speaking of local networks,
     but real wide online gaming). How this will fit with Liquid War's
     rules is not totally decided, but I already know of several way to
     achieve this.

   * I'll implement an "anticipation" system "a la" U61
     (http://www.ufoot.org). This means that no matter if a remote
     player has a poor network connection, things will behave as if
     everything was fine. Internally, the system keeps 2 images of the
     game. One which is "anticipated" and displayed to the player, and
     one which is validated but outdated, kept internally. It's a
     little hard to explain, consumes twice as much CPU and memory, but
     it works. It happens that today the lacking ressource for playing
     Liquid War online is more on the network side than on the local
     CPU and memory aspects.

   * I'll take it to the next level and implement a "peer-to-peer-like"
     network model, in which any client can become a server. The idea
     behind is that if a server quits the game, then a client takes its
     role, letting the game continue for hours. This way one could
     virtually have a never ending Liquid War game which would last
     weeks. I believe this could be really cool. I also believe no
     proprietary game will ever implement that, for in this model
     there's no way to force people to access a centralized server,
     this server usually being the major key in the business model of a
     company which sells proprietary software.

   This third point will be the real enhancement of Liquid War with
version 6. It's one of the very points which drives me to rewrite it
completely. First because it's impossible to implement it without some
heavy work. Then because I find it very motivating.

A.3.3 Hey, you forgot my idea!!!
--------------------------------

Many gamers submitted suggestions, either by mail or by posting
messages on the mailing list.

   Don't worry, I keep them. Not reading them here does not mean I
won't implement them. It simply means I won't implement them first. I
first need the game basically function before enhancing it with fancy
stuff.

A.4 Road map
============

As I stated on the mailing list, when thinking about Liquid War 6,
think of years rather than months (unless I get fired, jobless, or
spend several months in a hospital with a laptop).

   Note that this road map takes it for granted that I'll be the lone
coder on the project. It's unlikely that someone is going to help me
for the first stages, until there's at least something real, something
playable. Something that proves that the concept is valid. Besides,
(real) team work implies a significant overhead, especially at project
start. It's hard to figure out how to distribute tasks when the tasks
themselves are not clearly identified. But for the rest (starting in
2007 or 2008), it's possible that external help might greatly...
...help!

   * 2005 : Project framework should be done. This implies that the
     scripting engine is up and running, graphical mode works, config
     and data loading work, basic menus are available. Nothing playable.

   * 2006 : Import the core algorithm from Liquid War 5
     (http://www.ufoot.org/liquidwar/v5), make the game playable in
     "demo mode" (" la" Liquid War 2), implement the network
     "peer-to-peer-like" mode. At this stage, it will be possible to
     know wether Liquid War 6 is true vaporware or not.

   * 2007 : glue all this together to make something usable by anyone,
     heavy work on the GUI, on the options, on error checking, many bug
     fixes. The goal is to have a game which is equivalent to Liquid
     War 5 (http://www.ufoot.org/liquidwar/v5), with the network
     aspects pushed to the next level.

   * 2008 : tadaaaaaaaaaaa! Release the game "publicly" - inform
     Freshmeat 8-) - and enhance it with all the feedback from gamers
     (bug reports and suggestions received since 1998). Work on artwork
     (both graphics and musics). Write documentation.

   * 2009 : stabilize the game, patch it for all those things which had
     been forgotten back then in 2005, optimize for speed, bug-fix
     bug-fix bug-fix.

   * 2010 : stop maintaining Liquid War 5
     (http://www.ufoot.org/liquidwar/v5), invite Liquid War fans and
     coders to a hudge party in my garden, sing all night, drink beers
     and wine, teach Liquid War strategies to my 5 and 6 year old
     daughters, remember the old times when Liquid War wasn't so cool
     8-)

