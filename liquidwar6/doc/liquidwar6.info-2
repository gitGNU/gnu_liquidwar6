This is /home/mauduit/Home/_/liquidwar6/doc/liquidwar6.info, produced
by makeinfo version 4.13 from
/home/mauduit/Home/_/liquidwar6/doc/liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c)  2005, 2006, 2007, 2008, 2009, 2010, 2011  Christian
Mauduit <ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: Map hints.xml,  Next: Map style.xml,  Prev: Map rules.xml,  Up: Reference

4.12 Map hints.xml
==================

4.12.1 background-color-auto
----------------------------

 -- Command-line option: `--background-color-auto=<value>'
 -- Environment variable: `LW6_BACKGROUND_COLOR_AUTO'
 -- XML key: `background-color-auto'
     Type: boolean

     Default value: true

     Defines wether hud colors will be set automatically from base and
     alternate colors. This is a time saver to keep map designers from
     requiring to redefined every single color in the game. You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg. Then hud_color_frame_bg, hud_color_frame_fg,
     hud_color_text_bg and hud_color_text_fg will be automatically set.

4.12.2 downsize-using-bench-value
---------------------------------

 -- Command-line option: `--downsize-using-bench-value=<value>'
 -- Environment variable: `LW6_DOWNSIZE_USING_BENCH_VALUE'
 -- XML key: `downsize-using-bench-value'
     Type: boolean

     Default value: true

     If set, then the game will automatically downsize a map according
     to the 'bench-value' parameter. Downsizing means: a 1600x1200 maps
     becomes 200x150, for instance. Downsizing causes fighters to be
     bigger because map resolution is lower. This will avoid running
     the game on a too big map, with your computer not being able to
     handle it at the required speed.

4.12.3 downsize-using-fighter-scale
-----------------------------------

 -- Command-line option: `--downsize-using-fighter-scale=<value>'
 -- Environment variable: `LW6_DOWNSIZE_USING_FIGHTER_SCALE'
 -- XML key: `downsize-using-fighter-scale'
     Type: boolean

     Default value: false

     If set, then the game will automatically downsize a map according
     to the 'fighter-scale' parameter. Downsizing means: a 1600x1200
     maps becomes 200x150, for instance. Downsizing causes fighters to
     be bigger because map resolution is lower. This can be usefull if
     you don't want fighters to be too small.

4.12.4 fighter-scale
--------------------

 -- Command-line option: `--fighter-scale=<value>'
 -- Environment variable: `LW6_FIGHTER_SCALE'
 -- XML key: `fighter-scale'
     Type: float

     Default value: 1.0

     Defines how wide (in pixels) fighters must be. This parameter is
     very important and will largely condition the number of fighters
     on the map. It is used when loading the map. If it is, for
     instance, set to 1, there will be exactly a fighter per pixel on
     the screen. That is, if you play 640x480 on an empty map, the
     maximum fighters you could have is about 300000. The idea is that
     by changing the resolution, you also define the density of the
     map. In pratice, this is done in the hope that someone with a slow
     computer will pick up a low resolution and therefore play small
     levels. Conversely, someone with a brand new computer with
     powerfull CPU & GPU will use great resolutions and be happy with
     many fighters on the map. Still, changing the resolution after
     loading the map will not affet the number of fighters. Same for
     network games, the first player, who loads the map, defines its
     properties according to its own settings.

4.12.5 guess-colors
-------------------

 -- Command-line option: `--guess-colors=<value>'
 -- Environment variable: `LW6_GUESS_COLORS'
 -- XML key: `guess-colors'
     Type: boolean

     Default value: true

     Defines wether colors should be set automatically from texture
     colors. If set to true, then the program will try to pick up
     colors automatically from the texture, and will override the
     values of the color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg parameters. How these colors are picked up
     can't be garanteed, so if the map does not have strong contrast or
     if there can be any form of ambiguity, it's safe to set this to
     false and define one's own colors.

4.12.6 guess-moves-per-sec
--------------------------

 -- Command-line option: `--guess-moves-per-sec=<value>'
 -- Environment variable: `LW6_GUESS_MOVES_PER_SEC'
 -- XML key: `guess-moves-per-sec'
     Type: boolean

     Default value: true

     If set, then loader will use 'time-to-cross-level' to guess the
     game speed parameters.

4.12.7 hud-color-auto
---------------------

 -- Command-line option: `--hud-color-auto=<value>'
 -- Environment variable: `LW6_HUD_COLOR_AUTO'
 -- XML key: `hud-color-auto'
     Type: boolean

     Default value: true

     Defines wether hud colors will be set automatically from base and
     alternate colors. This is a time saver to keep map designers from
     requiring to redefined every single color in the game. You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg. Then hud_color_frame_bg, hud_color_frame_fg,
     hud_color_text_bg and hud_color_text_fg will be automatically set.

4.12.8 max-map-height
---------------------

 -- Command-line option: `--max-map-height=<value>'
 -- Environment variable: `LW6_MAX_MAP_HEIGHT'
 -- XML key: `max-map-height'
     Type: integer

     Default value: 3000

     Allows you to give a maximum map height. When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     height, why should I limit it? Now think of the play who plays on
     a old slowish computer with a tiny screen. He might redefine this
     himself, and does not necessarly wishes to fire Gimp to rescale
     the map.

4.12.9 max-map-surface
----------------------

 -- Command-line option: `--max-map-surface=<value>'
 -- Environment variable: `LW6_MAX_MAP_SURFACE'
 -- XML key: `max-map-surface'
     Type: integer

     Default value: 3000000

     Allows you to give a maximum map surface. Map surface is simply
     (width * height). This parameter is just here to save you the
     hassle of defining both 'max-map-width' and 'max-map-height' in a
     consistent manner.

4.12.10 max-map-width
---------------------

 -- Command-line option: `--max-map-width=<value>'
 -- Environment variable: `LW6_MAX_MAP_WIDTH'
 -- XML key: `max-map-width'
     Type: integer

     Default value: 4000

     Allows you to give a maximum map width. When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     width, why should I limit it?  Now think of the play who plays on
     a old slowish computer with a tiny screen.  He might redefine this
     himself, and does not necessarly wishes to fire Gimp to rescale
     the map.

4.12.11 menu-color-auto
-----------------------

 -- Command-line option: `--menu-color-auto=<value>'
 -- Environment variable: `LW6_MENU_COLOR_AUTO'
 -- XML key: `menu-color-auto'
     Type: boolean

     Default value: true

     Defines wether menu colors will be set automatically from base and
     alternate colors. This is a time saver to keep map designers from
     requiring to redefined every single color in the game. You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg. Then menu_color_default_bg,
     menu_color_default_fg, menu_color_selected_bg,
     menu_color_selected_fg, menu_color_disabled_bg and
     menu_color_disabled_fg will be automatically set.

4.12.12 min-map-height
----------------------

 -- Command-line option: `--min-map-height=<value>'
 -- Environment variable: `LW6_MIN_MAP_HEIGHT'
 -- XML key: `min-map-height'
     Type: integer

     Default value: 15

     Allows you to give a minimum map height. When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     height, why should I limit it? Now think of the player who decided
     to play with highly-defined maps because he has a super calculator
     and a hudge screen. He might redefine this himself, and does not
     necessarly wishes to fire Gimp to rescale the map.

4.12.13 min-map-surface
-----------------------

 -- Command-line option: `--min-map-surface=<value>'
 -- Environment variable: `LW6_MIN_MAP_SURFACE'
 -- XML key: `min-map-surface'
     Type: integer

     Default value: 1200

     Allows you to give a minimum map surface. Map surface is simply
     (width * height). This parameter is just here to save you the
     hassle of defining both 'min-map-width' and 'min-map-height' in a
     consistent manner.

4.12.14 min-map-width
---------------------

 -- Command-line option: `--min-map-width=<value>'
 -- Environment variable: `LW6_MIN_MAP_WIDTH'
 -- XML key: `min-map-width'
     Type: integer

     Default value: 20

     Allows you to give a minimum map width. When designing a map you
     might wonder: this is dumb I'm conceiving this map I know its
     width, why should I limit it?  Now think of the player who decided
     to play with highly-defined maps because he has a super calculator
     and a hudge screen. He might redefine this himself, and does not
     necessarly wishes to fire Gimp to rescale the map.

4.12.15 resample
----------------

 -- Command-line option: `--resample=<value>'
 -- Environment variable: `LW6_RESAMPLE'
 -- XML key: `resample'
     Type: boolean

     Default value: true

     If set to true, maps will always be resampled to a size which
     depends on your screen resolution, zoom factor, and the rest. If
     false, maps will be set at the exact resolution of map.png.

4.12.16 speed
-------------

 -- Command-line option: `--speed=<value>'
 -- Environment variable: `LW6_SPEED'
 -- XML key: `speed'
     Type: float

     Default value: 1.0

     This parameter is the main parameter on which game speed depends.
     The map loader will garantee, by downscaling the map, that to
     cross the level (by crossing the level we mean, for instance,
     going from top-left corner to bottom-right corner in a straight
     line) a fighter will take a constant amount of time. Under the
     hood, the loader might of course rescale the map but it will also
     change game speed so that, at the end, fighters take a constant
     time to cross the level. This is, indeed, the most important
     thing, players do not care much if internally there are X or Y
     moves per second, the global game experience depends on how fast
     fighter movement looks on the screen. The default settings
     corresponds roughly to one second to cross the level. If you set
     this to 2.0, it will go twice faster.

4.12.17 system-color-auto
-------------------------

 -- Command-line option: `--system-color-auto=<value>'
 -- Environment variable: `LW6_SYSTEM_COLOR_AUTO'
 -- XML key: `system-color-auto'
     Type: boolean

     Default value: true

     Defines wether system colors will be set automatically from base
     and alternate colors. This is a time saver to keep map designers
     from requiring to redefined every single color in the game. You
     only need to set color-base-bg, color-base-fg, color-alternate-bg
     and color-alternate-fg. Then system_color_bg and system_color_fg
     will be automatically set.

4.12.18 upsize-using-bench-value
--------------------------------

 -- Command-line option: `--upsize-using-bench-value=<value>'
 -- Environment variable: `LW6_UPSIZE_USING_BENCH_VALUE'
 -- XML key: `upsize-using-bench-value'
     Type: boolean

     Default value: false

     If set, then the game will automatically upsize a map according to
     the 'fighter-scale' parameter. Upsizing means: a 160x120 maps
     becomes 400x300, for instance. Upsizing causes fighters to be
     smaller because map resolution is higher. This will avoid useless
     pixelish 'jumbo fighters' look when your computer is powerfull
     enough to do better.

4.12.19 upsize-using-fighter-scale
----------------------------------

 -- Command-line option: `--upsize-using-fighter-scale=<value>'
 -- Environment variable: `LW6_UPSIZE_USING_FIGHTER_SCALE'
 -- XML key: `upsize-using-fighter-scale'
     Type: boolean

     Default value: true

     If set, then the game will automatically upsize a map according to
     the 'fighter-scale' parameter. Upsizing means: a 160x120 maps
     becomes 400x300, for instance. Upsizing causes fighters to be
     smaller because map resolution is higher. This can be usefull if
     you don't want fighters to be too big.

4.12.20 view-color-auto
-----------------------

 -- Command-line option: `--view-color-auto=<value>'
 -- Environment variable: `LW6_VIEW_COLOR_AUTO'
 -- XML key: `view-color-auto'
     Type: boolean

     Default value: true

     Defines wether view colors will be set automatically from base and
     alternate colors. This is a time saver to keep map designers from
     requiring to redefined every single color in the game. You only
     need to set color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg. Then view_color_cursor_bg,
     view_color_cursor_fg, view_color_map_bg and view_color_map_fg will
     be automatically set.

4.12.21 wall-grease
-------------------

 -- Command-line option: `--wall-grease=<value>'
 -- Environment variable: `LW6_WALL_GREASE'
 -- XML key: `wall-grease'
     Type: integer

     Default value: 0 Min value: -5 Max value: 5

     This parameter allows you to make walls (AKA map foreground)
     thicker, or thiner, when map is loaded. Indeed, when map are
     resampled, and especially when they are downscaled, some walls may
     disappear, or some passages may be blocked. The loader can't
     automatically figure out wether it's more important to keep an
     existing wall or to keep an open passage for fighters. This
     parameter helps doing so, if you set it to a low value, level will
     be less greasy, and many passages might open themselves. On the
     contrary, if grease is at a high level, then a thin line of almost
     isolated pixels might become a thick wall. There's no real
     garantee your wall or passage will always be present, but it's a
     same bet to assume on a 'tunnel-like' level one needs to set
     grease to a low value, and on a 'wide open' level with few walls
     one needs to set grease to a high value.


File: liquidwar6.info,  Node: Map style.xml,  Next: Map teams.xml,  Prev: Map hints.xml,  Up: Reference

4.13 Map style.xml
==================

4.13.1 animation-density
------------------------

 -- Command-line option: `--animation-density=<value>'
 -- Environment variable: `LW6_ANIMATION_DENSITY'
 -- XML key: `animation-density'
     Type: float

     Default value: 1.0f Min value: 0 Max value: 10

     Density of the background animation, that is, for instance, if the
     background animation is about displaying bubbles, using a high
     value will display many bubbles. A value of 1.0 corresponds to the
     default setting.

4.13.2 animation-speed
----------------------

 -- Command-line option: `--animation-speed=<value>'
 -- Environment variable: `LW6_ANIMATION_SPEED'
 -- XML key: `animation-speed'
     Type: float

     Default value: 1.0f Min value: 0 Max value: 10

     Speed of the background animation, that is, for instance, if the
     background animation is about displaying bubbles, using a high
     value will cause bubbles to move very fast. A value of 1.0
     corresponds to the default setting.

4.13.3 background-color-root-bg
-------------------------------

 -- Command-line option: `--background-color-root-bg=<value>'
 -- Environment variable: `LW6_BACKGROUND_COLOR_ROOT_BG'
 -- XML key: `background-color-root-bg'
     Type: color

     Default value: #000

     Defines the main background color. This is, for instance, the
     color which will be used to clear the screen before drawing thing.
     Will be automatically guessed from the map texture if color-auto
     is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.4 background-color-root-fg
-------------------------------

 -- Command-line option: `--background-color-root-fg=<value>'
 -- Environment variable: `LW6_BACKGROUND_COLOR_ROOT_FG'
 -- XML key: `background-color-root-fg'
     Type: color

     Default value: #ccc

     Defines a color which will be used together with color-base-bg to
     compose the background. It can be wise to have a minimum contrast
     between this color and color-base-bg, but it is not mandatory,
     especially if other colors are manually redefined. Will be
     automatically guessed from the map texture if color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.5 background-color-stuff-bg
--------------------------------

 -- Command-line option: `--background-color-stuff-bg=<value>'
 -- Environment variable: `LW6_BACKGROUND_COLOR_STUFF_BG'
 -- XML key: `background-color-stuff-bg'
     Type: color

     Default value: #333

     Defines a color which will be used together with
     color-alternate-fg to draw things (animations, sprites, text,
     whatever) in the background. It should be different enough from
     color-alternate-fg so that one can really distinguish these
     colors. Will be automatically guessed from the map texture if
     color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.6 background-color-stuff-fg
--------------------------------

 -- Command-line option: `--background-color-stuff-fg=<value>'
 -- Environment variable: `LW6_BACKGROUND_COLOR_STUFF_FG'
 -- XML key: `background-color-stuff-fg'
     Type: color

     Default value: #fff

     Defines a color which will be used to draw things (animations,
     sprites, text, whatever) in the background. It should be different
     enough from color-alternate-bg so that one can really distinguish
     these colors. Think of this as the sprite, the text, the
     whatever-needs-to-be-seen-uses-this color.  Will be automatically
     guessed from the map texture if color-auto is set. Can be #RGB,
     #RGBA, #RRGGBB or #RRGGBBAA.

4.13.7 background-style
-----------------------

 -- Command-line option: `--background-style=<value>'
 -- Environment variable: `LW6_BACKGROUND_STYLE'
 -- XML key: `background-style'
     Type: string

     Default value: bubbles

     The background defines, of course, what is displayed at the
     background, but it also conditions the colors used for other
     items, such as the menus for instance. The possible values are
     'void' and 'bubbles'.

4.13.8 blink-cursor
-------------------

 -- Command-line option: `--blink-cursor=<value>'
 -- Environment variable: `LW6_BLINK_CURSOR'
 -- XML key: `blink-cursor'
     Type: boolean

     Default value: false

     If set, then cursor will blink, allowing you to see what's under
     the cursor.  It's just a matter of taste, you might to always have
     your cursor displayed, or prefer to have it disappear from time to
     time so that you can see the action below

4.13.9 color-alternate-bg
-------------------------

 -- Command-line option: `--color-alternate-bg=<value>'
 -- Environment variable: `LW6_COLOR_ALTERNATE_BG'
 -- XML key: `color-alternate-bg'
     Type: color

     Default value: #333

     Defines the alternate color, more precisely, its bg (background)
     part. Colors are always defined by a bg/fg pair. Most colors in
     the game can be deduced from this one, usually to color a map you
     only need to define color-base-bg, color-base-fg,
     color-alternate-bg and color-alternate-fg.

4.13.10 color-alternate-fg
--------------------------

 -- Command-line option: `--color-alternate-fg=<value>'
 -- Environment variable: `LW6_COLOR_ALTERNATE_FG'
 -- XML key: `color-alternate-fg'
     Type: color

     Default value: #fff

     Defines the alternate color, more precisely, its fg (foreground)
     part. Colors are always defined by a bg/fg pair. Most colors in
     the game can be deduced from this one, usually to color a map you
     only need to define color-base-bg, color-base-fg,
     color-alternate-bg and color-alternate-fg.

4.13.11 color-base-bg
---------------------

 -- Command-line option: `--color-base-bg=<value>'
 -- Environment variable: `LW6_COLOR_BASE_BG'
 -- XML key: `color-base-bg'
     Type: color

     Default value: #000

     Defines the base color, more precisely, its bg (background) part.
     Colors are always defined by a bg/fg pair. Most colors in the game
     can be deduced from this one, usually to color a map you only need
     to define color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.

4.13.12 color-base-fg
---------------------

 -- Command-line option: `--color-base-fg=<value>'
 -- Environment variable: `LW6_COLOR_BASE_FG'
 -- XML key: `color-base-fg'
     Type: color

     Default value: #ccc

     Defines the base color, more precisely, its fg (foreground) part.
     Colors are always defined by a bg/fg pair. Most colors in the game
     can be deduced from this one, usually to color a map you only need
     to define color-base-bg, color-base-fg, color-alternate-bg and
     color-alternate-fg.

4.13.13 colorize
----------------

 -- Command-line option: `--colorize=<value>'
 -- Environment variable: `LW6_COLORIZE'
 -- XML key: `colorize'
     Type: boolean

     Default value: true

     If set, then all background drawings including textures will use
     the background colors. This means, for instance, that if
     background colors are set automatically by color-auto from the map
     texture, then the background will adopt the same range of colors
     than the map itself. In short, the background will mimic the map.

4.13.14 colorize-cursor
-----------------------

 -- Command-line option: `--colorize-cursor=<value>'
 -- Environment variable: `LW6_COLORIZE_CURSOR'
 -- XML key: `colorize-cursor'
     Type: boolean

     Default value: true

     If set, then all cursors will use the automatic guessed colors, or
     the specified colors, but basically they won't be displayed using
     their native colors. This can be usefull for you can wish to use a
     generic non-colored texture for your cursor and let it be
     colorized automatically so that it's accorded to the level.

4.13.15 cursor-size
-------------------

 -- Command-line option: `--cursor-size=<value>'
 -- Environment variable: `LW6_CURSOR_SIZE'
 -- XML key: `cursor-size'
     Type: float

     Default value: 1.0f Min value: 0 Max value: 10

     Size of the cursors on the map. 1 is the default, setting it to a
     higher value will make cursors bigger, a lower value will make
     them smaller.

4.13.16 hidden-layer-alpha
--------------------------

 -- Command-line option: `--hidden-layer-alpha=<value>'
 -- Environment variable: `LW6_HIDDEN_LAYER_ALPHA'
 -- XML key: `hidden-layer-alpha'
     Type: float

     Default value: 0.1f Min value: 0 Max value: 1

     Whenever players are supposed to be hidden behind a wall, for
     instance if they are in layer 2 and layer 1 is filled with walls,
     it's still possible to see them, but with a low alpha value
     (almost transparent). This parameter allows you to trick this
     value, 0 will make these players absolutely invisible, 1 will make
     them totally opaque, like if they were on layer 1.

4.13.17 hud-color-frame-bg
--------------------------

 -- Command-line option: `--hud-color-frame-bg=<value>'
 -- Environment variable: `LW6_HUD_COLOR_FRAME_BG'
 -- XML key: `hud-color-frame-bg'
     Type: color

     Default value: #000

     Defines the background color for the hud frame. Ignored if
     hud-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.18 hud-color-frame-fg
--------------------------

 -- Command-line option: `--hud-color-frame-fg=<value>'
 -- Environment variable: `LW6_HUD_COLOR_FRAME_FG'
 -- XML key: `hud-color-frame-fg'
     Type: color

     Default value: #ccc

     Defines the foreground color for the hud frame. Ignored if
     hud-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.19 hud-color-text-bg
-------------------------

 -- Command-line option: `--hud-color-text-bg=<value>'
 -- Environment variable: `LW6_HUD_COLOR_TEXT_BG'
 -- XML key: `hud-color-text-bg'
     Type: color

     Default value: #333

     Defines the background color for hud text. Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.20 hud-color-text-fg
-------------------------

 -- Command-line option: `--hud-color-text-fg=<value>'
 -- Environment variable: `LW6_HUD_COLOR_TEXT_FG'
 -- XML key: `hud-color-text-fg'
     Type: color

     Default value: #fff

     Defines the foreground color for hud text. Ignored if
     hud-color-auto is set.  Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.21 hud-style
-----------------

 -- Command-line option: `--hud-style=<value>'
 -- Environment variable: `LW6_HUD_STYLE'
 -- XML key: `hud-style'
     Type: string

     Default value: floating

     The hud is where informations about the game are displayed. This
     means, who is winning, are other status-like informations.
     Possible values include 'floating' and 'tactical'.

4.13.22 keep-ratio
------------------

 -- Command-line option: `--keep-ratio=<value>'
 -- Environment variable: `LW6_KEEP_RATIO'
 -- XML key: `keep-ratio'
     Type: boolean

     Default value: true

     Defines wether the map should keep its ratio, or if it should be
     stretched to fill the shape of your screen.

4.13.23 menu-color-default-bg
-----------------------------

 -- Command-line option: `--menu-color-default-bg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_DEFAULT_BG'
 -- XML key: `menu-color-default-bg'
     Type: color

     Default value: #333

     Defines the default background color for menus. Ignored if
     menu-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.24 menu-color-default-fg
-----------------------------

 -- Command-line option: `--menu-color-default-fg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_DEFAULT_FG'
 -- XML key: `menu-color-default-fg'
     Type: color

     Default value: #fff

     Defines the default foreground color for menus. In fact, this is
     the main color for menu text, the color used to draw letters in
     menus. Ignored if menu-color-auto is set. Can be #RGB, #RGBA,
     #RRGGBB or #RRGGBBAA.

4.13.25 menu-color-disabled-bg
------------------------------

 -- Command-line option: `--menu-color-disabled-bg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_DISABLED_BG'
 -- XML key: `menu-color-disabled-bg'
     Type: color

     Default value: #000

     Defines the background color for a disabled menu item. Ignored if
     menu-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.26 menu-color-disabled-fg
------------------------------

 -- Command-line option: `--menu-color-disabled-fg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_DISABLED_FG'
 -- XML key: `menu-color-disabled-fg'
     Type: color

     Default value: #ccc

     Defines the foreground color for a disabled menu item. Ignored if
     menu-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.27 menu-color-selected-bg
------------------------------

 -- Command-line option: `--menu-color-selected-bg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_SELECTED_BG'
 -- XML key: `menu-color-selected-bg'
     Type: color

     Default value: #fff

     Defines the background color for a selected menu item. Ignored if
     menu-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.28 menu-color-selected-fg
------------------------------

 -- Command-line option: `--menu-color-selected-fg=<value>'
 -- Environment variable: `LW6_MENU_COLOR_SELECTED_FG'
 -- XML key: `menu-color-selected-fg'
     Type: color

     Default value: #333

     Defines the foreground color for a selected menu item. Ignored if
     menu-color-auto is set. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.29 menu-style
------------------

 -- Command-line option: `--menu-style=<value>'
 -- Environment variable: `LW6_MENU_STYLE'
 -- XML key: `menu-style'
     Type: string

     Default value: cylinder

     The menu style is simply the name of the engine used to power the
     menu system.  The only possible value, for now, is 'cylinder'.

4.13.30 music-exclude
---------------------

 -- Command-line option: `--music-exclude=<value>'
 -- Environment variable: `LW6_MUSIC_EXCLUDE'
 -- XML key: `music-exclude'
     Type: string

     Default value: Chadburn

     If this string is found in a music file name, it will be excluded
     from the list when playing in random mode.

4.13.31 music-file
------------------

 -- Command-line option: `--music-file=<value>'
 -- Environment variable: `LW6_MUSIC_FILE'
 -- XML key: `music-file'
     Type: string

     Default value:

     Allows you to play a custom music file (typically your own ogg
     music) and override default game music. If file does not exist,
     game will use its internal music. The file will be searched for in
     the current 'music-path' but also in the current map directory. No
     absolute or even relative path are allowed, only a plain filename
     with no slash or backslash. Avoid special characters at all cost.

4.13.32 music-filter
--------------------

 -- Command-line option: `--music-filter=<value>'
 -- Environment variable: `LW6_MUSIC_FILTER'
 -- XML key: `music-filter'
     Type: string

     Default value:

     A music filter, used when files are played randomly. This is not a
     complex regex-enabled filter, just a plain string search. Even the
     '*' wildcard won't work. If you want precise control on what music
     file to play, please consider reorganizing your files and/or use
     the 'music-file' parameter.

4.13.33 pixelize
----------------

 -- Command-line option: `--pixelize=<value>'
 -- Environment variable: `LW6_PIXELIZE'
 -- XML key: `pixelize'
     Type: boolean

     Default value: false

     Depending on the renderer capabilities, will try to pixelize some
     parts of the game. This can be used to emulate the old LW5
     appearance.

4.13.34 system-color-bg
-----------------------

 -- Command-line option: `--system-color-bg=<value>'
 -- Environment variable: `LW6_SYSTEM_COLOR_BG'
 -- XML key: `system-color-bg'
     Type: color

     Default value: #333

     Defines the system background color, used when displaying system
     info, such as the number of frames per second. Can be #RGB, #RGBA,
     #RRGGBB or #RRGGBBAA.

4.13.35 system-color-fg
-----------------------

 -- Command-line option: `--system-color-fg=<value>'
 -- Environment variable: `LW6_SYSTEM_COLOR_FG'
 -- XML key: `system-color-fg'
     Type: color

     Default value: #fff

     Defines the system foreground color, used when displaying system
     info, such as the number of frames per second. This will typically
     be text color. Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.36 team-color-blue
-----------------------

 -- Command-line option: `--team-color-blue=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_BLUE'
 -- XML key: `team-color-blue'
     Type: color

     Default value: #00f

     Defines the color for the blue team. Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.37 team-color-cyan
-----------------------

 -- Command-line option: `--team-color-cyan=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_CYAN'
 -- XML key: `team-color-cyan'
     Type: color

     Default value: #0ff

     Defines the color for the cyan team. Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.38 team-color-dead
-----------------------

 -- Command-line option: `--team-color-dead=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_DEAD'
 -- XML key: `team-color-dead'
     Type: color

     Default value: #000

     Defines the color for the teams when they are dead. By default it
     is black, this means when a team is weak it becomes black. Syntax
     is HTML-like, #RGB or #RRGGBB.

4.13.39 team-color-green
------------------------

 -- Command-line option: `--team-color-green=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_GREEN'
 -- XML key: `team-color-green'
     Type: color

     Default value: #0f0

     Defines the color for the green team. Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.40 team-color-lightblue
----------------------------

 -- Command-line option: `--team-color-lightblue=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_LIGHTBLUE'
 -- XML key: `team-color-lightblue'
     Type: color

     Default value: #8bf

     Defines the color for the light blue team. Syntax is HTML-like,
     #RGB or #RRGGBB.

4.13.41 team-color-magenta
--------------------------

 -- Command-line option: `--team-color-magenta=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_MAGENTA'
 -- XML key: `team-color-magenta'
     Type: color

     Default value: #f0f

     Defines the color for the magenta team. Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.42 team-color-orange
-------------------------

 -- Command-line option: `--team-color-orange=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_ORANGE'
 -- XML key: `team-color-orange'
     Type: color

     Default value: #f80

     Defines the color for the orange team. Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.43 team-color-pink
-----------------------

 -- Command-line option: `--team-color-pink=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_PINK'
 -- XML key: `team-color-pink'
     Type: color

     Default value: #f8b

     Defines the color for the pink team. Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.44 team-color-purple
-------------------------

 -- Command-line option: `--team-color-purple=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_PURPLE'
 -- XML key: `team-color-purple'
     Type: color

     Default value: #b8f

     Defines the color for the purple team. Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.45 team-color-red
----------------------

 -- Command-line option: `--team-color-red=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_RED'
 -- XML key: `team-color-red'
     Type: color

     Default value: #f00

     Defines the color for the red team. Syntax is HTML-like, #RGB or
     #RRGGBB.

4.13.46 team-color-yellow
-------------------------

 -- Command-line option: `--team-color-yellow=<value>'
 -- Environment variable: `LW6_TEAM_COLOR_YELLOW'
 -- XML key: `team-color-yellow'
     Type: color

     Default value: #ff0

     Defines the color for the yellow team. Syntax is HTML-like, #RGB
     or #RRGGBB.

4.13.47 view-color-cursor-bg
----------------------------

 -- Command-line option: `--view-color-cursor-bg=<value>'
 -- Environment variable: `LW6_VIEW_COLOR_CURSOR_BG'
 -- XML key: `view-color-cursor-bg'
     Type: color

     Default value: #333

     Defines the background cursor color. Will typically be used to
     draw the shape of the cursor. Ignored if view-color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.48 view-color-cursor-fg
----------------------------

 -- Command-line option: `--view-color-cursor-fg=<value>'
 -- Environment variable: `LW6_VIEW_COLOR_CURSOR_FG'
 -- XML key: `view-color-cursor-fg'
     Type: color

     Default value: #fff

     Defines the foreground cursor color. Will typically be used to
     draw text in the cursor. Ignored if view-color-auto is set. Can be
     #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.49 view-color-map-bg
-------------------------

 -- Command-line option: `--view-color-map-bg=<value>'
 -- Environment variable: `LW6_VIEW_COLOR_MAP_BG'
 -- XML key: `view-color-map-bg'
     Type: color

     Default value: #000

     Defines the background map color. If there's no map texture
     defined or if use-texture is false, this is the color of the
     places where armies will go.  Ignored if view-color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.50 view-color-map-fg
-------------------------

 -- Command-line option: `--view-color-map-fg=<value>'
 -- Environment variable: `LW6_VIEW_COLOR_MAP_FG'
 -- XML key: `view-color-map-fg'
     Type: color

     Default value: #ccc

     Defines the foreground map color. If there's no map texture
     defined or if use-texture is false, this is the color of walls,
     what armies can't go through. Ignored if view-color-auto is set.
     Can be #RGB, #RGBA, #RRGGBB or #RRGGBBAA.

4.13.51 view-style
------------------

 -- Command-line option: `--view-style=<value>'
 -- Environment variable: `LW6_VIEW_STYLE'
 -- XML key: `view-style'
     Type: string

     Default value: flat

     The view style conditions which renderer is used for the map, the
     area where fighters are displayed. This is not the graphics
     backend. Indeed, the graphics backend defines which technical tool
     one uses (which library) one runs, wether this parameter says what
     kind of rendering one wants.

4.13.52 waves
-------------

 -- Command-line option: `--waves=<value>'
 -- Environment variable: `LW6_WAVES'
 -- XML key: `waves'
     Type: boolean

     Default value: true

     Activates the wave effect, that's to say level appears to be under
     water when playing.

4.13.53 x-wrap
--------------

 -- Command-line option: `--x-wrap=<value>'
 -- Environment variable: `LW6_X_WRAP'
 -- XML key: `x-wrap'
     Type: boolean

     Default value: true

     Defines wether the map should be wrapped on the x axis. This is
     the companion of 'x-polarity', if no polarity is defined, map
     can't be wrapped, but in some cases, one might wish to have a map
     with polarity but without wrapping if, for instance, textures do
     not tile nicely.

4.13.54 y-wrap
--------------

 -- Command-line option: `--y-wrap=<value>'
 -- Environment variable: `LW6_Y_WRAP'
 -- XML key: `y-wrap'
     Type: boolean

     Default value: true

     Defines wether the map should be wrapped on the y axis. This is
     the companion of 'y-polarity', if no polarity is defined, map
     can't be wrapped, but in some cases, one might wish to have a map
     with polarity but without wrapping if, for instance, textures do
     not tile nicely.

4.13.55 zoom
------------

 -- Command-line option: `--zoom=<value>'
 -- Environment variable: `LW6_ZOOM'
 -- XML key: `zoom'
     Type: float

     Default value: 1.0f

     Defines the map zoom. If lower than 1.0, map will occupy only a
     fraction of the screen, if greater than 1.0, some areas will be
     outside the screen, and the player will need to scroll through it.

4.13.56 zoom-max
----------------

 -- Command-line option: `--zoom-max=<value>'
 -- Environment variable: `LW6_ZOOM_MAX'
 -- XML key: `zoom-max'
     Type: float

     Default value: 30.0f

     Defines the max map zoom. If set to a high value, you'll be able to
     dynamically view the map with hudge fighters, seeing only a
     fraction of the level.

4.13.57 zoom-min
----------------

 -- Command-line option: `--zoom-min=<value>'
 -- Environment variable: `LW6_ZOOM_MIN'
 -- XML key: `zoom-min'
     Type: float

     Default value: 0.3f

     Defines the min map zoom. If set to a low value, you'll be able to
     dynamically view a very small, reduced map.


File: liquidwar6.info,  Node: Map teams.xml,  Next: Advanced settings,  Prev: Map style.xml,  Up: Reference

4.14 Map teams.xml
==================

4.14.1 bot-iq
-------------

 -- Command-line option: `--bot-iq=<value>'
 -- Environment variable: `LW6_BOT_IQ'
 -- XML key: `bot-iq'
     Type: integer

     Default value: 100 Min value: 0 Max value: 200

     The IQ (intelligence quotient) of bots. Typically, a value of 100
     will make the bot behave normally, performing at its best. A value
     of 0 will just make it act the worst way it can. Values over 100
     probably won't change anything compared to 100, but this truely
     depends on which bot backend you're running.

4.14.2 bot-speed
----------------

 -- Command-line option: `--bot-speed=<value>'
 -- Environment variable: `LW6_BOT_SPEED'
 -- XML key: `bot-speed'
     Type: float

     Default value: 1.0f

     The speed of bots, 1 means normal speed, higher value will speed
     it up, lower will slow it down. Note that this only has an impact
     on bot engines, not on the game speed itself.

4.14.3 bot1-ai
--------------

 -- Command-line option: `--bot1-ai=<value>'
 -- Environment variable: `LW6_BOT1_AI'
 -- XML key: `bot1-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 1.

4.14.4 bot1-color
-----------------

 -- Command-line option: `--bot1-color=<value>'
 -- Environment variable: `LW6_BOT1_COLOR'
 -- XML key: `bot1-color'
     Type: string

     Default value: green

     Color for bot number 1.

4.14.5 bot2-ai
--------------

 -- Command-line option: `--bot2-ai=<value>'
 -- Environment variable: `LW6_BOT2_AI'
 -- XML key: `bot2-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 2.

4.14.6 bot2-color
-----------------

 -- Command-line option: `--bot2-color=<value>'
 -- Environment variable: `LW6_BOT2_COLOR'
 -- XML key: `bot2-color'
     Type: string

     Default value: blue

     Color for bot number 2.

4.14.7 bot3-ai
--------------

 -- Command-line option: `--bot3-ai=<value>'
 -- Environment variable: `LW6_BOT3_AI'
 -- XML key: `bot3-ai'
     Type: string

     Default value: random

     AI engine for bot number 3.

4.14.8 bot3-color
-----------------

 -- Command-line option: `--bot3-color=<value>'
 -- Environment variable: `LW6_BOT3_COLOR'
 -- XML key: `bot3-color'
     Type: string

     Default value: yellow

     Color for bot number 3.

4.14.9 bot4-ai
--------------

 -- Command-line option: `--bot4-ai=<value>'
 -- Environment variable: `LW6_BOT4_AI'
 -- XML key: `bot4-ai'
     Type: string

     Default value: follow

     AI engine for bot number 4.

4.14.10 bot4-color
------------------

 -- Command-line option: `--bot4-color=<value>'
 -- Environment variable: `LW6_BOT4_COLOR'
 -- XML key: `bot4-color'
     Type: string

     Default value: cyan

     Color for bot number 4.

4.14.11 bot5-ai
---------------

 -- Command-line option: `--bot5-ai=<value>'
 -- Environment variable: `LW6_BOT5_AI'
 -- XML key: `bot5-ai'
     Type: string

     Default value: random

     AI engine for bot number 5.

4.14.12 bot5-color
------------------

 -- Command-line option: `--bot5-color=<value>'
 -- Environment variable: `LW6_BOT5_COLOR'
 -- XML key: `bot5-color'
     Type: string

     Default value: magenta

     Color for bot number 5.

4.14.13 bot6-ai
---------------

 -- Command-line option: `--bot6-ai=<value>'
 -- Environment variable: `LW6_BOT6_AI'
 -- XML key: `bot6-ai'
     Type: string

     Default value: follow

     AI engine for bot number 6.

4.14.14 bot6-color
------------------

 -- Command-line option: `--bot6-color=<value>'
 -- Environment variable: `LW6_BOT6_COLOR'
 -- XML key: `bot6-color'
     Type: string

     Default value: orange

     Color for bot number 6.

4.14.15 bot7-ai
---------------

 -- Command-line option: `--bot7-ai=<value>'
 -- Environment variable: `LW6_BOT7_AI'
 -- XML key: `bot7-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 7.

4.14.16 bot7-color
------------------

 -- Command-line option: `--bot7-color=<value>'
 -- Environment variable: `LW6_BOT7_COLOR'
 -- XML key: `bot7-color'
     Type: string

     Default value: lightblue

     Color for bot number 7.

4.14.17 bot8-ai
---------------

 -- Command-line option: `--bot8-ai=<value>'
 -- Environment variable: `LW6_BOT8_AI'
 -- XML key: `bot8-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 8.

4.14.18 bot8-color
------------------

 -- Command-line option: `--bot8-color=<value>'
 -- Environment variable: `LW6_BOT8_COLOR'
 -- XML key: `bot8-color'
     Type: string

     Default value: purple

     Color for bot number 8.

4.14.19 bot9-ai
---------------

 -- Command-line option: `--bot9-ai=<value>'
 -- Environment variable: `LW6_BOT9_AI'
 -- XML key: `bot9-ai'
     Type: string

     Default value: idiot

     AI engine for bot number 9.

4.14.20 bot9-color
------------------

 -- Command-line option: `--bot9-color=<value>'
 -- Environment variable: `LW6_BOT9_COLOR'
 -- XML key: `bot9-color'
     Type: string

     Default value: pink

     Color for bot number 9.

4.14.21 nb-bots
---------------

 -- Command-line option: `--nb-bots=<value>'
 -- Environment variable: `LW6_NB_BOTS'
 -- XML key: `nb-bots'
     Type: integer

     Default value: 2 Min value: 0 Max value: 9

     Number of bots on the map. 0 means no bots, if set to 1 the the
     bot1-...  settings will be used, if set to 2 then bot1-... and
     bot2-... will be used, and so on.

4.14.22 player-color
--------------------

 -- Command-line option: `--player-color=<value>'
 -- Environment variable: `LW6_PLAYER_COLOR'
 -- XML key: `player-color'
     Type: string

     Default value: red

     Color of the player in solo mode, must be red, green, blue,
     yellow, cyan, magenta, orange, lightblue, purple or pink. Note
     that this is different from player1-... parameters, this is used
     when playing solo with default settings, relying on what the map
     provides, if you want to play with custom color/teams settings,
     then this will just be ignored.


File: liquidwar6.info,  Node: Advanced settings,  Next: C to Guile,  Prev: Map teams.xml,  Up: Reference

4.15 Advanced settings
======================

4.15.1 base64-decode
--------------------

 -- Command-line option: `--base64-decode'
     If specified, program will take stdin and base64 decode it to
     stdout. This is for testing purpose (for network messages for
     instance). Will decode in standard base64 encoding using
     characters + and / but also the url-compliant version using - and
     /, see RFC 4648 for details.

4.15.2 base64-encode
--------------------

 -- Command-line option: `--base64-encode'
     If specified, program will take stdin and base64 encode it to
     stdout. This is for testing purpose (for network messages for
     instance). Will *not* use standard base64 encoding using
     characters + and / but - and _ instead to be url-compliant, see
     RFC 4648 for details.

4.15.3 bench
------------

 -- Command-line option: `--bench'
     Runs a benchmarking test which will report an approximative
     performance estimation of the game on your computer.

4.15.4 bench-value
------------------

 -- Command-line option: `--bench-value=<value>'
 -- Environment variable: `LW6_BENCH_VALUE'
 -- XML key: `bench-value'
     Type: integer

     Default value: 20

     Contains the current bench value of the computer running the game.
     This is used internally to choose the right map settings. You can
     override this value and use your own but... use at your own risk.
     Pretending you have a faster computer than what you really have
     can lead to confusion.

4.15.5 bin-id
-------------

 -- Command-line option: `--bin-id=<value>'
 -- Environment variable: `LW6_BIN_ID'
 -- XML key: `bin-id'
     Type: integer

     Default value: 0

     The internal 'bin-id' value. Note that this is not necessarly
     equal to the value returned by 'show-build-bin-id'. When they are
     different, it is assumed this is because of a software upgrade.

4.15.6 check
------------

 -- Command-line option: `--check'
     Running the game with '-check' is almost like running '-test', the
     difference is that '-check' will not run tests which involve
     graphics or sound backends, so it's adapted to pure console mode.
     This can be usefull for automated checks on a build farm, or if
     you want to check things in a headless (pure console) environment.

4.15.7 commands-per-sec
-----------------------

 -- Command-line option: `--commands-per-sec=<value>'
 -- Environment variable: `LW6_COMMANDS_PER_SEC'
 -- XML key: `commands-per-sec'
     Type: integer

     Default value: 5

     Defines the number of commands per second. When a command is
     generated, orders are actually sent to the game engine, for
     instance, 'this cursor moved there'.  So this option will affect
     game responsiveness, setting this to a high value will make the
     game more responsive but consume bandwidth on network games.

4.15.8 daemon
-------------

 -- Command-line option: `--daemon'
     Start the game in daemon mode, this is typically used with the
     server mode, if you want the process to be detached from the
     console and executed in the background.

4.15.9 debug-layer-id
---------------------

 -- Command-line option: `--debug-layer-id=<value>'
 -- Environment variable: `LW6_DEBUG_LAYER_ID'
 -- XML key: `debug-layer-id'
     Type: integer

     Default value: 0 Min value: 0 Max value: 6

     A team id which will be used for debugging purposes, for instance
     when displaying gradient.

4.15.10 debug-team-id
---------------------

 -- Command-line option: `--debug-team-id=<value>'
 -- Environment variable: `LW6_DEBUG_TEAM_ID'
 -- XML key: `debug-team-id'
     Type: integer

     Default value: 0 Min value: 0 Max value: 9

     A team id which will be used for debugging purposes, for instance
     when displaying gradient.

4.15.11 demo
------------

 -- Command-line option: `--demo'
     Start the game in demo mode. 2 bots play against each other
     forever.

4.15.12 dirty-read
------------------

 -- Command-line option: `--dirty-read=<value>'
 -- Environment variable: `LW6_DIRTY_READ'
 -- XML key: `dirty-read'
     Type: integer

     Default value: 2 Min value: 0 Max value: 2

     How to handle dirty reads and locks when displaying stuff. If set
     to 0, there will be no dirty reads at all, a lock (mutex) will be
     set whenever it's needed. If set to 1, display might be done with
     inconsistent data, however the data itself won't be modified while
     displaying. If set to 2, displayed data can (and will) be modified
     while the rendering thread is running.

4.15.13 display-background
--------------------------

 -- Command-line option: `--display-background=<value>'
 -- Environment variable: `LW6_DISPLAY_BACKGROUND'
 -- XML key: `display-background'
     Type: boolean

     Default value: true

     Decides wether the background animation/image should be displayed
     at all.

4.15.14 display-console
-----------------------

 -- Command-line option: `--display-console=<value>'
 -- Environment variable: `LW6_DISPLAY_CONSOLE'
 -- XML key: `display-console'
     Type: boolean

     Default value: false

     Defines wether the interactive system console must be displayed.
     Note that console support must have been enabled at compilation
     time. It might not be available on your computer, for instance if
     you are running a system such as Microsoft Windows.

4.15.15 display-cursors
-----------------------

 -- Command-line option: `--display-cursors=<value>'
 -- Environment variable: `LW6_DISPLAY_CURSORS'
 -- XML key: `display-cursors'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the
     display of cursors when playing.

4.15.16 display-debug-gradient
------------------------------

 -- Command-line option: `--display-debug-gradient=<value>'
 -- Environment variable: `LW6_DISPLAY_DEBUG_GRADIENT'
 -- XML key: `display-debug-gradient'
     Type: boolean

     Default value: false

     Set this to 'true' to display the gradient, this is usefull to
     debug the core algorithm or understand how it works.

4.15.17 display-debug-zones
---------------------------

 -- Command-line option: `--display-debug-zones=<value>'
 -- Environment variable: `LW6_DISPLAY_DEBUG_ZONES'
 -- XML key: `display-debug-zones'
     Type: boolean

     Default value: false

     Set this to 'true' to display the zones, this is usefull to debug
     the core algorithm or understand how it works.

4.15.18 display-fighters
------------------------

 -- Command-line option: `--display-fighters=<value>'
 -- Environment variable: `LW6_DISPLAY_FIGHTERS'
 -- XML key: `display-fighters'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the
     display of fighters when playing.

4.15.19 display-fps
-------------------

 -- Command-line option: `--display-fps=<value>'
 -- Environment variable: `LW6_DISPLAY_FPS'
 -- XML key: `display-fps'
     Type: boolean

     Default value: false

     Set this to 'true' to display the number of frames per second.
     When this gets too low... play a smaller map, buy a new computer
     or contribute and hack Liquid War 6 so that it runs faster!

4.15.20 display-hud
-------------------

 -- Command-line option: `--display-hud=<value>'
 -- Environment variable: `LW6_DISPLAY_HUD'
 -- XML key: `display-hud'
     Type: boolean

     Default value: true

     Decides wether the hud (informations while playing) should be
     displayed.

4.15.21 display-log
-------------------

 -- Command-line option: `--display-log=<value>'
 -- Environment variable: `LW6_DISPLAY_LOG'
 -- XML key: `display-log'
     Type: boolean

     Default value: true

     Set this to 'false' to disable the display of error messages on
     the screen.  Mote that you can miss valuable informations.

4.15.22 display-map
-------------------

 -- Command-line option: `--display-map=<value>'
 -- Environment variable: `LW6_DISPLAY_MAP'
 -- XML key: `display-map'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable map
     (level) display when playing.

4.15.23 display-menu
--------------------

 -- Command-line option: `--display-menu=<value>'
 -- Environment variable: `LW6_DISPLAY_MENU'
 -- XML key: `display-menu'
     Type: boolean

     Default value: true

     Debugging option which can be set to 'false' to disable the
     display of menus.

4.15.24 display-mouse
---------------------

 -- Command-line option: `--display-mouse=<value>'
 -- Environment variable: `LW6_DISPLAY_MOUSE'
 -- XML key: `display-mouse'
     Type: boolean

     Default value: true

     Set this to 'false' to always hide the mouse pointer.

4.15.25 display-mps
-------------------

 -- Command-line option: `--display-mps=<value>'
 -- Environment variable: `LW6_DISPLAY_MPS'
 -- XML key: `display-mps'
     Type: boolean

     Default value: false

     Set this to 'true' to display the number of moves per second. In
     theory the game should maintain this constant but in practise it
     can get low if your computer is too slow or too busy.

4.15.26 display-preview
-----------------------

 -- Command-line option: `--display-preview=<value>'
 -- Environment variable: `LW6_DISPLAY_PREVIEW'
 -- XML key: `display-preview'
     Type: boolean

     Default value: true

     Decides wether a map preview should be displayed when choosing a
     level.

4.15.27 display-progress
------------------------

 -- Command-line option: `--display-progress=<value>'
 -- Environment variable: `LW6_DISPLAY_PROGRESS'
 -- XML key: `display-progress'
     Type: boolean

     Default value: true

     Decides wether a progress bar should be displayed when a long
     operation is realized as a background task.

4.15.28 display-score
---------------------

 -- Command-line option: `--display-score=<value>'
 -- Environment variable: `LW6_DISPLAY_SCORE'
 -- XML key: `display-score'
     Type: boolean

     Default value: true

     Decides wether the score screen should be displayed.

4.15.29 display-splash
----------------------

 -- Command-line option: `--display-splash=<value>'
 -- Environment variable: `LW6_DISPLAY_SPLASH'
 -- XML key: `display-splash'
     Type: boolean

     Default value: true

     Set this to 'false' to disable the display of the splash screen at
     game startup.

4.15.30 display-url
-------------------

 -- Command-line option: `--display-url=<value>'
 -- Environment variable: `LW6_DISPLAY_URL'
 -- XML key: `display-url'
     Type: boolean

     Default value: false

     Set this to 'true' to display the URL (homepage) of the game. This
     is mostly used when doing screenshots, so that generated images
     contain a link to the homepage.

4.15.31 executed-again
----------------------

 -- Command-line option: `--executed-again=<value>'
 -- Environment variable: `LW6_EXECUTED_AGAIN'
 -- XML key: `executed-again'
     Type: boolean

     Default value: false

     This environment variable/keyword is used to detect wether the
     program has been launched by itself with an internal execv call.
     This is used as a workarround to set some environment variables
     (DYLD_LIBRARY_PATH on Mac OS X for instance) before the program is
     run, as sometimes using setenv() inside the program does not work.

4.15.32 gfx-cpu-usage
---------------------

 -- Command-line option: `--gfx-cpu-usage=<value>'
 -- Environment variable: `LW6_GFX_CPU_USAGE'
 -- XML key: `gfx-cpu-usage'
     Type: float

     Default value: 0.75 Min value: 0 Max value: 1

     Percentage of the CPU which will be used by the display thread.
     It's wise to leave some time to other threads to execute. The OS
     does it naturally, but setting this helps the whole process by
     explicitely pausing (sleep call) the display thread. You could
     change this to a low value if you have lagging games but smooth
     display.

4.15.33 gfx-debug
-----------------

 -- Command-line option: `--gfx-debug=<value>'
 -- Environment variable: `LW6_GFX_DEBUG'
 -- XML key: `gfx-debug'
     Type: boolean

     Default value: false

     Enables dedicated graphics debugging tools. This is different from
     'debug' mode which is global, this one is really graphics specific.

4.15.34 io-per-sec
------------------

 -- Command-line option: `--io-per-sec=<value>'
 -- Environment variable: `LW6_IO_PER_SEC'
 -- XML key: `io-per-sec'
     Type: integer

     Default value: 15

     Defines the number of calls to input/output functions per second.
     This can affect speed of menus but also cursors, but won't change
     the speed of the game itself. It's a cosmectic, comfort option.

4.15.35 loader-sleep
--------------------

 -- Command-line option: `--loader-sleep=<value>'
 -- Environment variable: `LW6_LOADER_SLEEP'
 -- XML key: `loader-sleep'
     Type: float

     Default value: 0.5

     Defines how long the loader thread should wait between two polls.
     Default value should fit in most cases.

4.15.36 log-level
-----------------

 -- Command-line option: `--log-level=<value>'
 -- Environment variable: `LW6_LOG_LEVEL'
 -- XML key: `log-level'
     Type: integer

     Default value: 3 Min value: 0 Max value: 4

     Defines the log level, that is, how verbose the program will be
     regarding logs and console output. 0 (ERROR) is the minimum, only
     errors are reported. 1 (WARNING) means errors + warnings. 2
     (NOTICE) displays most important messages. 3 (INFO) is the
     default, the log file will contain all messages but debug stuff. 4
     (DEBUG) logs everything, including debug informations.

4.15.37 log-timeout
-------------------

 -- Command-line option: `--log-timeout=<value>'
 -- Environment variable: `LW6_LOG_TIMEOUT'
 -- XML key: `log-timeout'
     Type: integer

     Default value: 5000

     Delay, in msec, for which a log message will stay displayed on the
     screen.

4.15.38 magic-number
--------------------

 -- Command-line option: `--magic-number=<value>'
 -- Environment variable: `LW6_MAGIC_NUMBER'
 -- XML key: `magic-number'
     Type: integer

     Default value: 14741

     This 'magic' number probably requires an explanation. It's used to
     estimate how big a map can be built. The calculus is very
     approximative, basically
     bench_value*magic_number=total_fighters_on_map*rounds_per_sec*moves_per_round
     with total_fighters_on_map depending on various parameters such as
     map size but also how many fighters are on the map. The map loader
     will try and adjust the map size so that it is just big enough not
     to saturate your CPU while being as high-res as possible. The
     magic number in itself has no real meaning, the higher it gets,
     the more optimized it means the game is. Normally you shouldn't
     change this but if you find the map resizing is too agressively
     pessimistic, or if for some reason bench returns bogus values, you
     can modify it.

4.15.39 max-local-bench-value
-----------------------------

 -- Command-line option: `--max-local-bench-value=<value>'
 -- Environment variable: `LW6_MAX_LOCAL_BENCH_VALUE'
 -- XML key: `max-local-bench-value'
     Type: integer

     Default value: 800

     Even if your computer is very fast, this parameter will be used to
     tame the optimism of the test, and do not load maps in very high
     detail. It's believed at some point, it's best to keep your extra
     power to deal with unordinary situations rather than waste it on
     useless details. Game should be fun with that setting, but if you
     really want to use your shiny CPU at its maximum, raise this.

4.15.40 max-network-bench-value
-------------------------------

 -- Command-line option: `--max-network-bench-value=<value>'
 -- Environment variable: `LW6_MAX_NETWORK_BENCH_VALUE'
 -- XML key: `max-network-bench-value'
     Type: integer

     Default value: 200

     On network games, we need to be sure everyone can play in correct
     conditions, therefore maps won't be loaded with more details than
     this, by default. You're free to increase this parameter but it
     can cause your games to be unjoignable by some people.

4.15.41 memory-bazooka-eraser
-----------------------------

 -- Command-line option: `--memory-bazooka-eraser=<value>'
 -- Environment variable: `LW6_MEMORY_BAZOOKA_ERASER'
 -- XML key: `memory-bazooka-eraser'
     Type: boolean

     Default value: true

     The memory eraser is a tool which will systematically fill
     allocated memory with 'M', and overwrite all allocated bytes with
     'F' before freeing memory. It will even handle realloc calls. This
     is usefull to track bugs. Indeed, with this option enabled,
     freshly allocated memory will never contain zeroes unless one
     calls calloc, and if you ever free some memory zone before being
     done with it, it will be filled with junk and therefore not be
     usable. The memory bazooka must be big enough if you want this
     feature to actually work.

4.15.42 memory-bazooka-size
---------------------------

 -- Command-line option: `--memory-bazooka-size=<value>'
 -- Environment variable: `LW6_MEMORY_BAZOOKA_SIZE'
 -- XML key: `memory-bazooka-size'
     Type: integer

     Default value: 99991

     The memory bazooka is a brute-force tool, conceived after a full
     night spent tracking some memory leak. The idea is to keep a track
     of all allocated pointers, when the data was allocated
     (timestamp), where in the code (file, line), and even point out
     what data there is in that place. A memory bazooka report at the
     end of the game will just show what's left. There should be
     nothing. This parameter is here to avoid wasting CPU cycles on a
     feature which is very debug-oriented and does not really make
     sense for the casual user. Set it to 0 for best performance,
     something like 100 might just be helpfull, but 1000000 is the
     right way to seriously debug code.

4.15.43 net-log
---------------

 -- Command-line option: `--net-log=<value>'
 -- Environment variable: `LW6_NET_LOG'
 -- XML key: `net-log'
     Type: boolean

     Default value: false

     Activates network log, that is, logs everything sent/received over
     the network, except data which is sent through a third party
     library such as libCurl. This is mostly for debugging purpose, it
     can lead to rather big log files.

4.15.44 network-reliability
---------------------------

 -- Command-line option: `--network-reliability=<value>'
 -- Environment variable: `LW6_NETWORK_RELIABILITY'
 -- XML key: `network-reliability'
     Type: integer

     Default value: 1000 Min value: 1 Max value: 1000000000

     The program assumes network is non-reliable, however the problem
     with those assumptions is that when you test, network is always
     reliable, even with non-garanteed protocols like UDP. This option
     will force the program to actually ignore some calls to send or
     recv functions, simulating a network disfunction. This is to
     ensure the internal mecanisms correcting network problems do work
     for good, on daily regular use. It's not possible to set it to a
     perfect behavior, never dropping any packet, however using the
     default settings you probably won't even notice the performance
     drop induced by having to fix problems. The highest the number is,
     the most reliable network will look, the algorithm is simply to
     drop one message out of X.

4.15.45 open-relay
------------------

 -- Command-line option: `--open-relay=<value>'
 -- Environment variable: `LW6_OPEN_RELAY'
 -- XML key: `open-relay'
     Type: boolean

     Default value: false

     Enables forwarding of abritrary network messages. If open relay is
     forbidden, the game will only forward messages when physical
     sender and logical sender are the same. This is to say if messages
     come from A for C and is sent by A to B, B will forward it to C.
     But if message comes from X to C and is sent by A to B, then B
     won't forward it. In practice, it means without open relay,
     messages can only be forwarded once.

4.15.46 pilot-lag
-----------------

 -- Command-line option: `--pilot-lag=<value>'
 -- Environment variable: `LW6_PILOT_LAG'
 -- XML key: `pilot-lag'
     Type: integer

     Default value: 10

     Maximum lag, in rounds, until the game engine is slowed down. This
     will typically be usefull if your computer is too slow for the map
     resolution and the game speed you set up.

4.15.47 quick-start
-------------------

 -- Command-line option: `--quick-start'
     Start the game just like if the player had requested a quick
     start, without showing any menu.

4.15.48 reset
-------------

 -- Command-line option: `--reset'
     Clears the config file so that the game will run with defaults
     next time. The idea is to get rid of traces of previous
     executions. The difference with '-defaults' is that '-reset' does
     not run the game, while '-defaults' does.

4.15.49 reset-config-on-upgrade
-------------------------------

 -- Command-line option: `--reset-config-on-upgrade=<value>'
 -- Environment variable: `LW6_RESET_CONFIG_ON_UPGRADE'
 -- XML key: `reset-config-on-upgrade'
     Type: boolean

     Default value: true

     If set, then a reset (config file set to defaults) is run every
     time you upgrade the game.

4.15.50 server
--------------

 -- Command-line option: `--server'
     Start the game in server mode, without requiring any graphics
     backend. Server mode is usefull if you just want to start a
     network node without hosting any real game on it. It can be used
     to list existing nodes and sessions or as a bounce server in case
     some clients can't contact each other because firewalled. If you
     only want to start a server game on your computer, don't use this
     option, just start the game normally and start a game server by
     clicking on the GUI buttons.

4.15.51 target-fps
------------------

 -- Command-line option: `--target-fps=<value>'
 -- Environment variable: `LW6_TARGET_FPS'
 -- XML key: `target-fps'
     Type: integer

     Default value: 60

     Defines how many frames will be displayed per second. Of course
     this is a maximum value, if your hardware can't keep up with this
     value, display will just be slow, no matter what value you define
     here. Note that you might really wish to have something rather low
     here, to keep network and 'logic' function responsiveness. Passed
     60 frames per second, speed is really only for visual comfort, as
     Liquid War 6 is now so fast-paced that it requires 200 frames/sec
     to outperform opponents.

4.15.52 trojan
--------------

 -- Command-line option: `--trojan=<value>'
 -- Environment variable: `LW6_TROJAN'
 -- XML key: `trojan'
     Type: boolean

     Default value: false

     Make the program act like a (stupid) trojan horse, trying to fake
     messages, sending various inconsistent informations. This is to
     check the normal version of the program is able to detect such a
     fake and kick it out of the game. It's of no use for regular
     players, be sure to unset this if you want to play for good.

4.15.53 z-decode
----------------

 -- Command-line option: `--z-decode'
     If specified, program will take stdin and z-decode it to stdout.
     This is for testing purpose (for network messages for instance).
     Z-decoding, here means verifying there a Z at the beginning,
     base64 decode and pass the content through Zlib inflating. I
     content is not Z-prefixed, will be returned as is.

4.15.54 z-encode
----------------

 -- Command-line option: `--z-encode'
     If specified, program will take stdin and z-encode it to stdout.
     This is for testing purpose (for network messages for instance).
     Z-encoding, here means passing the message through Zlib deflating
     then base64 encoding and prefix it with a Z.


File: liquidwar6.info,  Node: C to Guile,  Next: Script hooks,  Prev: Advanced settings,  Up: Reference

4.16 C to Guile
===============

4.16.1 c-gettext
----------------

 -- C function exported to Guile: `c-gettext'
     Calls GNU gettext to convert string in current locale. Note that
     '_' (plain underscode) is exported as well, so that code can be
     written using '_' as a function.

4.16.2 c-lw6-exit
-----------------

 -- C function exported to Guile: `c-lw6-exit'
     Wrapper on lw6_exit.

4.16.3 c-lw6-release
--------------------

 -- C function exported to Guile: `c-lw6-release'
     Wrapper on lw6_release.

4.16.4 c-lw6bot-get-backends
----------------------------

 -- C function exported to Guile: `c-lw6bot-get-backends'
     Wrapper on lw6bot_get_backends.

4.16.5 c-lw6bot-new
-------------------

 -- C function exported to Guile: `c-lw6bot-new'
     Wrapper on lw6bot_new.

4.16.6 c-lw6bot-next-move
-------------------------

 -- C function exported to Guile: `c-lw6bot-next-move'
     Wrapper on lw6bot_next_move.

4.16.7 c-lw6cfg-defaults
------------------------

 -- C function exported to Guile: `c-lw6cfg-defaults'
     Wrapper on lw6cfg_defaults.

4.16.8 c-lw6cfg-get-option
--------------------------

 -- C function exported to Guile: `c-lw6cfg-get-option'
     Wrapper on lw6cfg_get_option.

4.16.9 c-lw6cfg-init
--------------------

 -- C function exported to Guile: `c-lw6cfg-init'
     Wrapper on lw6cfg_init.

4.16.10 c-lw6cfg-load
---------------------

 -- C function exported to Guile: `c-lw6cfg-load'
     Wrapper on lw6cfg_load.

4.16.11 c-lw6cfg-option-exists
------------------------------

 -- C function exported to Guile: `c-lw6cfg-option-exists'
     Wrapper on lw6cfg_option_exists.

4.16.12 c-lw6cfg-quit
---------------------

 -- C function exported to Guile: `c-lw6cfg-quit'
     Wrapper on lw6cfg_quit.

4.16.13 c-lw6cfg-save
---------------------

 -- C function exported to Guile: `c-lw6cfg-save'
     Wrapper on lw6cfg_save.

4.16.14 c-lw6cfg-set-option
---------------------------

 -- C function exported to Guile: `c-lw6cfg-set-option'
     Wrapper on lw6cfg_set_option.

4.16.15 c-lw6cfg-unified-get-log-file
-------------------------------------

 -- C function exported to Guile: `c-lw6cfg-unified-get-log-file'
     Wrapper on lw6cfg_unified_get_log_file.

4.16.16 c-lw6cfg-unified-get-map-path
-------------------------------------

 -- C function exported to Guile: `c-lw6cfg-unified-get-map-path'
     Wrapper on lw6cfg_unified_get_map_path.

4.16.17 c-lw6cfg-unified-get-music-path
---------------------------------------

 -- C function exported to Guile: `c-lw6cfg-unified-get-music-path'
     Wrapper on lw6cfg_unified_get_music_path.

4.16.18 c-lw6cfg-unified-get-user-dir
-------------------------------------

 -- C function exported to Guile: `c-lw6cfg-unified-get-user-dir'
     Wrapper on lw6cfg_unified_get_user_dir.

4.16.19 c-lw6cli-get-backends
-----------------------------

 -- C function exported to Guile: `c-lw6cli-get-backends'
     Wrapper on lw6cli_get_backends.

4.16.20 c-lw6cns-init
---------------------

 -- C function exported to Guile: `c-lw6cns-init'
     Wrapper on lw6cns_init.

4.16.21 c-lw6cns-poll
---------------------

 -- C function exported to Guile: `c-lw6cns-poll'
     Wrapper on lw6cns_poll.

4.16.22 c-lw6cns-quit
---------------------

 -- C function exported to Guile: `c-lw6cns-quit'
     Wrapper on lw6cns_quit.

4.16.23 c-lw6cns-support
------------------------

 -- C function exported to Guile: `c-lw6cns-support'
     Wrapper on lw6cns_support.

4.16.24 c-lw6dsp-get-average-fps
--------------------------------

 -- C function exported to Guile: `c-lw6dsp-get-average-fps'
     Wrapper on lw6dsp_get_average_fps.

4.16.25 c-lw6dsp-get-fullscreen-modes
-------------------------------------

 -- C function exported to Guile: `c-lw6dsp-get-fullscreen-modes'
     Wrapper on lw6dsp_get_fullscreen_modes.

4.16.26 c-lw6dsp-get-instant-fps
--------------------------------

 -- C function exported to Guile: `c-lw6dsp-get-instant-fps'
     Wrapper on lw6dsp_get_instant_fps.

4.16.27 c-lw6dsp-get-last-frame-rendering-time
----------------------------------------------

 -- C function exported to Guile:
`c-lw6dsp-get-last-frame-rendering-time'
     Wrapper on lw6dsp_get_last_frame_rendering_time.

4.16.28 c-lw6dsp-get-nb-frames
------------------------------

 -- C function exported to Guile: `c-lw6dsp-get-nb-frames'
     Wrapper on lw6dsp_get_nb_frames.

4.16.29 c-lw6dsp-get-video-mode
-------------------------------

 -- C function exported to Guile: `c-lw6dsp-get-video-mode'
     Wrapper on lw6dsp_get_video_mode.

4.16.30 c-lw6dsp-new
--------------------

 -- C function exported to Guile: `c-lw6dsp-new'
     Wrapper on lw6dsp_new.

4.16.31 c-lw6dsp-release
------------------------

 -- C function exported to Guile: `c-lw6dsp-release'
     Wrapper on lw6dsp_release.

4.16.32 c-lw6dsp-update
-----------------------

 -- C function exported to Guile: `c-lw6dsp-update'
     Wrapper on lw6dsp_update.

4.16.33 c-lw6gfx-get-backends
-----------------------------

 -- C function exported to Guile: `c-lw6gfx-get-backends'
     Wrapper on lw6gfx_get_backends.

4.16.34 c-lw6gui-default-look
-----------------------------

 -- C function exported to Guile: `c-lw6gui-default-look'
     Wrapper on lw6gui_default_look.

4.16.35 c-lw6gui-input-reset
----------------------------

 -- C function exported to Guile: `c-lw6gui-input-reset'
     Wrapper on lw6gui_input_reset.

4.16.36 c-lw6gui-joystick1-get-move-pad
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-get-move-pad'
     Wrapper on lw6gui_joystick1_get_move_pad.

4.16.37 c-lw6gui-joystick1-pop-button-a
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-a'
     Wrapper on lw6gui_joystick1_pop_button_a.

4.16.38 c-lw6gui-joystick1-pop-button-b
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-b'
     Wrapper on lw6gui_joystick1_pop_button_b.

4.16.39 c-lw6gui-joystick1-pop-button-c
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-c'
     Wrapper on lw6gui_joystick1_pop_button_c.

4.16.40 c-lw6gui-joystick1-pop-button-d
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-d'
     Wrapper on lw6gui_joystick1_pop_button_d.

4.16.41 c-lw6gui-joystick1-pop-button-e
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-e'
     Wrapper on lw6gui_joystick1_pop_button_e.

4.16.42 c-lw6gui-joystick1-pop-button-f
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-button-f'
     Wrapper on lw6gui_joystick1_pop_button_f.

4.16.43 c-lw6gui-joystick1-pop-pad-down
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-pad-down'
     Wrapper on lw6gui_joystick1_pop_pad_down.

4.16.44 c-lw6gui-joystick1-pop-pad-left
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-pad-left'
     Wrapper on lw6gui_joystick1_pop_pad_left.

4.16.45 c-lw6gui-joystick1-pop-pad-right
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-pad-right'
     Wrapper on lw6gui_joystick1_pop_pad_right.

4.16.46 c-lw6gui-joystick1-pop-pad-up
-------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick1-pop-pad-up'
     Wrapper on lw6gui_joystick1_pop_pad_up.

4.16.47 c-lw6gui-joystick2-get-move-pad
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-get-move-pad'
     Wrapper on lw6gui_joystick2_get_move_pad.

4.16.48 c-lw6gui-joystick2-pop-button-a
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-a'
     Wrapper on lw6gui_joystick2_pop_button_a.

4.16.49 c-lw6gui-joystick2-pop-button-b
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-b'
     Wrapper on lw6gui_joystick2_pop_button_b.

4.16.50 c-lw6gui-joystick2-pop-button-c
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-c'
     Wrapper on lw6gui_joystick2_pop_button_c.

4.16.51 c-lw6gui-joystick2-pop-button-d
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-d'
     Wrapper on lw6gui_joystick2_pop_button_d.

4.16.52 c-lw6gui-joystick2-pop-button-e
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-e'
     Wrapper on lw6gui_joystick2_pop_button_e.

4.16.53 c-lw6gui-joystick2-pop-button-f
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-button-f'
     Wrapper on lw6gui_joystick2_pop_button_f.

4.16.54 c-lw6gui-joystick2-pop-pad-down
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-pad-down'
     Wrapper on lw6gui_joystick2_pop_pad_down.

4.16.55 c-lw6gui-joystick2-pop-pad-left
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-pad-left'
     Wrapper on lw6gui_joystick2_pop_pad_left.

4.16.56 c-lw6gui-joystick2-pop-pad-right
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-pad-right'
     Wrapper on lw6gui_joystick2_pop_pad_right.

4.16.57 c-lw6gui-joystick2-pop-pad-up
-------------------------------------

 -- C function exported to Guile: `c-lw6gui-joystick2-pop-pad-up'
     Wrapper on lw6gui_joystick2_pop_pad_up.

4.16.58 c-lw6gui-keyboard-get-move-pad
--------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-get-move-pad'
     Wrapper on lw6gui_keyboard_get_move_pad.

4.16.59 c-lw6gui-keyboard-is-pressed
------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-is-pressed'
     Wrapper on lw6gui_keyboard_is_pressed.

4.16.60 c-lw6gui-keyboard-pop-arrow-down
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-arrow-down'
     Wrapper on lw6gui_keyboard_pop_arrow_down.

4.16.61 c-lw6gui-keyboard-pop-arrow-left
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-arrow-left'
     Wrapper on lw6gui_keyboard_pop_arrow_left.

4.16.62 c-lw6gui-keyboard-pop-arrow-right
-----------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-arrow-right'
     Wrapper on lw6gui_keyboard_pop_arrow_right.

4.16.63 c-lw6gui-keyboard-pop-arrow-up
--------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-arrow-up'
     Wrapper on lw6gui_keyboard_pop_arrow_up.

4.16.64 c-lw6gui-keyboard-pop-key-alt
-------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-alt'
     Wrapper on lw6gui_keyboard_pop_key_alt.

4.16.65 c-lw6gui-keyboard-pop-key-ctrl
--------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-ctrl'
     Wrapper on lw6gui_keyboard_pop_key_ctrl.

4.16.66 c-lw6gui-keyboard-pop-key-enter
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-enter'
     Wrapper on lw6gui_keyboard_pop_key_enter.

4.16.67 c-lw6gui-keyboard-pop-key-esc
-------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-esc'
     Wrapper on lw6gui_keyboard_pop_key_esc.

4.16.68 c-lw6gui-keyboard-pop-key-pgdown
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-pgdown'
     Wrapper on lw6gui_keyboard_pop_key_pgdown.

4.16.69 c-lw6gui-keyboard-pop-key-pgup
--------------------------------------

 -- C function exported to Guile: `c-lw6gui-keyboard-pop-key-pgup'
     Wrapper on lw6gui_keyboard_pop_key_pgup.

4.16.70 c-lw6gui-look-get
-------------------------

 -- C function exported to Guile: `c-lw6gui-look-get'
     Wrapper on lw6gui_look_get.

4.16.71 c-lw6gui-look-set
-------------------------

 -- C function exported to Guile: `c-lw6gui-look-set'
     Wrapper on lw6gui_look_set.

4.16.72 c-lw6gui-look-zoom-in
-----------------------------

 -- C function exported to Guile: `c-lw6gui-look-zoom-in'
     Wrapper on lw6gui_look_zoom_in.

4.16.73 c-lw6gui-look-zoom-out
------------------------------

 -- C function exported to Guile: `c-lw6gui-look-zoom-out'
     Wrapper on lw6gui_look_zoom_out.

4.16.74 c-lw6gui-menu-append
----------------------------

 -- C function exported to Guile: `c-lw6gui-menu-append'
     Wrapper on lw6gui_menu_append.

4.16.75 c-lw6gui-menu-enable-esc
--------------------------------

 -- C function exported to Guile: `c-lw6gui-menu-enable-esc'
     Wrapper on lw6gui_menu_enable_esc.

4.16.76 c-lw6gui-menu-new
-------------------------

 -- C function exported to Guile: `c-lw6gui-menu-new'
     Wrapper on lw6gui_menu_new.

4.16.77 c-lw6gui-menu-scroll-down
---------------------------------

 -- C function exported to Guile: `c-lw6gui-menu-scroll-down'
     Wrapper on lw6gui_menu_scroll_down.

4.16.78 c-lw6gui-menu-scroll-up
-------------------------------

 -- C function exported to Guile: `c-lw6gui-menu-scroll-up'
     Wrapper on lw6gui_menu_scroll_up.

4.16.79 c-lw6gui-menu-select
----------------------------

 -- C function exported to Guile: `c-lw6gui-menu-select'
     Wrapper on lw6gui_menu_select.

4.16.80 c-lw6gui-menu-select-esc
--------------------------------

 -- C function exported to Guile: `c-lw6gui-menu-select-esc'
     Wrapper on lw6gui_menu_select_esc.

4.16.81 c-lw6gui-menu-sync
--------------------------

 -- C function exported to Guile: `c-lw6gui-menu-sync'
     Wrapper on lw6gui_menu_sync.

4.16.82 c-lw6gui-mouse-get-state
--------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-get-state'
     Wrapper on lw6gui_mouse_get_state.

4.16.83 c-lw6gui-mouse-poll-move
--------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-poll-move'
     Wrapper on lw6gui_mouse_poll_move.

4.16.84 c-lw6gui-mouse-pop-button-left
--------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-button-left'
     Wrapper on lw6gui_mouse_pop_button_left.

4.16.85 c-lw6gui-mouse-pop-button-middle
----------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-button-middle'
     Wrapper on lw6gui_mouse_pop_button_middle.

4.16.86 c-lw6gui-mouse-pop-button-right
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-button-right'
     Wrapper on lw6gui_mouse_pop_button_right.

4.16.87 c-lw6gui-mouse-pop-double-click
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-double-click'
     Wrapper on lw6gui_mouse_pop_double_click.

4.16.88 c-lw6gui-mouse-pop-simple-click
---------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-simple-click'
     Wrapper on lw6gui_mouse_pop_simple_click.

4.16.89 c-lw6gui-mouse-pop-wheel-down
-------------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-wheel-down'
     Wrapper on lw6gui_mouse_pop_wheel_down.

4.16.90 c-lw6gui-mouse-pop-wheel-up
-----------------------------------

 -- C function exported to Guile: `c-lw6gui-mouse-pop-wheel-up'
     Wrapper on lw6gui_mouse_pop_wheel_up.

4.16.91 c-lw6hlp-get-default-value
----------------------------------

 -- C function exported to Guile: `c-lw6hlp-get-default-value'
     Wrapper on lw6hlp_get_default_value.

4.16.92 c-lw6hlp-list
---------------------

 -- C function exported to Guile: `c-lw6hlp-list'
     Wrapper on lw6hlp_list.

4.16.93 c-lw6hlp-list-advanced
------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-advanced'
     Wrapper on lw6hlp_list_advanced.

4.16.94 c-lw6hlp-list-aliases
-----------------------------

 -- C function exported to Guile: `c-lw6hlp-list-aliases'
     Wrapper on lw6hlp_list_aliases.

4.16.95 c-lw6hlp-list-doc
-------------------------

 -- C function exported to Guile: `c-lw6hlp-list-doc'
     Wrapper on lw6hlp_list_doc.

4.16.96 c-lw6hlp-list-funcs
---------------------------

 -- C function exported to Guile: `c-lw6hlp-list-funcs'
     Wrapper on lw6hlp_list_funcs.

4.16.97 c-lw6hlp-list-graphics
------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-graphics'
     Wrapper on lw6hlp_list_graphics.

4.16.98 c-lw6hlp-list-hooks
---------------------------

 -- C function exported to Guile: `c-lw6hlp-list-hooks'
     Wrapper on lw6hlp_list_hooks.

4.16.99 c-lw6hlp-list-input
---------------------------

 -- C function exported to Guile: `c-lw6hlp-list-input'
     Wrapper on lw6hlp_list_input.

4.16.100 c-lw6hlp-list-map
--------------------------

 -- C function exported to Guile: `c-lw6hlp-list-map'
     Wrapper on lw6hlp_list_map.

4.16.101 c-lw6hlp-list-map-hints
--------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-map-hints'
     Wrapper on lw6hlp_list_map_hints.

4.16.102 c-lw6hlp-list-map-rules
--------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-map-rules'
     Wrapper on lw6hlp_list_map_rules.

4.16.103 c-lw6hlp-list-map-style
--------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-map-style'
     Wrapper on lw6hlp_list_map_style.

4.16.104 c-lw6hlp-list-map-teams
--------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-map-teams'
     Wrapper on lw6hlp_list_map_teams.

4.16.105 c-lw6hlp-list-network
------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-network'
     Wrapper on lw6hlp_list_network.

4.16.106 c-lw6hlp-list-path
---------------------------

 -- C function exported to Guile: `c-lw6hlp-list-path'
     Wrapper on lw6hlp_list_path.

4.16.107 c-lw6hlp-list-players
------------------------------

 -- C function exported to Guile: `c-lw6hlp-list-players'
     Wrapper on lw6hlp_list_players.

4.16.108 c-lw6hlp-list-quick
----------------------------

 -- C function exported to Guile: `c-lw6hlp-list-quick'
     Wrapper on lw6hlp_list_quick.

4.16.109 c-lw6hlp-list-show
---------------------------

 -- C function exported to Guile: `c-lw6hlp-list-show'
     Wrapper on lw6hlp_list_show.

4.16.110 c-lw6hlp-list-sound
----------------------------

 -- C function exported to Guile: `c-lw6hlp-list-sound'
     Wrapper on lw6hlp_list_sound.

4.16.111 c-lw6ker-add-cursor
----------------------------

 -- C function exported to Guile: `c-lw6ker-add-cursor'
     Wrapper on lw6ker_add_cursor.

4.16.112 c-lw6ker-build-game-state
----------------------------------

 -- C function exported to Guile: `c-lw6ker-build-game-state'
     Wrapper on lw6ker_build_game_state.

4.16.113 c-lw6ker-build-game-struct
-----------------------------------

 -- C function exported to Guile: `c-lw6ker-build-game-struct'
     Wrapper on lw6ker_build_game_struct.

4.16.114 c-lw6ker-cursor-exists
-------------------------------

 -- C function exported to Guile: `c-lw6ker-cursor-exists'
     Wrapper on lw6ker_cursor_exists.

4.16.115 c-lw6ker-did-cursor-win
--------------------------------

 -- C function exported to Guile: `c-lw6ker-did-cursor-win'
     Wrapper on lw6ker_did_cursor_win.

4.16.116 c-lw6ker-do-round
--------------------------

 -- C function exported to Guile: `c-lw6ker-do-round'
     Wrapper on lw6ker_do_round.

4.16.117 c-lw6ker-dup-game-state
--------------------------------

 -- C function exported to Guile: `c-lw6ker-dup-game-state'
     Wrapper on lw6ker_dup_game_state.

4.16.118 c-lw6ker-game-state-checksum
-------------------------------------

 -- C function exported to Guile: `c-lw6ker-game-state-checksum'
     Wrapper on lw6ker_game_state_checksum.

4.16.119 c-lw6ker-game-struct-checksum
--------------------------------------

 -- C function exported to Guile: `c-lw6ker-game-struct-checksum'
     Wrapper on lw6ker_game_struct_checksum.

4.16.120 c-lw6ker-get-cursor
----------------------------

 -- C function exported to Guile: `c-lw6ker-get-cursor'
     Wrapper on lw6ker_get_cursor.

4.16.121 c-lw6ker-get-moves
---------------------------

 -- C function exported to Guile: `c-lw6ker-get-moves'
     Wrapper on lw6ker_get_moves.

4.16.122 c-lw6ker-get-rounds
----------------------------

 -- C function exported to Guile: `c-lw6ker-get-rounds'
     Wrapper on lw6ker_get_rounds.

4.16.123 c-lw6ker-get-spreads
-----------------------------

 -- C function exported to Guile: `c-lw6ker-get-spreads'
     Wrapper on lw6ker_get_spreads.

4.16.124 c-lw6ker-is-over
-------------------------

 -- C function exported to Guile: `c-lw6ker-is-over'
     Wrapper on lw6ker_is_over.

4.16.125 c-lw6ker-node-exists
-----------------------------

 -- C function exported to Guile: `c-lw6ker-node-exists'
     Wrapper on lw6ker_node_exists.

4.16.126 c-lw6ker-register-node
-------------------------------

 -- C function exported to Guile: `c-lw6ker-register-node'
     Wrapper on lw6ker_register_node.

4.16.127 c-lw6ker-remove-cursor
-------------------------------

 -- C function exported to Guile: `c-lw6ker-remove-cursor'
     Wrapper on lw6ker_remove_cursor.

4.16.128 c-lw6ker-set-cursor
----------------------------

 -- C function exported to Guile: `c-lw6ker-set-cursor'
     Wrapper on lw6ker_set_cursor.

4.16.129 c-lw6ker-sync-game-state
---------------------------------

 -- C function exported to Guile: `c-lw6ker-sync-game-state'
     Wrapper on lw6ker_sync_game_state.

4.16.130 c-lw6ker-unregister-node
---------------------------------

 -- C function exported to Guile: `c-lw6ker-unregister-node'
     Wrapper on lw6ker_unregister_node.

4.16.131 c-lw6ldr-exp-validate
------------------------------

 -- C function exported to Guile: `c-lw6ldr-exp-validate'
     Wrapper on lw6ldr_exp_validate.

4.16.132 c-lw6ldr-get-entries
-----------------------------

 -- C function exported to Guile: `c-lw6ldr-get-entries'
     Wrapper on lw6ldr_get_entries.

4.16.133 c-lw6ldr-hints-get-default
-----------------------------------

 -- C function exported to Guile: `c-lw6ldr-hints-get-default'
     Wrapper on lw6ldr_hints_get_default.

4.16.134 c-lw6ldr-print-examples
--------------------------------

 -- C function exported to Guile: `c-lw6ldr-print-examples'
     Wrapper on lw6ldr_print_examples.

4.16.135 c-lw6ldr-read
----------------------

 -- C function exported to Guile: `c-lw6ldr-read'
     Wrapper on lw6ldr_read.

4.16.136 c-lw6ldr-read-relative
-------------------------------

 -- C function exported to Guile: `c-lw6ldr-read-relative'
     Wrapper on lw6ldr_read_relative.

4.16.137 c-lw6map-get-look
--------------------------

 -- C function exported to Guile: `c-lw6map-get-look'
     Wrapper on lw6map_get_look.

4.16.138 c-lw6map-get-music-dir
-------------------------------

 -- C function exported to Guile: `c-lw6map-get-music-dir'
     Wrapper on lw6map_get_music_dir.

4.16.139 c-lw6map-param-get
---------------------------

 -- C function exported to Guile: `c-lw6map-param-get'
     Wrapper on lw6map_param_get.

4.16.140 c-lw6map-rules-get-default
-----------------------------------

 -- C function exported to Guile: `c-lw6map-rules-get-default'
     Wrapper on lw6map_rules_get_default.

4.16.141 c-lw6map-rules-get-int
-------------------------------

 -- C function exported to Guile: `c-lw6map-rules-get-int'
     Wrapper on lw6map_rules_get_int.

4.16.142 c-lw6map-rules-get-max
-------------------------------

 -- C function exported to Guile: `c-lw6map-rules-get-max'
     Wrapper on lw6map_rules_get_max.

4.16.143 c-lw6map-rules-get-min
-------------------------------

 -- C function exported to Guile: `c-lw6map-rules-get-min'
     Wrapper on lw6map_rules_get_min.

4.16.144 c-lw6map-style-get-default
-----------------------------------

 -- C function exported to Guile: `c-lw6map-style-get-default'
     Wrapper on lw6map_style_get_default.

4.16.145 c-lw6map-team-color-index-to-key
-----------------------------------------

 -- C function exported to Guile: `c-lw6map-team-color-index-to-key'
     Wrapper on lw6map_team_color_index_to_key.

4.16.146 c-lw6map-team-color-key-to-index
-----------------------------------------

 -- C function exported to Guile: `c-lw6map-team-color-key-to-index'
     Wrapper on lw6map_team_color_key_to_index.

4.16.147 c-lw6map-team-color-list
---------------------------------

 -- C function exported to Guile: `c-lw6map-team-color-list'
     Wrapper on lw6map_team_color_list.

4.16.148 c-lw6map-teams-get-default
-----------------------------------

 -- C function exported to Guile: `c-lw6map-teams-get-default'
     Wrapper on lw6map_teams_get_default.

4.16.149 c-lw6map-weapon-index-to-key
-------------------------------------

 -- C function exported to Guile: `c-lw6map-weapon-index-to-key'
     Wrapper on lw6map_weapon_index_to_key.

4.16.150 c-lw6map-weapon-key-to-index
-------------------------------------

 -- C function exported to Guile: `c-lw6map-weapon-key-to-index'
     Wrapper on lw6map_weapon_key_to_index.

4.16.151 c-lw6map-weapon-list
-----------------------------

 -- C function exported to Guile: `c-lw6map-weapon-list'
     Wrapper on lw6map_weapon_list.

4.16.152 c-lw6net-init
----------------------

 -- C function exported to Guile: `c-lw6net-init'
     Wrapper on lw6net_init.

4.16.153 c-lw6net-quit
----------------------

 -- C function exported to Guile: `c-lw6net-quit'
     Wrapper on lw6net_quit.

4.16.154 c-lw6p2p-db-default-name
---------------------------------

 -- C function exported to Guile: `c-lw6p2p-db-default-name'
     Wrapper on lw6p2p_db_default_name.

4.16.155 c-lw6p2p-db-new
------------------------

 -- C function exported to Guile: `c-lw6p2p-db-new'
     Wrapper on lw6p2p_db_new.

4.16.156 c-lw6p2p-db-reset
--------------------------

 -- C function exported to Guile: `c-lw6p2p-db-reset'
     Wrapper on lw6p2p_db_reset.

4.16.157 c-lw6p2p-node-close
----------------------------

 -- C function exported to Guile: `c-lw6p2p-node-close'
     Wrapper on lw6p2p_node_close.

4.16.158 c-lw6p2p-node-get-id
-----------------------------

 -- C function exported to Guile: `c-lw6p2p-node-get-id'
     Wrapper on lw6p2p_node_get_id.

4.16.159 c-lw6p2p-node-new
--------------------------

 -- C function exported to Guile: `c-lw6p2p-node-new'
     Wrapper on lw6p2p_node_new.

4.16.160 c-lw6p2p-node-poll
---------------------------

 -- C function exported to Guile: `c-lw6p2p-node-poll'
     Wrapper on lw6p2p_node_poll.

4.16.161 c-lw6pil-bench
-----------------------

 -- C function exported to Guile: `c-lw6pil-bench'
     Wrapper on lw6pil_bench.

4.16.162 c-lw6pil-build-pilot
-----------------------------

 -- C function exported to Guile: `c-lw6pil-build-pilot'
     Wrapper on lw6pil_build_pilot.

4.16.163 c-lw6pil-calibrate
---------------------------

 -- C function exported to Guile: `c-lw6pil-calibrate'
     Wrapper on lw6pil_calibrate.

4.16.164 c-lw6pil-commit
------------------------

 -- C function exported to Guile: `c-lw6pil-commit'
     Wrapper on lw6pil_commit.

4.16.165 c-lw6pil-did-cursor-win
--------------------------------

 -- C function exported to Guile: `c-lw6pil-did-cursor-win'
     Wrapper on lw6pil_did_cursor_win.

4.16.166 c-lw6pil-execute-command
---------------------------------

 -- C function exported to Guile: `c-lw6pil-execute-command'
     Wrapper on lw6pil_execute_command.

4.16.167 c-lw6pil-fix-coords
----------------------------

 -- C function exported to Guile: `c-lw6pil-fix-coords'
     Wrapper on lw6pil_fix_coords.

4.16.168 c-lw6pil-get-last-commit-round
---------------------------------------

 -- C function exported to Guile: `c-lw6pil-get-last-commit-round'
     Wrapper on lw6pil_get_last_commit_round.

4.16.169 c-lw6pil-get-max-round
-------------------------------

 -- C function exported to Guile: `c-lw6pil-get-max-round'
     Wrapper on lw6pil_get_max_round.

4.16.170 c-lw6pil-get-next-round
--------------------------------

 -- C function exported to Guile: `c-lw6pil-get-next-round'
     Wrapper on lw6pil_get_next_round.

4.16.171 c-lw6pil-get-reference-current-round
---------------------------------------------

 -- C function exported to Guile: `c-lw6pil-get-reference-current-round'
     Wrapper on lw6pil_get_reference_current_round.

4.16.172 c-lw6pil-get-reference-target-round
--------------------------------------------

 -- C function exported to Guile: `c-lw6pil-get-reference-target-round'
     Wrapper on lw6pil_get_reference_target_round.

4.16.173 c-lw6pil-is-over
-------------------------

 -- C function exported to Guile: `c-lw6pil-is-over'
     Wrapper on lw6pil_is_over.

4.16.174 c-lw6pil-local-command
-------------------------------

 -- C function exported to Guile: `c-lw6pil-local-command'
     Wrapper on lw6pil_local_command.

4.16.175 c-lw6pil-local-cursors-set-main
----------------------------------------

 -- C function exported to Guile: `c-lw6pil-local-cursors-set-main'
     Wrapper on lw6pil_local_cursors_set_main.

4.16.176 c-lw6pil-local-cursors-set-mouse-controlled
----------------------------------------------------

 -- C function exported to Guile:
`c-lw6pil-local-cursors-set-mouse-controlled'
     Wrapper on lw6pil_local_cursors_set_mouse_controlled.

4.16.177 c-lw6pil-make-backup
-----------------------------

 -- C function exported to Guile: `c-lw6pil-make-backup'
     Wrapper on lw6pil_make_backup.

4.16.178 c-lw6pil-send-command
------------------------------

 -- C function exported to Guile: `c-lw6pil-send-command'
     Wrapper on lw6pil_send_command.

4.16.179 c-lw6pil-slow-down
---------------------------

 -- C function exported to Guile: `c-lw6pil-slow-down'
     Wrapper on lw6pil_slow_down.

4.16.180 c-lw6pil-speed-up
--------------------------

 -- C function exported to Guile: `c-lw6pil-speed-up'
     Wrapper on lw6pil_speed_up.

4.16.181 c-lw6pil-sync-from-backup
----------------------------------

 -- C function exported to Guile: `c-lw6pil-sync-from-backup'
     Wrapper on lw6pil_sync_from_backup.

4.16.182 c-lw6pil-sync-from-draft
---------------------------------

 -- C function exported to Guile: `c-lw6pil-sync-from-draft'
     Wrapper on lw6pil_sync_from_draft.

4.16.183 c-lw6pil-sync-from-reference
-------------------------------------

 -- C function exported to Guile: `c-lw6pil-sync-from-reference'
     Wrapper on lw6pil_sync_from_reference.

4.16.184 c-lw6snd-get-backends
------------------------------

 -- C function exported to Guile: `c-lw6snd-get-backends'
     Wrapper on lw6snd_get_backends.

4.16.185 c-lw6snd-is-music-file
-------------------------------

 -- C function exported to Guile: `c-lw6snd-is-music-file'
     Wrapper on lw6snd_is_music_file.

4.16.186 c-lw6snd-new
---------------------

 -- C function exported to Guile: `c-lw6snd-new'
     Wrapper on lw6snd_new.

4.16.187 c-lw6snd-play-fx
-------------------------

 -- C function exported to Guile: `c-lw6snd-play-fx'
     Wrapper on lw6snd_play_fx.

4.16.188 c-lw6snd-play-music-file
---------------------------------

 -- C function exported to Guile: `c-lw6snd-play-music-file'
     Wrapper on lw6snd_play_music_file.

4.16.189 c-lw6snd-play-music-random
-----------------------------------

 -- C function exported to Guile: `c-lw6snd-play-music-random'
     Wrapper on lw6snd_play_music_random.

4.16.190 c-lw6snd-poll
----------------------

 -- C function exported to Guile: `c-lw6snd-poll'
     Wrapper on lw6snd_poll.

4.16.191 c-lw6snd-release
-------------------------

 -- C function exported to Guile: `c-lw6snd-release'
     Wrapper on lw6snd_release.

4.16.192 c-lw6snd-set-fx-volume
-------------------------------

 -- C function exported to Guile: `c-lw6snd-set-fx-volume'
     Wrapper on lw6snd_set_fx_volume.

4.16.193 c-lw6snd-set-music-volume
----------------------------------

 -- C function exported to Guile: `c-lw6snd-set-music-volume'
     Wrapper on lw6snd_set_music_volume.

4.16.194 c-lw6snd-set-water-volume
----------------------------------

 -- C function exported to Guile: `c-lw6snd-set-water-volume'
     Wrapper on lw6snd_set_water_volume.

4.16.195 c-lw6snd-stop-music
----------------------------

 -- C function exported to Guile: `c-lw6snd-stop-music'
     Wrapper on lw6snd_stop_music.

4.16.196 c-lw6srv-get-backends
------------------------------

 -- C function exported to Guile: `c-lw6srv-get-backends'
     Wrapper on lw6srv_get_backends.

4.16.197 c-lw6sys-build-get-bin-id
----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-bin-id'
     Wrapper on lw6sys_build_get_bin_id.

4.16.198 c-lw6sys-build-get-cflags
----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-cflags'
     Wrapper on lw6sys_build_get_cflags.

4.16.199 c-lw6sys-build-get-codename
------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-codename'
     Wrapper on lw6sys_build_get_codename.

4.16.200 c-lw6sys-build-get-configure-args
------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-configure-args'
     Wrapper on lw6sys_build_get_configure_args.

4.16.201 c-lw6sys-build-get-copyright
-------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-copyright'
     Wrapper on lw6sys_build_get_copyright.

4.16.202 c-lw6sys-build-get-datadir
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-datadir'
     Wrapper on lw6sys_build_get_datadir.

4.16.203 c-lw6sys-build-get-date
--------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-date'
     Wrapper on lw6sys_build_get_date.

4.16.204 c-lw6sys-build-get-enable-allinone
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-allinone'
     Wrapper on lw6sys_build_get_enable_allinone.

4.16.205 c-lw6sys-build-get-enable-console
------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-console'
     Wrapper on lw6sys_build_get_enable_console.

4.16.206 c-lw6sys-build-get-enable-fullstatic
---------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-fullstatic'
     Wrapper on lw6sys_build_get_enable_fullstatic.

4.16.207 c-lw6sys-build-get-enable-gcov
---------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-gcov'
     Wrapper on lw6sys_build_get_enable_gcov.

4.16.208 c-lw6sys-build-get-enable-gprof
----------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-gprof'
     Wrapper on lw6sys_build_get_enable_gprof.

4.16.209 c-lw6sys-build-get-enable-gtk
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-gtk'
     Wrapper on lw6sys_build_get_enable_gtk.

4.16.210 c-lw6sys-build-get-enable-instrument
---------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-instrument'
     Wrapper on lw6sys_build_get_enable_instrument.

4.16.211 c-lw6sys-build-get-enable-mod-csound
---------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-mod-csound'
     Wrapper on lw6sys_build_get_enable_mod_csound.

4.16.212 c-lw6sys-build-get-enable-mod-gl
-----------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-mod-gl'
     Wrapper on lw6sys_build_get_enable_mod_gl.

4.16.213 c-lw6sys-build-get-enable-mod-http
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-mod-http'
     Wrapper on lw6sys_build_get_enable_mod_http.

4.16.214 c-lw6sys-build-get-enable-mod-ogg
------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-mod-ogg'
     Wrapper on lw6sys_build_get_enable_mod_ogg.

4.16.215 c-lw6sys-build-get-enable-openmp
-----------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-openmp'
     Wrapper on lw6sys_build_get_enable_openmp.

4.16.216 c-lw6sys-build-get-enable-optimize
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-optimize'
     Wrapper on lw6sys_build_get_enable_optimize.

4.16.217 c-lw6sys-build-get-enable-paranoid
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-paranoid'
     Wrapper on lw6sys_build_get_enable_paranoid.

4.16.218 c-lw6sys-build-get-enable-profiler
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-profiler'
     Wrapper on lw6sys_build_get_enable_profiler.

4.16.219 c-lw6sys-build-get-enable-valgrind
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-enable-valgrind'
     Wrapper on lw6sys_build_get_enable_valgrind.

4.16.220 c-lw6sys-build-get-endianness
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-endianness'
     Wrapper on lw6sys_build_get_endianness.

4.16.221 c-lw6sys-build-get-gcc-version
---------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-gcc-version'
     Wrapper on lw6sys_build_get_gcc_version.

4.16.222 c-lw6sys-build-get-host-cpu
------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-host-cpu'
     Wrapper on lw6sys_build_get_host_cpu.

4.16.223 c-lw6sys-build-get-host-os
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-host-os'
     Wrapper on lw6sys_build_get_host_os.

4.16.224 c-lw6sys-build-get-hostname
------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-hostname'
     Wrapper on lw6sys_build_get_hostname.

4.16.225 c-lw6sys-build-get-includedir
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-includedir'
     Wrapper on lw6sys_build_get_includedir.

4.16.226 c-lw6sys-build-get-ldflags
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-ldflags'
     Wrapper on lw6sys_build_get_ldflags.

4.16.227 c-lw6sys-build-get-libdir
----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-libdir'
     Wrapper on lw6sys_build_get_libdir.

4.16.228 c-lw6sys-build-get-license
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-license'
     Wrapper on lw6sys_build_get_license.

4.16.229 c-lw6sys-build-get-localedir
-------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-localedir'
     Wrapper on lw6sys_build_get_localedir.

4.16.230 c-lw6sys-build-get-md5sum
----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-md5sum'
     Wrapper on lw6sys_build_get_md5sum.

4.16.231 c-lw6sys-build-get-package-name
----------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-package-name'
     Wrapper on lw6sys_build_get_package_name.

4.16.232 c-lw6sys-build-get-package-string
------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-package-string'
     Wrapper on lw6sys_build_get_package_string.

4.16.233 c-lw6sys-build-get-package-tarname
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-package-tarname'
     Wrapper on lw6sys_build_get_package_tarname.

4.16.234 c-lw6sys-build-get-pointer-size
----------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-pointer-size'
     Wrapper on lw6sys_build_get_pointer_size.

4.16.235 c-lw6sys-build-get-prefix
----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-prefix'
     Wrapper on lw6sys_build_get_prefix.

4.16.236 c-lw6sys-build-get-stamp
---------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-stamp'
     Wrapper on lw6sys_build_get_stamp.

4.16.237 c-lw6sys-build-get-time
--------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-time'
     Wrapper on lw6sys_build_get_time.

4.16.238 c-lw6sys-build-get-top-srcdir
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-top-srcdir'
     Wrapper on lw6sys_build_get_top_srcdir.

4.16.239 c-lw6sys-build-get-url
-------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-url'
     Wrapper on lw6sys_build_get_url.

4.16.240 c-lw6sys-build-get-version
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-get-version'
     Wrapper on lw6sys_build_get_version.

4.16.241 c-lw6sys-build-is-gp2x
-------------------------------

 -- C function exported to Guile: `c-lw6sys-build-is-gp2x'
     Wrapper on lw6sys_build_is_gp2x.

4.16.242 c-lw6sys-build-is-mac-os-x
-----------------------------------

 -- C function exported to Guile: `c-lw6sys-build-is-mac-os-x'
     Wrapper on lw6sys_build_is_mac_os_x.

4.16.243 c-lw6sys-build-is-ms-windows
-------------------------------------

 -- C function exported to Guile: `c-lw6sys-build-is-ms-windows'
     Wrapper on lw6sys_build_is_ms_windows.

4.16.244 c-lw6sys-build-is-x86
------------------------------

 -- C function exported to Guile: `c-lw6sys-build-is-x86'
     Wrapper on lw6sys_build_is_x86.

4.16.245 c-lw6sys-debug-get
---------------------------

 -- C function exported to Guile: `c-lw6sys-debug-get'
     Wrapper on lw6sys_debug_get.

4.16.246 c-lw6sys-debug-set
---------------------------

 -- C function exported to Guile: `c-lw6sys-debug-set'
     Wrapper on lw6sys_debug_set.

4.16.247 c-lw6sys-delay
-----------------------

 -- C function exported to Guile: `c-lw6sys-delay'
     Wrapper on lw6sys_delay.

4.16.248 c-lw6sys-dump
----------------------

 -- C function exported to Guile: `c-lw6sys-dump'
     Wrapper on lw6sys_dump.

4.16.249 c-lw6sys-dump-clear
----------------------------

 -- C function exported to Guile: `c-lw6sys-dump-clear'
     Wrapper on lw6sys_dump_clear.

4.16.250 c-lw6sys-generate-id-16
--------------------------------

 -- C function exported to Guile: `c-lw6sys-generate-id-16'
     Wrapper on lw6sys_generate_id_16.

4.16.251 c-lw6sys-generate-id-32
--------------------------------

 -- C function exported to Guile: `c-lw6sys-generate-id-32'
     Wrapper on lw6sys_generate_id_32.

4.16.252 c-lw6sys-generate-id-64
--------------------------------

 -- C function exported to Guile: `c-lw6sys-generate-id-64'
     Wrapper on lw6sys_generate_id_64.

4.16.253 c-lw6sys-get-config-file
---------------------------------

 -- C function exported to Guile: `c-lw6sys-get-config-file'
     Wrapper on lw6sys_get_config_file.

4.16.254 c-lw6sys-get-cwd
-------------------------

 -- C function exported to Guile: `c-lw6sys-get-cwd'
     Wrapper on lw6sys_get_cwd.

4.16.255 c-lw6sys-get-cycle
---------------------------

 -- C function exported to Guile: `c-lw6sys-get-cycle'
     Wrapper on lw6sys_get_cycle.

4.16.256 c-lw6sys-get-data-dir
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-data-dir'
     Wrapper on lw6sys_get_data_dir.

4.16.257 c-lw6sys-get-default-config-file
-----------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-config-file'
     Wrapper on lw6sys_get_default_config_file.

4.16.258 c-lw6sys-get-default-data-dir
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-data-dir'
     Wrapper on lw6sys_get_default_data_dir.

4.16.259 c-lw6sys-get-default-log-file
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-log-file'
     Wrapper on lw6sys_get_default_log_file.

4.16.260 c-lw6sys-get-default-map-dir
-------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-map-dir'
     Wrapper on lw6sys_get_default_map_dir.

4.16.261 c-lw6sys-get-default-map-path
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-map-path'
     Wrapper on lw6sys_get_default_map_path.

4.16.262 c-lw6sys-get-default-mod-dir
-------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-mod-dir'
     Wrapper on lw6sys_get_default_mod_dir.

4.16.263 c-lw6sys-get-default-music-dir
---------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-music-dir'
     Wrapper on lw6sys_get_default_music_dir.

4.16.264 c-lw6sys-get-default-music-path
----------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-music-path'
     Wrapper on lw6sys_get_default_music_path.

4.16.265 c-lw6sys-get-default-prefix
------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-prefix'
     Wrapper on lw6sys_get_default_prefix.

4.16.266 c-lw6sys-get-default-script-file
-----------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-script-file'
     Wrapper on lw6sys_get_default_script_file.

4.16.267 c-lw6sys-get-default-user-dir
--------------------------------------

 -- C function exported to Guile: `c-lw6sys-get-default-user-dir'
     Wrapper on lw6sys_get_default_user_dir.

4.16.268 c-lw6sys-get-hostname
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-hostname'
     Wrapper on lw6sys_get_hostname.

4.16.269 c-lw6sys-get-log-file
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-log-file'
     Wrapper on lw6sys_get_log_file.

4.16.270 c-lw6sys-get-map-dir
-----------------------------

 -- C function exported to Guile: `c-lw6sys-get-map-dir'
     Wrapper on lw6sys_get_map_dir.

4.16.271 c-lw6sys-get-map-path
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-map-path'
     Wrapper on lw6sys_get_map_path.

4.16.272 c-lw6sys-get-mod-dir
-----------------------------

 -- C function exported to Guile: `c-lw6sys-get-mod-dir'
     Wrapper on lw6sys_get_mod_dir.

4.16.273 c-lw6sys-get-music-dir
-------------------------------

 -- C function exported to Guile: `c-lw6sys-get-music-dir'
     Wrapper on lw6sys_get_music_dir.

4.16.274 c-lw6sys-get-music-path
--------------------------------

 -- C function exported to Guile: `c-lw6sys-get-music-path'
     Wrapper on lw6sys_get_music_path.

4.16.275 c-lw6sys-get-prefix
----------------------------

 -- C function exported to Guile: `c-lw6sys-get-prefix'
     Wrapper on lw6sys_get_prefix.

4.16.276 c-lw6sys-get-run-dir
-----------------------------

 -- C function exported to Guile: `c-lw6sys-get-run-dir'
     Wrapper on lw6sys_get_run_dir.

4.16.277 c-lw6sys-get-script-file
---------------------------------

 -- C function exported to Guile: `c-lw6sys-get-script-file'
     Wrapper on lw6sys_get_script_file.

4.16.278 c-lw6sys-get-timestamp
-------------------------------

 -- C function exported to Guile: `c-lw6sys-get-timestamp'
     Wrapper on lw6sys_get_timestamp.

4.16.279 c-lw6sys-get-uptime
----------------------------

 -- C function exported to Guile: `c-lw6sys-get-uptime'
     Wrapper on lw6sys_get_uptime.

4.16.280 c-lw6sys-get-user-dir
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-user-dir'
     Wrapper on lw6sys_get_user_dir.

4.16.281 c-lw6sys-get-username
------------------------------

 -- C function exported to Guile: `c-lw6sys-get-username'
     Wrapper on lw6sys_get_username.

4.16.282 c-lw6sys-getenv
------------------------

 -- C function exported to Guile: `c-lw6sys-getenv'
     Wrapper on lw6sys_getenv.

4.16.283 c-lw6sys-getenv-prefixed
---------------------------------

 -- C function exported to Guile: `c-lw6sys-getenv-prefixed'
     Wrapper on lw6sys_getenv_prefixed.

4.16.284 c-lw6sys-idle
----------------------

 -- C function exported to Guile: `c-lw6sys-idle'
     Wrapper on lw6sys_idle.

4.16.285 c-lw6sys-log
---------------------

 -- C function exported to Guile: `c-lw6sys-log'
     Wrapper on lw6sys_log.

4.16.286 c-lw6sys-log-get-level
-------------------------------

 -- C function exported to Guile: `c-lw6sys-log-get-level'
     Wrapper on lw6sys_log_get_level.

4.16.287 c-lw6sys-log-set-level
-------------------------------

 -- C function exported to Guile: `c-lw6sys-log-set-level'
     Wrapper on lw6sys_log_set_level.

4.16.288 c-lw6sys-path-concat
-----------------------------

 -- C function exported to Guile: `c-lw6sys-path-concat'
     Wrapper on lw6sys_path_concat.

4.16.289 c-lw6sys-path-parent
-----------------------------

 -- C function exported to Guile: `c-lw6sys-path-parent'
     Wrapper on lw6sys_path_parent.

4.16.290 c-lw6sys-path-split
----------------------------

 -- C function exported to Guile: `c-lw6sys-path-split'
     Wrapper on lw6sys_path_split.

4.16.291 c-lw6sys-set-memory-bazooka-eraser
-------------------------------------------

 -- C function exported to Guile: `c-lw6sys-set-memory-bazooka-eraser'
     Wrapper on lw6sys_set_memory_bazooka_eraser.

4.16.292 c-lw6sys-set-memory-bazooka-size
-----------------------------------------

 -- C function exported to Guile: `c-lw6sys-set-memory-bazooka-size'
     Wrapper on lw6sys_set_memory_bazooka_size.

4.16.293 c-lw6sys-signal-custom
-------------------------------

 -- C function exported to Guile: `c-lw6sys-signal-custom'
     Wrapper on lw6sys_signal_custom.

4.16.294 c-lw6sys-signal-default
--------------------------------

 -- C function exported to Guile: `c-lw6sys-signal-default'
     Wrapper on lw6sys_signal_default.

4.16.295 c-lw6sys-signal-poll-quit
----------------------------------

 -- C function exported to Guile: `c-lw6sys-signal-poll-quit'
     Wrapper on lw6sys_signal_poll_quit.

4.16.296 c-lw6sys-signal-send-quit
----------------------------------

 -- C function exported to Guile: `c-lw6sys-signal-send-quit'
     Wrapper on lw6sys_signal_send_quit.

4.16.297 c-lw6sys-sleep
-----------------------

 -- C function exported to Guile: `c-lw6sys-sleep'
     Wrapper on lw6sys_sleep.

4.16.298 c-lw6sys-snooze
------------------------

 -- C function exported to Guile: `c-lw6sys-snooze'
     Wrapper on lw6sys_snooze.

4.16.299 c-lw6sys-url-canonize
------------------------------

 -- C function exported to Guile: `c-lw6sys-url-canonize'
     Wrapper on lw6sys_url_canonize.

4.16.300 c-lw6tsk-loader-get-stage
----------------------------------

 -- C function exported to Guile: `c-lw6tsk-loader-get-stage'
     Wrapper on lw6tsk_loader_get_stage.

4.16.301 c-lw6tsk-loader-new
----------------------------

 -- C function exported to Guile: `c-lw6tsk-loader-new'
     Wrapper on lw6tsk_loader_new.

4.16.302 c-lw6tsk-loader-pop
----------------------------

 -- C function exported to Guile: `c-lw6tsk-loader-pop'
     Wrapper on lw6tsk_loader_pop.

4.16.303 c-lw6tsk-loader-push
-----------------------------

 -- C function exported to Guile: `c-lw6tsk-loader-push'
     Wrapper on lw6tsk_loader_push.


File: liquidwar6.info,  Node: Script hooks,  Prev: C to Guile,  Up: Reference

4.17 Script hooks
=================


File: liquidwar6.info,  Node: C API,  Prev: Reference,  Up: Top

5 C API
*******

This chapter contains a description of all modules and a list of all
documented C functions in the program. It contains many references and
is self-generated from C comments using gdoc
(http://josefsson.org/gdoc/) by Simon Josefsson (http://josefsson.org/).

   In order to reduce the number of pages of printed output, this
complete reference is, by default, disabled in printable versions of
the documentation (PostScript, PDF).  This is both to make the manual
more readable and to avoid wasting paper.  Think about the environment.

   It is however available in the HTML version of the documentation,
which you can read online on
`http://www.gnu.org/software/liquidwar6/manual/html_node/'.

   Additionnally, the following adresses contain various view on the
source code, giving informations on all the internal and public C
interfaces:

   * `http://www.gnu.org/software/liquidwar6/coverage/': the lcov
     (http://ltp.sourceforge.net/coverage/lcov.php) output when running
     `./liquidwar6 --test'.  It shows what functions are actually
     tested, and how many times they are called.

   * `http://www.gnu.org/software/liquidwar6/global/': the GNU global
     (http://www.gnu.org/software/global/) output gives complete
     cross-references, macros, headers, contants declaration. It's a
     very good place to start browsing the code.

   * `http://www.gnu.org/software/liquidwar6/cyclo/': the pmccabe
     (http://parisc-linux.org/~bame/pmccabe/) output shows the
     cyclomatic complexity of functions. It enables the programmer to
     spots the "ugly" and dangerous parts of the program.

* Menu:

* libliquidwar6::       Top-level functions.
* libbot::              Bot algorithms.
* mod-brute::           Brute-force bot.
* mod-follow::          A bot that follows others.
* mod-idiot::           Basic idiot bot.
* mod-random::          Totally random bot.
* libcfg::              Loading and saving config files.
* libcli::              Network clients.
* mod-http::            Web client.
* mod-tcp::             Tcp client using native protocol.
* mod-udp::             Udp client using native protocol.
* libcns::              Console handling.
* libcnx::              Connection common code.
* libdat::              Storing network data.
* libdef::              Keywords definitions.
* libdsp::              Threaded display.
* libdyn::              Dynamic module loading.
* libgfx::              Graphics.
* mod-gl::              Main 3D graphics backend.
* libglb::              Gnulib embedded routines.
* libgui::              GUI utilities.
* libhlp::              Built-in help system.
* libimg::              Generating screenshots.
* libker::              Main kernel module (core algorithm).
* libldr::              Loading maps.
* libmap::              Map, AKA levels.
* libmsg::              Network messages.
* libnet::              Low-level network routines.
* libnod::              Manipulating node data.
* libp2p::              A la peer to peer network system.
* libpil::              Dealing with game lag.
* libscm::              Guile wrapper.
* libsnd::              Sound.
* mod-csound::          Csound sound backend (vaporware).
* mod-ogg::             Ogg/libSDL default sound backend.
* libsrv::              Network servers.
* mod-httpd::           Embedded web server.
* mod-tcpd::            Tcp server using native protocol.
* mod-udpd::            Udp server using native protocol.
* libsys::              Low-level system utilities.
* libtsk::              Asynchronous loading.
* libvox::              Voxel-based 3D rendering.


File: liquidwar6.info,  Node: libliquidwar6,  Next: libbot,  Up: C API

5.1 libliquidwar6
=================

5.1.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/index.html'.

5.1.2 API
---------

 -- Function: void lw6_resize_callback (lw6gui_video_mode_t *
          VIDEO_MODE)
     VIDEO_MODE:  the new video mode

     This callback is here because gfx needs to update the config when
     the screen is resized. But... we did not want to make gfx depend
     on cfg "directly". It's cleaner to pass parameters with Scheme, in
     the long run, it should make things easier.  So this callback is
     the solution. Another side effect is that this way there's a
     tangible obvious trace of this updating of config status by the
     gfx module. Seeing it sticking out like a thumb isn't a bad thing.

     *Return value:*  none

 -- Function: void lw6_release ()
     Functions which will call `quit'(), `free'(), `destroy'() on
     whatever smob object that has threads and/or requires hardware
     ressources.  This is to be called before the Guile interpreter
     ends. This is because when it garbage collects objects at the end
     of the program, it has no idea of what order to use when freeing
     objects. So if an object which uses another one in a thread is
     freed after the other is freed, you get a (rather unexplainabled
     if not warned) segfault.

     *Return value:*  none

 -- Function: void lw6_exit ()
     Sends a quit message and displays a newline.

     *Return value:*  none

 -- Function: int lw6_fix_env (int ARGC, char * [] ARGV)
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Fixes environment variables (path related) so that program can
     find its requirements. This must be called early in the program
     flow (else other calls might fail).

     *Return value:*  1 if success, 0 if failure

 -- Function: int lw6_register_funcs ()
     Register all the functions, make them callable from Guile.  This
     is a very simple yet long and very usefull function, without it
     Guile has no knowledge of what LW6 is.

     *Return value:*  1 on success, 0 if failed.

 -- Function: extern void lw6_cns_handler (char * C_LINE)
     c_line: the line typed by the user

     This function will be called every time a message is typed on the
     console. It runs the given line in the current Guile environment.

     *Return value:*  none

 -- Function: int lw6_init_global (int ARGC, char * [] ARGV)
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Initializes global values to their defaults.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6_quit_global ()
     argc: number of args as passed to main argv: array of strings as
     passed to main

     Frees global values. Will also garbage collect objects in case
     Guile failed to do it perfectly (or we failed to tell Guile how to
     do it).

     *Return value:*  none.

 -- Function: int lw6_main (int ARGC, char * [] ARGV)
     ARGC:  the argc parameter of the `main'() function, that is, the
     number of command-line args.

     ARGV:  the argv parameter of the `main'() function, that is, an
     array containing pointers on command-line args.

     This function is directly called by `main'(). This means by linking
     against libliquidwar6 and calling it, you would have a program
     that is almost exactly the "official" upstream liquidwar6 binary,
     except you can tweak it and have all the power to call whatever
     other functions you like, embed it. In short, everything the binary
     does, you can do it in your own binarn, by linking against the
     library and calling this function.

     *Return value:*  1 if success, zero if failure. Note that this is
     the "standard" C / liquidwar6 way to proceed, but your `main'()
     function should return 0 if success, else an error code. Typical
     use is "return !lw6_main(argc, argv);".

 -- Function: int lw6_process_non_run_options (int ARGC, char * []
          ARGV, int * RUN_GAME)
     ARGC:  the number of command-line args, as passed to `main()'

     ARGV:  an array of strings containing command-line args, as passed
     to `main()'

     RUN_GAME:  a pointer to a boolean which will contain true (1) if
     the game must be launched, or false (0) if the option is such that
     game must be skipped. Example: -copyright, -help, ...

     *Return value:*  non-zero if success, 0 if error. The error can
     be, for instance, the test suite returning "no, tests were not OK".

 -- Function: void lw6_print_help ()
     Displays a short help message.

     *Return value:*  none

 -- Function: void lw6_print_version ()
     Displays the version of the game.

     *Return value:*  none

 -- Function: void lw6_print_short_copyright ()
     Displays the copyright of the game (short version).

     *Return value:*  none

 -- Function: void lw6_print_long_copyright ()
     Displays the copyright of the game (long version).

     *Return value:*  none

 -- Function: void lw6_print_bench (float BENCH_RESULT)
     Displays the program bench value.

     *Return value:*  none

 -- Function: void lw6_print_pedigree ()
     Displays the program pedigree, think of this as version on
     steroids.

     *Return value:*  none

 -- Function: void lw6_print_host ()
     Displays the host on which the program was compiled.

     *Return value:*  none

 -- Function: void lw6_print_audit (int ARGC, char * [] ARGV)
     Displays various paths used by the game.

     *Return value:*  none

 -- Function: void lw6_print_modules ()
     Displays the list of modules compiled with the game.

     *Return value:*  none

 -- Function: void lw6_print_list_quick ()
     Displays the list of 'quick' options.

     *Return value:*  none

 -- Function: void lw6_print_list_doc ()
     Displays the list of 'doc' options.

     *Return value:*  none

 -- Function: void lw6_print_list_show ()
     Displays the list of 'show' options.

     *Return value:*  none

 -- Function: void lw6_print_list_path ()
     Displays the list of 'path' options.

     *Return value:*  none

 -- Function: void lw6_print_list_players ()
     Displays the list of 'players' options.

     *Return value:*  none

 -- Function: void lw6_print_list_input ()
     Displays the list of 'input' options.

     *Return value:*  none

 -- Function: void lw6_print_list_graphics ()
     Displays the list of 'graphics' options.

     *Return value:*  none

 -- Function: void lw6_print_list_sound ()
     Displays the list of 'sound' options.

     *Return value:*  none

 -- Function: void lw6_print_list_network ()
     Displays the list of 'network' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map ()
     Displays the list of 'map' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_rules ()
     Displays the list of 'map rules' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_hints ()
     Displays the list of 'map hints' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_style ()
     Displays the list of 'map style' options.

     *Return value:*  none

 -- Function: void lw6_print_list_map_teams ()
     Displays the list of 'map teams' options.

     *Return value:*  none

 -- Function: void lw6_print_list_funcs ()
     Displays the list of 'funcs'.

     *Return value:*  none

 -- Function: void lw6_print_list_hooks ()
     Displays the list of 'hooks'.

     *Return value:*  none

 -- Function: void lw6_print_list_advanced ()
     Displays the list of 'advanced' options.

     *Return value:*  none

 -- Function: void lw6_print_list_aliases ()
     Displays the list of options aliases.

     *Return value:*  none

 -- Function: void lw6_print_list ()
     Displays the list of all known options.

     *Return value:*  none

 -- Function: void lw6_print_about (char * KEYWORD)
     Displays the about message for a keyword.

     *Return value:*  none

 -- Function: void lw6_print_hello (int ARGC, char * [] ARGV)
     Displays 'hello' at the beginning of the program.

     *Return value:*  none

 -- Function: void lw6_print_goodbye ()
     Displays 'goodbye', typically use at end of program to know it's
     over and everything went fine.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_dsp (lw6dsp_backend_t * C_DSP)
     C_DSP:  the display object

     Creates an SCM 'dsp' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6dsp_backend_t * lw6_scm_to_dsp (SCM DSP)
     DSP:  the dsp to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'dsp'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_dsp_smob (lw6_dsp_smob_t * DSP_SMOB)
     DSP_SMOB:  the smob to free

     Frees a dsp smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_snd (lw6snd_backend_t * C_SND)
     C_SND:  the sound object

     Creates an SCM 'snd' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6snd_backend_t * lw6_scm_to_snd (SCM SND)
     SND:  the snd to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'snd'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_snd_smob (lw6_snd_smob_t * SND_SMOB)
     SND_SMOB:  the smob to free

     Frees a snd smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_map (lw6map_level_t * C_MAP)
     C_MAP:  the map object

     Creates an SCM 'map' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6map_level_t * lw6_scm_to_map (SCM MAP)
     MAP:  the map to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'map'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_map_smob (lw6_map_smob_t * MAP_SMOB)
     MAP_SMOB:  the smob to free

     Frees a map smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_menu (lw6gui_menu_t * C_MENU)
     C_MENU:  the menu object

     Creates an SCM 'menu' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6gui_menu_t * lw6_scm_to_menu (SCM MENU)
     MENU:  the menu to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'menu'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_menu_smob (lw6_menu_smob_t * MENU_SMOB)
     MENU_SMOB:  the smob to free

     Frees a menu smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_game_struct (lw6ker_game_struct_t *
          C_GAME_STRUCT, SCM MAP)
     C_GAME_STRUCT:  the game struct object

     MAP:  the map (SCM object) referenced

     Creates an SCM 'game-struct' object from C data.  Passing the map
     object enables the garbage collector not to free the map until the
     game struct is freed.

     *Return value:*  the SCM object

 -- Function: lw6ker_game_struct_t * lw6_scm_to_game_struct (SCM
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_struct' object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_struct_smob (lw6_game_struct_smob_t *
          GAME_STRUCT_SMOB)
     GAME_STRUCT_SMOB:  the smob to free

     Frees a game_struct smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_game_state (lw6ker_game_state_t *
          C_GAME_STATE, SCM GAME_STRUCT)
     C_GAME_STATE:  the game state object

     GAME_STRUCT:  the game struct (SCM object) referenced

     Creates an SCM 'game_state' object from C data.  Passing
     game_struct enables the garbage collector not to free the
     game_struct until the game_state is freed.

     *Return value:*  the SCM object

 -- Function: lw6ker_game_state_t * lw6_scm_to_game_state (SCM
          GAME_STATE)
     GAME_STATE:  the game_state to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme
     'game_state' object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_game_state_smob (lw6_game_state_smob_t *
          GAME_STATE_SMOB)
     GAME_STATE_SMOB:  the smob to free

     Frees a game_state smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_pilot (lw6pil_pilot_t * C_PILOT)
     C_PILOT:  the pilot object

     Creates an SCM 'pilot' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6pil_pilot_t * lw6_scm_to_pilot (SCM PILOT)
     PILOT:  the pilot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'pilot'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_pilot_smob (lw6_pilot_smob_t * PILOT_SMOB)
     PILOT_SMOB:  the smob to free

     Frees a pilot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_bot (lw6bot_backend_t * C_BOT, SCM
          GAME_STATE, SCM PILOT)
     C_BOT:  the bot object

     GAME_STATE:  the game state

     PILOT:  the pilot

     Creates an SCM 'bot' object from C data.  Passing game_state and
     pilot enables the garbage collector not the free them until bot is
     freed.

     *Return value:*  the SCM object

 -- Function: lw6bot_backend_t * lw6_scm_to_bot (SCM BOT)
     BOT:  the bot to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'bot'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_bot_smob (lw6_bot_smob_t * BOT_SMOB)
     BOT_SMOB:  the smob to free

     Frees a bot smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_look (lw6gui_look_t * C_LOOK)
     C_LOOK:  the look object

     Creates an SCM 'look' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6gui_look_t * lw6_scm_to_look (SCM LOOK)
     LOOK:  the look to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'look'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_look_smob (lw6_look_smob_t * LOOK_SMOB)
     LOOK_SMOB:  the smob to free

     Frees a look smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_loader (lw6tsk_loader_t * C_LOADER)
     C_LOADER:  the loader object

     Creates an SCM 'loader' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6tsk_loader_t * lw6_scm_to_loader (SCM LOADER)
     LOADER:  the loader to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'loader'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_loader_smob (lw6_loader_smob_t *
          LOADER_SMOB)
     LOADER_SMOB:  the smob to free

     Frees a loader smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_db (lw6p2p_db_t * C_DB)
     C_DB:  the database object

     Creates an SCM 'db' object from C data.

     *Return value:*  the SCM object

 -- Function: lw6p2p_db_t * lw6_scm_to_db (SCM DB)
     DB:  the db to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'db'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_db_smob (lw6_db_smob_t * DB_SMOB)
     DB_SMOB:  the smob to free

     Frees a db smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: SCM lw6_make_scm_node (lw6p2p_node_t * C_NODE, SCM DB)
     C_NODE:  the node object

     DB:  the db (SCM object) referenced

     Creates an SCM 'node' object from C data.  Passing db enables the
     garbage collector not to free db until node is freed.

     *Return value:*  the SCM object

 -- Function: lw6p2p_node_t * lw6_scm_to_node (SCM NODE)
     NODE:  the node to convert (SCM object)

     Gets the internal C pointer corresponding to the scheme 'node'
     object.

     *Return value:*  a pointer, *not* a copy, must not be freed

 -- Function: void lw6_free_node_smob (lw6_node_smob_t * NODE_SMOB)
     NODE_SMOB:  the smob to free

     Frees a node smob, we need a special function to do that as
     structures like assoc hold pointers to these objects and therefore
     need a proper callback when being destroyed.

     *Return value:*  none

 -- Function: int lw6_register_smobs ()
     Register all smobs to Guile.

     *Return value:*  1 on success, 0 if failed.

 -- Function: int lw6_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the liquidwar6 core module test suite, this will mostly test
     how Guile script integration works, loading a sample script and
     running it. It does not launch all the other sub modules tests.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libbot,  Next: mod-brute,  Prev: libliquidwar6,  Up: C API

5.2 libbot
==========

5.2.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/bot/index.html'.

5.2.2 API
---------

 -- Function: int lw6bot_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `bot' module test suite. Will try several engines and
     query basic moves.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: mod-brute,  Next: mod-follow,  Prev: libbot,  Up: C API

5.3 mod-brute
=============

5.3.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/bot/mod-brute/index.html'.

5.3.2 API
---------


File: liquidwar6.info,  Node: mod-follow,  Next: mod-idiot,  Prev: mod-brute,  Up: C API

5.4 mod-follow
==============

5.4.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/bot/mod-follow/index.html'.

5.4.2 API
---------


File: liquidwar6.info,  Node: mod-idiot,  Next: mod-random,  Prev: mod-follow,  Up: C API

5.5 mod-idiot
=============

5.5.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/bot/mod-idiot/index.html'.

5.5.2 API
---------


File: liquidwar6.info,  Node: mod-random,  Next: libcfg,  Prev: mod-idiot,  Up: C API

5.6 mod-random
==============

5.6.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/bot/mod-random/index.html'.

5.6.2 API
---------


File: liquidwar6.info,  Node: libcfg,  Next: libcli,  Prev: mod-random,  Up: C API

5.7 libcfg
==========

5.7.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cfg/index.html'.

5.7.2 API
---------

 -- Function: int lw6cfg_parse_command_line (void * CONTEXT)
     CONTEXT:  opaque pointer on a context

     Overwrites any existing option with command line args

     *Return value:*  1 if success, 0 if error

 -- Function: int lw6cfg_defaults (void * CONTEXT)
     CONTEXT:  opaque pointer on a context

     Sets all values to their defaults.

     *Return value:*  1 if success, 0 if error

 -- Function: int lw6cfg_merge_env (void * CFG_CONTEXT)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     Overwrites any existing vale in the config with environment
     variables prefixed by LW6_.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: int lw6cfg_load_exp (char * USER_DIR, int * EXP)
     USER_DIR:  the user directory

     EXP:  the exp (out param)

     Gets exp from file.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6cfg_save_exp (char * USER_DIR, int EXP)
     USER_DIR:  the user directory

     EXP:  the exp

     Saves exp to file.

     *Return value:*  1 on success, 0 on failure

 -- Function: char * lw6cfg_format (char * KEY, char * VALUE,
          lw6hlp_type_t TYPE)
     KEY:  the key of the value to format

     VALUE:  the value to format

     TYPE:  the type of the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on. This is a
     performance killer but will ensure everything is correct.

     *Return value:*  a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: char * lw6cfg_format_guess_type (char * KEY, char * VALUE)
     KEY:  the key of the value to format

     VALUE:  the value to format

     Formats, converts, a given value to its cannonical representation.
     Booleans will be converted to true/false, strings containing
     integers will be stripped from junk, and so on. This is a
     performance killer but will ensure everything is correct. This
     function will automatically guess the type of the value from its
     description in the help system.

     *Return value:*  a newly allocated string, containing the same as
     the input, but reformatted the pedantic way.

 -- Function: int lw6cfg_load (void * CFG_CONTEXT, char * FILENAME)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     FILENAME:  a file path, absolute or relative

     Loads the given config file, and stores its values into the current
     context. Parameters which are both in the config file and given as
     command line parameters, will be taken from the command-line.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: int lw6cfg_save (void * CFG_CONTEXT, char * FILENAME)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     FILENAME:  a file path, absolute or relative

     Save current options into the given config file. Before saving the
     file, all command line arguments will be read and will override
     current values. This means the saved file will contain values
     given as command line arguments.

     *Return value:*  1 if successfull, 0 if error.

 -- Function: void * lw6cfg_init (int ARGC, char * [] ARGV)
     ARGC:  number of command line arguments, as given to `main'

     ARGV:  a list of command line arguments, as given to `main'

     Initializes a config context object. This object is hidden behind
     an opaque void * pointer to avoid direct access to its elements.

     *Return value:*  an opaque pointer, must be freed with
     `lw6cfg_quit'.

 -- Function: void lw6cfg_quit (void * CFG_CONTEXT)
     CFG_CONTEXT:  a context returned by `lw6cfg_init'

     Frees a config cfg_context object. You must call this once you're
     done with the context.

     *Return value:*  none.

 -- Function: void lw6cfg_reset (int ARGC, char * [] ARGV)
     ARGC:  number of command line arguments, as given to `main'

     ARGV:  a list of command line arguments, as given to `main'

     Overwrites the config file with defaults.  Use this to get rid of
     old configurations.

 -- Function: int lw6cfg_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cfg' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: char * lw6cfg_unified_get_value (int ARGC, char * []
          ARGV, char * KEY)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     KEY:  the key to query

     Unified "value" getter, which gets informations from environment
     variables, command line, and config file. The rules is that the
     command-line argument always has the last word. It will override
     any other value.  Follows environment variables, which will be
     used if no command-line argument is supplied. Note that these are
     "LW6_" prefixed and uppercased environment variables as opposed to
     lowercased and "dash-separated" keys. Finally, if there's no
     environment variable, nor any config-file corresponding entry, the
     value will be searched in the config file.  If there's no
     information in the config file, NULL is returned.

     *Return value:*  a string with the value. Can be NULL. Must be
     freed.

 -- Function: char * lw6cfg_unified_get_user_dir (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_USER_DIR" env value, the "-user-dir" command-line
     paramater and the LW6DEF_USER_DIR config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_log_file (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the log file, taking all parameters in account, that's to say
     the "LW6_LOG_FILE" env value, the "-log-file" command-line
     paramater and the LW6DEF_LOG_FILE config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_music_path (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MUSIC_PATH" env value, the "-music-path" command-line
     paramater and the LW6DEF_MUSIC_PATH config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.

 -- Function: char * lw6cfg_unified_get_map_path (int ARGC, char * []
          ARGV)
     ARGC:  number of command-line args, as passed to `main'

     ARGV:  arry of command-line args, as passed to `main'

     Gets the user dir, taking all parameters in account, that's to say
     the "LW6_MAP_PATH" env value, the "-map-path" command-line
     paramater and the LW6DEF_MAP_PATH config file entry.

     *Return value:*  the directory path, might be NULL, must be freed.


File: liquidwar6.info,  Node: libcli,  Next: mod-http,  Prev: libcfg,  Up: C API

5.8 libcli
==========

5.8.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cli/index.html'.

5.8.2 API
---------

 -- Function: lw6cli_oob_t * lw6cli_oob_new (char * PUBLIC_URL,
          lw6cli_verify_callback_func_t VERIFY_CALLBACK_FUNC, void *
          VERIFY_CALLBACK_DATA)
     PUBLIC_URL:  the address of the distant server to test

     VERIFY_CALLBACK_FUNC:  a function which will be called when a node
     has been verified

     VERIFY_CALLBACK_DATA:  additionnal data passed to the callback func

     Create a new OOB structure, copying required objects.  We need to
     make copies for this is for usage in a separate thread. The thread
     member is not set here since the right way to do things is first to
     set up data then to fire the thread.

     *Return value:*  new object

 -- Function: void lw6cli_oob_free (lw6cli_oob_t * OOB)
     OOB:  the object to free

     Frees an OOB structure.

     *Return value:*  none

 -- Function: int lw6cli_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cli' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: mod-http,  Next: mod-tcp,  Prev: libcli,  Up: C API

5.9 mod-http
============

5.9.1 Overview
--------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cli/mod-http/index.html'.

5.9.2 API
---------


File: liquidwar6.info,  Node: mod-tcp,  Next: mod-udp,  Prev: mod-http,  Up: C API

5.10 mod-tcp
============

5.10.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cli/mod-tcp/index.html'.

5.10.2 API
----------


File: liquidwar6.info,  Node: mod-udp,  Next: libcns,  Prev: mod-tcp,  Up: C API

5.11 mod-udp
============

5.11.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cli/mod-udp/index.html'.

5.11.2 API
----------


File: liquidwar6.info,  Node: libcns,  Next: libcnx,  Prev: mod-udp,  Up: C API

5.12 libcns
===========

5.12.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cns/index.html'.

5.12.2 API
----------

 -- Function: int lw6cns_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cns' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libcnx,  Next: libdat,  Prev: libcns,  Up: C API

5.13 libcnx
===========

5.13.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/cnx/index.html'.

5.13.2 API
----------

 -- Function: lw6cnx_connection_t * lw6cnx_connection_new (char *
          LOCAL_URL, char * REMOTE_URL, char * REMOTE_IP, int
          REMOTE_PORT, char * PASSWORD, u_int64_t LOCAL_ID, u_int64_t
          REMOTE_ID, int DNS_OK, int NETWORK_RELIABILITY,
          lw6cnx_recv_callback_t RECV_CALLBACK_FUNC, void *
          RECV_CALLBACK_DATA)
     LOCAL_URL:  the local public URL

     REMOTE_URL:  the remote public URL

     REMOTE_IP:  the remote IP address

     REMOTE_PORT:  the remote port

     PASSWORD:  the password to use

     LOCAL_ID:  the local ID

     REMOTE_ID:  the remote ID

     DNS_OK:  1 if no DNS mismatch, 0 if IP does not match public URL

     NETWORK_RELIABILITY:  drop 1 out of X packets

     RECV_CALLBACK_FUNC:  a callback to call when data is received

     RECV_CALLBACK_DATA:  additionnal data to pass to the callback

     Create a connection object. This object in itself does nothing,
     it's just to share common structures among modules, more
     precisely, between cli and srv code.  It's the responsability off
     the caller/backend to handle the `backend_specific_data' field
     which is NULL after this call.

     *Return value:*  newly allocated object.

 -- Function: void lw6cnx_connection_free (lw6cnx_connection_t *
          CONNECTION)
     CONNECTION:  object to free

     Frees a connection object. It's the responsibility of the
     caller/backend to handle the `backend_specific_data' field.

     *Return value:*  none.

 -- Function: int lw6cnx_connection_should_send_foo
          (lw6cnx_connection_t * CONNECTION, int64_t NOW)
     CONNECTION:  the connection concerned

     NOW:  the current timestamp

     Tells wether a new foo message must be issued.

     *Return value:*  1 if true, 0 if false.

 -- Function: void lw6cnx_connection_init_foo_bar_key
          (lw6cnx_connection_t * CONNECTION, int64_t NOW, int
          NEXT_FOO_DELAY)
     CONNECTION:  the connection concerned

     NOW:  the current timestamp

     NEXT_FOO_DELAY:  the delay (msec) before next foo message is sent

     Generates a new foo_bar_key, and schedules the next foo message
     send timestamp.

     *Return value:*  none.

 -- Function: int lw6cnx_connection_lock_send (lw6cnx_connection_t *
          CONNECTION)
     CONNECTION:  the connexion to lock

     Acquires a "send" lock on the connexion, the idea is to avoid too
     threads sending data using the same socket at the same time.  Note
     that each backend must call this when accessing the socket,
     there's no top-level lock for the sake of performance.

     *Return value:*  1 on success, 0 if not.

 -- Function: void lw6cnx_connection_unlock_send (lw6cnx_connection_t *
          CONNECTION)
     CONNECTION:  the connexion to lock

     Releases a "send" lock on the connexion, the idea is to avoid too
     threads sending data using the same socket at the same time.  Note
     that each backend must call this when accessing the socket,
     there's no top-level lock for the sake of performance.

     *Return value:*  none.

 -- Function: int lw6cnx_connection_reliability_filter
          (lw6cnx_connection_t * CONNECTION)
     CONNECTION:  the connexion concerned

     Will filter and return true only in "rare" cases when packets must
     be artificially dropped for testing purpose.

     *Return value:*  1 if message must be sent/received, 0 if not

 -- Function: char * lw6cnx_password_checksum (char * SEED, char *
          PASSWORD)
     SEED:  a seed to blur the password, can be NULL

     PASSWORD:  the password, can be NULL

     Calculates the checksum of a password, and returns it as a string,
     ready to be sent on the network.  If password is empty or NULL,
     then an empty (but not NULL unless internal error) string will be
     returned. All LW6 protocols should send these checksums instead of
     real passwords, then on server side value can be checked against
     both real password and its checksum. The seed is here so that
     eavesdropper can't reuse the checksum to connect on random
     sessions. Seed can typically be the node 'public_url' value.

     *Return value:*  a dynamically allocated string

 -- Function: int lw6cnx_password_verify (char * SEED, char *
          PASSWORD_HERE, char * PASSWORD_RECEIVED)
     SEED:  a seed to blur the password, can be NULL

     PASSWORD_HERE:  the local password, can be NULL

     PASSWORD_RECEIVED:  the password received from network, can be NULL

     Tells wether a password received over the network is valid.  The
     `password_here' argument (the local password) will be checksumed
     so that `password_received' is checked against both clear and
     checksumed values, so it can be in any form.

     *Return value:*  1 if OK, passwords are the same, 0 if not.

 -- Function: int lw6cnx_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `cnx' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: void lw6cnx_ticket_table_zero (lw6cnx_ticket_table_t *
          TICKET_TABLE)
     TICKET_TABLE:  the ticket table to fill with zero

     Fills the ticket table struct with 0s.

     *Return value:*  none.

 -- Function: int lw6cnx_ticket_table_init (lw6cnx_ticket_table_t *
          TICKET_TABLE, int HASH_SIZE)
     TICKET_TABLE:  the ticket table to init

     HASH_SIZE:  the hash size for both recv/send hashs

     Initialize a ticket table, that is, set it up with two empty
     hashs. Recv hash is filled automatically as it's queried for
     tickets, send hash must be filled explicitely with info from the
     network.

     *Return value:*  none.

 -- Function: void lw6cnx_ticket_table_clear (lw6cnx_ticket_table_t *
          TICKET_TABLE)
     TICKET_TABLE:  the ticket table to clear

     Clears the object (frees memory).

     *Return value:*  none.

 -- Function: u_int64_t lw6cnx_ticket_table_get_recv
          (lw6cnx_ticket_table_t * TICKET_TABLE, char * PEER_ID)
     TICKET_TABLE:  the ticket table to query

     PEER_ID:  the id of remote node

     Gets the ticket used to communicate with peer, to check its
     incoming (recv) messages. If ticket does not exist yet, it's
     automatically generated so tunction will always return a non-zero
     value.

     *Return value:*  the ticket used to check incoming messages.

 -- Function: void lw6cnx_ticket_table_ack_recv (lw6cnx_ticket_table_t
          * TICKET_TABLE, char * PEER_ID)
     TICKET_TABLE:  the ticket table to query

     PEER_ID:  the id of remote node

     Acknowledges the ticket used to communicate with peer, to check
     its incoming (recv) messages has been received. This is to avoid
     sending it again when it has been received, as it's kept "forever"
     by peer, we never need to send it again.

     *Return value:*  none.

 -- Function: int lw6cnx_ticket_table_was_recv_exchanged
          (lw6cnx_ticket_table_t * TICKET_TABLE, char * PEER_ID)
     TICKET_TABLE:  the ticket table to query

     PEER_ID:  the id of remote node

     Acknowledges the ticket used to communicate with peer, to check
     its incoming (recv) messages has been received. This is to avoid
     sending it again when it has been received, as it's kept "forever"
     by peer, we never need to send it again.

     *Return value:*  the ticket used to check incoming messages.

 -- Function: u_int64_t lw6cnx_ticket_table_get_send
          (lw6cnx_ticket_table_t * TICKET_TABLE, char * PEER_ID)
     TICKET_TABLE:  the ticket table to query

     PEER_ID:  the id of remote node

     Gets the ticket used to communicate with peer, to stamp the
     outgoing messages. If ticket does not exist yet, 0 is returned,
     indeed this value must be initialized with the value the peer
     gives us.

     *Return value:*  the ticket used to stamp outgoing messages.

 -- Function: void lw6cnx_ticket_table_set_send (lw6cnx_ticket_table_t
          * TICKET_TABLE, char * PEER_ID, u_int64_t SEND_TICKET)
     TICKET_TABLE:  the ticket table to query

     PEER_ID:  the id of remote node

     SEND_TICKET:  the ticket to use to stamp outgoing messages

     Sets the ticket used to communicate with peer, to stamp the
     outgoing (send) messages. This value should be received from the
     network. Note that once it's set, it's impossible to change it, it
     will remain the same for the whole duration of the node existence.

     *Return value:*  NULL


File: liquidwar6.info,  Node: libdat,  Next: libdef,  Prev: libcnx,  Up: C API

5.14 libdat
===========

5.14.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/dat/index.html'.

5.14.2 API
----------

 -- Function: int lw6dat_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `dat' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: lw6dat_warehouse_t * lw6dat_warehouse_new (u_int64_t
          LOCAL_NODE_ID)
     Creates a new warehouse object.

     *Return value:*  new object, allocated dynamically

 -- Function: void lw6dat_warehouse_free (lw6dat_warehouse_t *
          WAREHOUSE)
     WAREHOUSE:  the object to free

     Frees a warehouse object.

     *Return value:*  new object, allocated dynamically

 -- Function: void lw6dat_warehouse_purge (lw6dat_warehouse_t *
          WAREHOUSE)
     WAREHOUSE:  the object to purge

     Purges a warehouse object.

     *Return value:*  new object, allocated dynamically

 -- Function: int lw6dat_warehouse_get_nb_nodes (lw6dat_warehouse_t *
          WAREHOUSE)
     WAREHOUSE:  the warehouse object to query.

     Tells how many nodes are registered in the object.

     *Return value:*  integer, number of nodes


File: liquidwar6.info,  Node: libdef,  Next: libdsp,  Prev: libdat,  Up: C API

5.15 libdef
===========

5.15.1 Overview
---------------

5.15.2 API
----------

There are no functions in `libdef', only a header file with constants.


File: liquidwar6.info,  Node: libdsp,  Next: libdyn,  Prev: libdef,  Up: C API

5.16 libdsp
===========

5.16.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/dsp/index.html'.

5.16.2 API
----------

 -- Function: lw6dsp_backend_t * lw6dsp_create_backend (int ARGC, char
          * [] ARGV, char * GFX_BACKEND_NAME)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     GFX_BACKEND_NAME:  the id/name of the gfx backend to use

     Creates a dsp_backend object. The created object won't be
     displaying things until `lw6dsp_init' is called. No thread is
     created, but the graphics backend is loaded into memory. If video
     mode is not available, it will appear later, when trying to start
     displaying things, this function only allocates memory and checks
     code is available in case of a dynamically loaded gfx backend.

     *Return value:*  a newly allocated object.

 -- Function: void lw6dsp_destroy_backend (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend object to free

     Frees all ressources used by a dsp_backend object. Note that you
     must call this on a inactive 'stopped' dsp_backend object.

     *Return value:*  none.

 -- Function: char * lw6dsp_repr (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the object to represent

     Gives a short human-readable description of the object.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: int lw6dsp_init (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM, lw6gui_resize_callback_func_t
          RESIZE_CALLBACK)
     DSP_BACKEND:  the dsp_backend to start

     PARAM:  parameters to pass to the display funcs

     RESIZE_CALLBACK:  a function which will be called when there's a
     resize event

     Starts a dsp_backend object, that is, fire a separate thread and
     start rendering. This will set up a video mode, so it's very
     likely to fail if for some reason the video context isn't right,
     for instance if you try to set up graphical stuff but only have
     console access.

     *Return value:*  1 if success, 0 if error.

 -- Function: void lw6dsp_quit (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to stop

     Stops a dsp_backend, that is, cancel rendering and unset the video
     mode, hardware shouldn't be used any more after this call.

     *Return value:*  none.

 -- Function: int lw6dsp_update (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM)
     DSP_BACKEND:  the dsp_backend to update

     PARAM:  parameters to pass to the dsp_backend funcs

     Passes a new set of parameters to the display function.  This is
     in fact the only way to pass informations to the dsp_backend
     object once it's been started. This function will acquire a mutex,
     copy parameters, then give control back to the main thread while
     display keeps on going with new parameters in the background. It
     will get input informations.  You really must call it often
     otherwise the screen won't get updated, or, at least, it will
     always display the same informations.  It should be reasonnable to
     call this 10 or 20 times per second, the display itself can be
     faster, run at 60 or 100 fps to show smooth animation (eye candy).

     *Return value:*  1 if success, 0 if error.

 -- Function: int lw6dsp_get_nb_frames (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the number of frames displayed since the display was
     started.

     *Return value:*  the number of frames displayed.

 -- Function: int lw6dsp_get_last_frame_rendering_time
          (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the rendering time of the last frame. Gives clues about
     performance.

     *Return value:*  the number of milliseconds it took to draw screen

 -- Function: int lw6dsp_get_instant_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is the
     instant value, it changes very often even if display seems smooth.

     *Return value:*  the current instant display rate.

 -- Function: int lw6dsp_get_average_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is not
     absolutely accurate but fits for displaying info to the player,
     it's an average.

     *Return value:*  the current averaged display rate.

 -- Function: int lw6dsp_get_video_mode (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     DSP_BACKEND:  the dsp_backend to query

     VIDEO_MODE:  a structure which will contain the results

     Returns the current video mode, the one obtained by the driver.
     This function is also a way to know wether display is running
     correcly or not, by testing its return value.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: int lw6dsp_get_fullscreen_modes (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     DSP_BACKEND:  the dsp_backend to query

     FULLSCREEN_MODES:  a structure which will contain the results

     Returns the current available fullscreen modes. Note that this one
     will only work if display is started, unlike
     `lw6gfx_get_fullscreen_modes' which is used internally. The reason
     is that in this dsp module context, we need the thread to be
     launched, and the thread does start/stop display on its own.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: void lw6dsp_param_zero (lw6dsp_param_t * PARAM)
     PARAM:  the structure to initialize

     Fills a display param struct with zeros, this is mandatory before
     any use. Think of it as a raw memset.

     *Return value:*  none.

 -- Function: int lw6dsp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the test suite for the dsp module. In check (0) mode, won't
     test much to avoid failure because of missing graphical
     environment.

     *Return value:*  1 if OK, 0 if error.


File: liquidwar6.info,  Node: libdyn,  Next: libgfx,  Prev: libdsp,  Up: C API

5.17 libdyn
===========

5.17.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/dyn/index.html'.

5.17.2 API
----------

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend_so (char *
          SO_FILE)
     Opens a .so file directly, using a valid (full) path name.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend (int ARGC,
          char * [] ARGV, char * TOP_LEVEL_LIB, char * BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     Opens a .so file corresponding to the given backend, it is capable
     to search for system libraries installed after "make install" but
     if not found, it will also search in the current build directory,
     finding the .so files in hidden .libs subdirectories.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: int lw6dyn_dlclose_backend (lw6dyn_dl_handle_t * HANDLE)
     HANDLE:  the backend to close.

     Closes an opened backend. Note that you must call any backend
     specific clear, destroy, deinit, exit, function before.

     *Return value:*  1 if success, 0 on error.

 -- Function: void * lw6dyn_dlsym (lw6dyn_dl_handle_t * HANDLE, char *
          FUNC_NAME)
     HANDLE:  the backend concerned

     FUNC_NAME:  the function name, as a NULL terminated string

     Finds a C function in the given backend.

     *Return value:*  a pointer to the function, NULL if not found.

 -- Function: lw6sys_assoc_t * lw6dyn_list_backends (int ARGC, char *
          [] ARGV, char * TOP_LEVEL_LIB)
     ARGC:  the number of command line args, as passed to main

     ARGV:  the commind line args, as passed to main

     TOP_LEVEL_LIB:  the library category to query (gfx, snd, cli, srv
     ...)

     Returns an assoc which lists all the available modules. The key of
     the assoc entries in the module internal name such as 'gl' and the
     value associated is a NULL terminated string describing the
     module, for instance 'OpenGL'.

     *Return value:*  an assoc object containing key/label pairs.

 -- Function: char * lw6dyn_path_find_backend (int ARGC, char * []
          ARGV, char * TOP_LEVEL_LIB, char * BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     BACKEND_NAME:  the actual name of the backend, this is the name of
     the .so file, between "libmod_" and ".so". For instance, to find
     "libmod_gl.so", the right argument is "gl".

     Get the full path to a .so file corresponding to the given backend,
     it is capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current
     build directory, finding the .so files in hidden .libs
     subdirectories.

     *Return value:*  the full path of the .so file, needs to be freed.

 -- Function: int lw6dyn_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `dyn' module test suite, testing most (if not all...)
     functions. Will try to load libraries and query them for standard
     LW6-expected functions.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libgfx,  Next: mod-gl,  Prev: libdyn,  Up: C API

5.18 libgfx
===========

5.18.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gfx/index.html'.

5.18.2 API
----------

 -- Function: int lw6gfx_init (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     BACKEND:  the graphical backend to use

     VIDEO_MODE:  the video mode to use at start up

     RESIZE_CALLBACK:  a callback function which will be called at each
     resize event

     Sets up the graphical backend for good, initializing a video mode
     and allocating ressources. This call can typically fail if there's
     no device available, if the user doesn't have enough rights to
     access the hardware, and so on.

     *Return value:*  1 on success, 0 if not

 -- Function: void lw6gfx_quit (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to free

     Uninitializes the backend, that is, exits the graphical mode. All
     threads that use graphics must be closed when this is called.

     *Return value:*  none.

 -- Function: char * lw6gfx_repr (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to represent

     Returns a readable version of the backend object.

     *Return value:*  a newly allocated pointer.

 -- Function: int lw6gfx_set_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the new video mode

     This function changes the video mode. Note that the first time you
     set up the graphical environment you must call `lw6gfx_init' but
     to change the current mode, use this function. It should reload
     backend data automatically if needed (textures for instance). Note
     that before giving up and failing this function will try alternate
     video modes, and you're not garanteed to have the right mode after
     the call, even if it returns true. To check this, use
     `lw6gfx_get_video_mode'.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the current video mode (will be overwritten, out
     parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_fullscreen_modes (lw6gfx_backend_t *
          BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     BACKEND:  the backend to use

     FULLSCREEN_MODES:  the available fullscreen modes (will be
     overwritten, out parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: lw6gui_input_t * lw6gfx_pump_events (lw6gfx_backend_t *
          BACKEND)
     BACKEND:  the backend to use

     This function "pumps" events, that is gets pending events, puts
     them in queues, maintains internal states up to date. You really
     must call this very often or no input will be processed at all.

     *Return value:*  a pointer on the internal input state, musn't be
     freed.

 -- Function: int lw6gfx_display (lw6gfx_backend_t * BACKEND, int MASK,
          lw6gui_look_t * LOOK, lw6map_level_t * LEVEL,
          lw6ker_game_struct_t * GAME_STRUCT, lw6ker_game_state_t *
          GAME_STATE, lw6pil_local_cursors_t * LOCAL_CURSORS,
          lw6gui_menu_t * MENU, float PROGRESS, float FPS, float MPS,
          char ** LOG_LIST, int CAPTURE, int GFX_DEBUG, int
          DEBUG_TEAM_ID, int DEBUG_LAYER_ID)
     BACKEND:  the graphical backend to use

     MASK:  display flag, tells what to display

     LOOK:  the look, the skin, contains display options

     LEVEL:  the level to display

     GAME_STRUCT:  the game_struct associated with the level

     GAME_STATE:  the game_state associated with the level

     LOCAL_CURSORS:  the cursor to center the focus on

     MENU:  the menu to display

     PROGRESS:  the value of the progress indicator

     FPS:  the number of frames per second to display

     MPS:  the number of moves per second to display

     LOG_LIST:  log messages to display

     CAPTURE:  wether to enable capture mode or not

     GFX_DEBUG:  wether to enable gfx debugging tools

     DEBUG_TEAM_ID:  for debug display, team to display informations
     about

     DEBUG_LAYER_ID:  for debug display, layer to display

     This is the major drawing function, the one that encapsulates all
     others. As the program uses a separate thread to display things,
     we just pass this function many parameters, and let it do its job
     alone. So many parameters might sometimes be useless. It also
     allows the graphics backend decide wether menus and hud and
     background should interact. Or not.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6gfx_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `gfx' module test suite. In check-only mode, this
     function won't test many things, for it requires a graphical mode
     to be available to perform the complete test.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: mod-gl,  Next: libglb,  Prev: libgfx,  Up: C API

5.19 mod-gl
===========

5.19.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gfx/mod-gl/gl-utils/index.html'
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.gnu.org/software/liquidwar6/coverage/index.html) for
complete information).

5.19.2 API
----------


File: liquidwar6.info,  Node: libglb,  Next: libgui,  Prev: mod-gl,  Up: C API

5.20 libglb
===========

5.20.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/glb/index.html'.

5.20.2 API
----------

 -- Function: char * lw6glb_base64_encode_bin (char * BUF, int SIZE)
     BUF:  the data to encode

     SIZE:  the size of data to encode

     Encodes data into base64. Memory allocation is done automatically.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin (int * SIZE, char *
          BASE64_STR)
     SIZE:  the size of the decoded data

     BASE64_STR:  the string to decode

     Decodes data from base64. Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.

     *Return value:*  newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str (char * STR)
     STR:  the string to encode

     Encodes a string into base64.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_str (char * STR)
     STR:  the string to decode

     Decodes a string from base64.

     *Return value:*  newly allocated string, NULL on error.

 -- Function: char * lw6glb_base64_encode_bin_prefix (char * BUF, int
          SIZE, char * PREFIX)
     BUF:  the data to encode

     SIZE:  the size of data to encode

     PREFIX:  a prefix string

     Encodes data into base64. Memory allocation is done automatically.
     The encoded string will be prefixed with `prefix'.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin_prefix (int * SIZE, char
          * BASE64_STR, char * PREFIX)
     SIZE:  the size of the decoded data

     BASE64_STR:  the string to decode

     PREFIX:  a prefix string

     Decodes data from base64. Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.  The encoded is expected to start with
     prefix `prefix' and then contain base64 data.

     *Return value:*  newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str_prefix (char * STR, char
          * PREFIX)
     STR:  the string to encode

     PREFIX:  a prefix string

     Encodes a string into base64. The encoded string will be prefixed
     with `prefix'.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_str_prefix (char * STR, char
          * PREFIX)
     STR:  the string to decode

     PREFIX:  a prefix string

     Decodes a string from base64. The encoded is expected to start
     with prefix `prefix' and then contain base64 data.

     *Return value:*  newly allocated string, NULL on error.

 -- Function: char * lw6glb_sha1_hmac_80_bin (char * KEY, int KEY_SIZE,
          char * BUF, int BUF_SIZE)
     KEY:  the key buffer `key_size'

     BUF:  the data to analyse

     BUF_SIZE:  the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:*  newly allocated string, containing 20 chars
     checksum.

 -- Function: char * lw6glb_sha1_hmac_80_str (char * KEY, char * STR)
     KEY:  a key (string)

     STR:  the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:*  newly allocated string, containing 20 chars
     checksum.

 -- Function: u_int32_t lw6glb_sha1_hmac_32_bin (char * KEY, int
          KEY_SIZE, char * BUF, int BUF_SIZE)
     KEY:  the key buffer `key_size'

     BUF:  the data to analyse

     BUF_SIZE:  the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:*  a 32-bit unsigned integer

 -- Function: u_int32_t lw6glb_sha1_hmac_32_str (char * KEY, char * STR)
     KEY:  a key (string)

     STR:  the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:*  a 32-bit unsigned integer

 -- Function: int lw6glb_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `glb' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libgui,  Next: libhlp,  Prev: libglb,  Up: C API

5.21 libgui
===========

5.21.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gui/index.html'.

5.21.2 API
----------


File: liquidwar6.info,  Node: libhlp,  Next: libimg,  Prev: libgui,  Up: C API

5.22 libhlp
===========

5.22.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/hlp/index.html'.

5.22.2 API
----------

 -- Function: int lw6hlp_is_documented (char * KEYWORD)
     KEYWORD:  the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:*  1 if documented, 0 if not.

 -- Function: char * lw6hlp_about (lw6hlp_type_t * TYPE, char **
          DEFAULT_VALUE, int * MIN_VALUE, int * MAX_VALUE, char *
          KEYWORD)
     TYPE:  the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE:  the default value for the keyword, will be written

     MIN_VALUE:  the min value for the keyword, will be written

     MAX_VALUE:  the max value for the keyword, will be written

     KEYWORD:  the keyword we want help about

     Returns the documentation string associated to a keyword. The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without
     checking it. String is localized if a translation is available.
     It's safe to call this function with type or other parameters
     being NULL.

     *Return value:*  a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (char * KEYWORD)
     KEYWORD:  the keyword we want the type of

     Returns the type of a keyword. Calls lw6hlp_about internally.

     *Return value:*  the type, might be LW6HLP_TYPE_VOID.

 -- Function: char * lw6hlp_get_default_value (char * KEYWORD)
     KEYWORD:  the keyword we want the default for

     Returns the default value for a keyword. Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:*  a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (char * KEYWORD)
     KEYWORD:  the keyword we want the min for

     Returns the min value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: int lw6hlp_get_max_value (char * KEYWORD)
     KEYWORD:  the keyword we want the max for

     Returns the max value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: char * lw6hlp_get_credits (int ID)
     ID:  the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on. One can pass an arbitraty high `id', no
     risk.

     *Return value:*  the string, must be freed.

 -- Function: int lw6hlp_match (char * KEYWORD1, char * KEYWORD2)
     KEYWORD1:  the 1st keyword

     KEYWORD2:  the 2nd keyword

     Checks wether a keyword matches another. Not only a string
     comparison, will also try and guess if the error is only about
     dash "-" replaced by underscode "_", for instance.

     *Return value:*  1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list ()
     Returns a list of all available keywords.

     *Return value:*  a list containing all the keywords. Strings are
     not dynamically allocated, you can't modify them.

 -- Function: void lw6hlp_print_keyword (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list. One keyword per line.

     *Return value:*  none.

 -- Function: void lw6hlp_print_content (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file. Output is formatted to fit on the
     standard terminal/console.

     *Return value:*  none.

 -- Function: void lw6hlp_print_about (char * KEYWORD, FILE * F)
     KEYWORD:  the keyword to print help about

     F:  the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:*  none

 -- Function: int lw6hlp_reference_init ()
     Initializes the help reference, this must be called before any
     call to lw6hlp_about or such help related functions.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit ()
     un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:*  1 on success, 0 if failed

 -- Function: int lw6hlp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `hlp' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libimg,  Next: libker,  Prev: libhlp,  Up: C API

5.23 libimg
===========

5.23.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/img/index.html'.

5.23.2 API
----------

 -- Function: int lw6img_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `img' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libker,  Next: libldr,  Prev: libimg,  Up: C API

5.24 libker
===========

5.24.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ker/index.html'.

5.24.2 API
----------

 -- Function: void lw6ker_cursor_reset (lw6ker_cursor_t * CURSOR)
     CURSOR:  the cursor to reset

     Sets a cursor to defaults (disabled). This function will not touch
     the node_id and cursor_id fields, so you can call it on an already
     used cursor, it will stay usable.

     *Return value:*  none

 -- Function: lw6ker_game_state_t * lw6ker_game_state_new
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  game_struct use to construct the object

     PROGRESS:  progress indicator

     Creates a game state from a game struct. The game struct must be
     kept (never freed) while game_state is in use.

     *Return value:*  newly created object.

 -- Function: void lw6ker_game_state_free (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the object to free

     Frees a game_state object, releases all required objects. At this
     stage the map_struct must still be available.

     *Return value:*  none

 -- Function: void lw6ker_game_state_point_to (lw6ker_game_state_t *
          GAME_STATE, lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STATE:  the game_state to modify

     GAME_STRUCT:  the game_struct to point to

     This can be used when one makes a copy (dup) of a game struct and
     for some reason want the game_state to point on this new copy. Of
     course you should make the game_state point to a game_struct that
     is identical to the one that was used to construct the object in
     the first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_state_memory_footprint
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_state_repr (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: int lw6ker_game_state_can_sync (lw6ker_game_state_t *
          DST, lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Tells wether src and dst can be synced. This is not a fool proof
     function but in most cases it will raise the error, use it to
     avoid blunders. It just compares `dst' and `src' and tries to
     guess if they correspond to the same logical objects.

     *Return value:*  1 if they are syncable, 0 if not.

 -- Function: int lw6ker_game_state_sync (lw6ker_game_state_t * DST,
          lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Fundamental function, used to carbon copy a game state to another,
     this is intensively used to keep too tracks of the game state, one
     most-up-to-date but probably wrong, the one we use to display on
     the screen, and one slightly outdated (or very outdated if network
     is slow) but that we're sure of, something 100% bullet proof we can
     rely on.

     *Return value:*  1 on success, 0 on error

 -- Function: lw6ker_game_state_t * lw6ker_game_state_dup
          (lw6ker_game_state_t * GAME_STATE, lw6sys_progress_t *
          PROGRESS)
     GAME_STATE:  the game_state to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_state object. The newly created object points to
     the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_state objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_state_checksum (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to query

     Calculates the checksum of a game_state, this can be very usefull
     to make sure two states are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_state_get_shape (lw6ker_game_state_t *
          GAME_STATE, lw6sys_whd_t * SHAPE)
     GAME_STATE:  the game_state to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_state.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_get_w (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the width (shape.w) of the game_state.

     *Return value:*  the width.

 -- Function: int lw6ker_game_state_get_h (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the height (shape.h) of the game_state.

     *Return value:*  the height.

 -- Function: int lw6ker_game_state_get_d (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_state.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_state_register_node (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Registers a node in the game, this must be done, else no action
     will be allowed (such as adding a cursor or moving it). There's a
     limited number of nodes allowed, and ids must be unique.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_unregister_node
          (lw6ker_game_state_t * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Unregisters a node in the game, this must be done when a node
     leaves the game, it will free ressources and allow others to
     connect.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_node_exists (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to query

     NODE_ID:  the node to test

     Tells wether a node is present in a game.

     *Return value:*  1 if node is in game, 0 if not

 -- Function: int lw6ker_game_state_get_node_info (lw6ker_game_state_t
          * GAME_STATE, u_int16_t NODE_ID, u_int32_t *
          LAST_COMMAND_ROUND)
     GAME_STATE:  game_state to query

     NODE_ID:  the node to get info about

     LAST_COMMAND_ROUND:  the last round for which a command was issued
     (out parameter)

     Queries information about a given node, mostly, what was the last
     round we got a command.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_add_cursor (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID, int
          TEAM_COLOR)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to add

     TEAM_COLOR:  the color we wish

     Adds a cursor in a game. Note that if there's already a cursor with
     that id, it will fail, and the color is only the color we wish, we
     might indeed be attributed another color on a successfull call.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_remove_cursor (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to remove

     Removes a cursor from the game, corresponding teams will be removed
     if needed.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_cursor_exists (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor is present in the game.

     *Return value:*  1 if cursor exists, 0 if not.

 -- Function: int lw6ker_game_state_get_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR:  the cursor data (out param)

     CURSOR_ID:  the cursor to query

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_game_state_get_cursor_by_index
          (lw6ker_game_state_t * GAME_STATE, lw6ker_cursor_t * CURSOR,
          int I)
     GAME_STATE:  the game state to query

     CURSOR:  the cursor (out param)

     I:  the index

     Gets the cursor information, using its index. This is usefull to
     walk the whole cursor without knowing their ids.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_set_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR)
     GAME_STATE:  the game_state to act upon

     CURSOR:  the cursor

     Sets a cursor, that is, changes its position, this is pretty much
     anything we can do about a cursor except adding or removing it,
     just because of Liquid War very simple rules. The passed pointer
     may be freed after the call, only the `cursor_id', `node_id', `x',
     `y' and `fire' fields are used, others are ignored. More
     precisely, the `enabled' will be ignored, it's not a valid way to
     add/remove teams.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ker_game_state_team_exists (lw6ker_game_state_t *
          GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the team color to test

     Tells wether a team color is present in the game. Note that this is
     different from cursor ids.

     *Return value:*  1 if team exists, 0 if not.

 -- Function: int lw6ker_game_state_get_team_info (lw6ker_game_state_t
          * GAME_STATE, int TEAM_COLOR, int32_t * NB_CURSORS, int32_t *
          NB_FIGHTERS)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the color to get informations about

     NB_CURSORS:  number of cursors with this color (out param)

     NB_FIGHTERS:  number of fighters with this color (out param)

     Gets informations about a given color. Indeed, a color can have
     several cursors, and knowing how many fighters there are with a
     given color is probably the most important things about a color.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_get_nb_teams (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells how many teams there are in a game. This is different from
     the cursors number, there can be more cursors than teams, because
     a team can have several cursors.

     *Return value:*  the number of teams.

 -- Function: void lw6ker_game_state_do_spread (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which gradients (teams) must be
     spreaded

     Spreads the gradient, that is, calculates the potential of each
     point on the map, ie the distance to the closest cursor. The
     binary mask allows gradient to be spread for only some teams, this
     is usefull in a multithreaded context, as gradients can be
     calculated separately.

     *Return value:*  none

 -- Function: void lw6ker_game_state_do_move (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which teams must be moved

     Moves the fighters, note that you must calculate the gradient from
     time to time else they go to the wrong places. The `team_mask'
     allows the moving of only some given teams, but moving (for
     instance) even teams then odd teams isn't the same as moving odd
     teams then even teams.  Whereas as far as gradient calculation is
     concerned, this could have been true, you could have multithreaded
     that.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_finish_round (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to act upon

     Finishes a round, that is, vaccums various stuff, checks if some
     team has lost, and so on. This is complementary to the spread and
     move steps, it should be called at each round.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_do_round (lw6ker_game_state_t *
          GAME_STATE)
     game_state: the game_state to act upon

     This is a fundamental function, it's called at each round, it
     fires all the complex calculations in the game, the real core
     algorithm. Every time this function is called, the round is "over"
     and the game state is ready for the next... round. It's equivalent
     to calling the spread, move and finish functions.

     *Return value:*  none.

 -- Function: u_int32_t lw6ker_game_state_get_moves
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of moves done on this game.

     *Return value:*  number of moves.

 -- Function: u_int32_t lw6ker_game_state_get_spreads
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of spreads done on this game.

     *Return value:*  number of spreads.

 -- Function: u_int32_t lw6ker_game_state_get_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of rounds done on this game.

     *Return value:*  number of rounds.

 -- Function: u_int32_t lw6ker_game_state_get_total_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of playable rounds in the game, that is the
     number of rounds to be played if game goes up to the time limit.
     This is a fixed number, if game slows down then time is stretched,
     but the the exact maximum number of rounds is known at game start,
     and it is the number returned by this function.

     *Return value:*  number of rounds in the game

 -- Function: int lw6ker_game_state_is_over (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells wether the game is over or not. The answer depends on time
     limit, game rules, and of course what happened on the battlefield.

     *Return value:*  1 if over, 0 if not.

 -- Function: int lw6ker_game_state_did_cursor_win (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor was the winner after a game is over.

     *Return value:*  1 if cursor is in winning team, 0 if not.

 -- Function: int lw6ker_game_state_get_winner (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the winner, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the best positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the winner team number, note that it can be
     invalid (-1) if there's no winner (for example, there are no teams
     on the map).

 -- Function: int lw6ker_game_state_get_looser (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the looser, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the worst positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the looser team number, note that it can be
     invalid (-1) if there's no looser (for example, there are no teams
     on the map).

 -- Function: int32_t lw6ker_game_state_get_nb_active_fighters
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Gets the number of active fighters, this is relatively constant
     within the game, it does not change when someone looses, but it
     can vary when a new team arrives or disappears.

     *Return value:*  number of fighters.

 -- Function: int32_t lw6ker_game_state_get_time_elapsed
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time elapsed, this is not the real time you'd time
     with an atomic clock, rather the time that would have elapsed if
     game had been run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.

     *Return value:*  time elapsed, in seconds.

 -- Function: int32_t lw6ker_game_state_get_time_left
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time left, this is not the real time you'd time with
     an atomic clock, rather the time that would theorically be left is
     game was to be run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.  You shouldn't
     rely on this to know wether a game is over or not, there's another
     dedicated function for that.

     *Return value:*  time left, in seconds.

 -- Function: int32_t lw6ker_game_state_get_global_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the global,
     long term history, reflects the whole game and could be used for
     an end-game score screen.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_latest_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the latest,
     short term history, reflects the recent game evolutions and could
     be used to display an in-game monitor.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_global_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the global long term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_latest_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the latest short term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_fighter_id
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets the id of a fighter in a given position. Previous versions of
     the game used to have this declared inline static for speed, but
     the price to pay in terms of maintainability was too high: too
     much stuff from the ker module had to be kept public. This
     functions is very likely to be called often when one wants to know
     what's happening on the battlefield, to draw it, for instance. If
     there's no fighter, the id is negative, any id equal or greater
     than 0 (returned by this function) is valid.

     *Return value:*  the id of the fighter at that position.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_by_id
          (lw6ker_game_state_t * GAME_STATE, int32_t FIGHTER_ID)
     GAME_STATE:  game_state to query

     FIGHTER_ID:  the id of the fighter

     Gets a fighter by its id. Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.

     *Return value:*  pointer to the fighter with the given id.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_safe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen. More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_unsafe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: int lw6ker_game_state_get_zone_potential
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     TEAM_ID:  the team id (color)

     Gets the potential of a zone. In practice this is not needed to
     make the game function, you need not call this to know how to move
     fighters, however the information can be interesting for debugging.

     *Return value:*  the potential

 -- Function: int lw6ker_game_state_get_charge_per1000
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns the charge ratio for a given team/color. A value of 100
     means fire is enabled, more than 1000 means super-charge, under 100
     means you have to wait.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_weapon_per1000_left
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns how much of the weapon is yet to be consumed for a given
     team. More than 1000 means extra time, 1000 is standard time to be
     elapsed, 0 means it's over.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_latest_weapon
          (lw6ker_game_state_t * GAME_STATE, int * TEAM_COLOR, int *
          WEAPON_ID, int * PER1000_LEFT)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color corresponding to last weapon (out
     param)

     WEAPON_ID:  the corresponding weapon_id (out param)

     PER1000_LEFT:  how much of the weapon is yet to be spent (out
     param)

     Returns informations about the latest weapon, this is typically
     for drawing purposes, just query this and you know if you need to
     paint everything in red, green, whatever, as far as the default
     backend is concerned. In case there's no weapon, well, parameters
     are untouched. Pointers can be passed as NULL.

     *Return value:*  1 if found, 0 if not.

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_new
          (lw6map_level_t * LEVEL, lw6sys_progress_t * PROGRESS)
     LEVEL:  the level on which the game_struct is based

     PROGRESS:  progress indicator

     Creates a new game_struct from a level. The game_struct is
     different from the level in the sense that the game_struct does
     contain algorithmic specific optimizations, it's a ready-to-use
     struct desgined for execution speed, while the plain level just
     stores information.

     *Return value:*  newly allocated object

 -- Function: void lw6ker_game_struct_free (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to free

     Frees a game_struct object, releasing all required stuff. The
     source level must still be available when freeing this.

     *Return value:*  none

 -- Function: void lw6ker_game_struct_point_to (lw6ker_game_struct_t *
          GAME_STRUCT, lw6map_level_t * LEVEL)
     GAME_STRUCT:  the game_struct to modify

     LEVEL:  the level to point to

     This can be used when one makes a copy (dup) of a level and for
     some reason want the game_struct to point on this new copy. Of
     course you should make the game_struct point to a level that is
     identical to the one that was used to construct the object in the
     first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_struct_memory_footprint
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_struct_repr (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_dup
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  the game_struct to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_struct object. The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_struct objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_struct_checksum
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Calculates the checksum of a game_struct, this can be very usefull
     to make sure two structs are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_struct_get_shape (lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_whd_t * SHAPE)
     GAME_STRUCT:  the game_struct to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_struct.

     *Return value:*  none.

 -- Function: int lw6ker_game_struct_get_w (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the width (shape.w) of the game_struct.

     *Return value:*  the width.

 -- Function: int lw6ker_game_struct_get_h (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the height (shape.h) of the game_struct.

     *Return value:*  the height.

 -- Function: int lw6ker_game_struct_get_d (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_struct.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_struct_is_fg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is foreground, that is, occupied by
     a wall.

     *Return value:*  1 if foreground (wall, fighters can't move), 0 if
     not

 -- Function: int lw6ker_game_struct_is_bg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is background, that is, there's no
     wall.

     *Return value:*  1 if background (wall, fighters can move), 0 if
     not

 -- Function: void lw6ker_game_struct_get_zones_info
          (lw6ker_game_struct_t * GAME_STRUCT, int * NB_ZONES, int *
          MAX_ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     NB_ZONES:  the maximum zone size (out param, can be NULL)

     MAX_ZONE_SIZE:  the maximum zone size (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none.

 -- Function: void lw6ker_game_struct_get_zone_info
          (lw6ker_game_struct_t * GAME_STRUCT, int I, lw6sys_xyz_t *
          ZONE_POS, int * ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     I:  index of the zone to query

     ZONE_POS:  coord of the zone, top-left corner (out param, can be
     NULL)

     ZONE_SIZE:  size of the zone (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none

 -- Function: int32_t lw6ker_game_struct_get_zone_id
          (lw6ker_game_struct_t * GAME_STRUCT, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x pos

     Y:  y pos

     Z:  z pos

     Gets the zone id for a given position. The id returned can then be
     used to query for a potential, for instance.

     *Return value:*  the zone id

 -- Function: void lw6ker_game_struct_find_free_slot_near
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_xyz_t * THERE,
          lw6sys_xyz_t HERE)
     GAME_STRUCT:  the game_struct to query

     THERE:  the closest free slot (out param)

     HERE:  where we'd like to be

     Tries to find the closest free slot (there) near a given position
     (here).  This is typically used internally to find out where to
     apply the cursor when it's flying over walls.

     *Return value:*  none

 -- Function: int lw6ker_move_get_best_next_pos (lw6ker_game_state_t *
          GAME_STATE, lw6sys_xyz_t * NEXT_POS, lw6sys_xyz_t *
          CURRENT_POS, int TEAM_COLOR)
     GAME_STATE:  the game_state to work on

     NEXT_POS:  the next position (out param)

     CURRENT_POS:  the current position

     TEAM_COLOR:  the team color

     Tries to find the best move given a position and a team. Note that
     this function does not check for the presence of another fighter,
     it will only check walls and can even (sometimes) fail when there's
     a path. The reason is that it uses the game_state at a given round
     and does not recalculate gradient while a real fighter has an
     ever-changing gradient. Whatsoever, this can be used to move
     cursors like they were fighters, it's not perfect but gives a good
     illusion.

     *Return value:*  1 if best place found, 0 if not.

 -- Function: int lw6ker_score_array_update (lw6ker_score_array_t *
          SCORE_ARRAY, lw6ker_game_state_t * GAME_STATE)
     SCORE_ARRAY:  the score array to modify

     GAME_STATE:  the game_state to get the information from

     Updates a score array, that is, calculates all scores, so that they
     can be displayed, for instance.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_team_mask_get (u_int32_t * EVEN, u_int32_t *
          ODD, int32_t ROUND)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     ROUND:  round concerned

     Returns a default team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).

     *Return value:*  none.

 -- Function: void lw6ker_team_mask_best (u_int32_t * EVEN, u_int32_t *
          ODD, lw6ker_game_state_t * GAME_STATE)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     GAME_STATE:  the game_state concerned

     Returns an optimal team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance). The difference with the default team mask is that this
     one will test for which teams are present and try and manage to
     find an equilibrated set of odd/even teams.

     *Return value:*  none.

 -- Function: int lw6ker_team_mask_is_concerned (int TEAM_COLOR,
          u_int32_t TEAM_MASK)
     TEAM_COLOR:  color index

     TEAM_MASK:  team mask

     Tells wether a given team is concerned by a team mask.

     *Return value:*  1 if concerned, 0 if not.

 -- Function: int lw6ker_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ker' module test suite. Will perform deep checksums and
     *really* check many things. If this passes, the algorithm is fine.
     What could make it fail is a serious bug and/or some weird
     combination of endianess, byte alignment...

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libldr,  Next: libmap,  Prev: libker,  Up: C API

5.25 libldr
===========

5.25.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ldr/index.html'.

5.25.2 API
----------

 -- Function: int lw6ldr_body_read (lw6map_body_t * BODY, char *
          DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float RATIO, int BENCH_VALUE, int
          MAGIC_NUMBER, lw6sys_progress_t * PROGRESS)
     BODY:  the body to read, must point to allocated memory

     DIRNAME:  the directory of the map

     PARAM:  map parameters

     HINTS:  map hints

     DISPLAY_W:  the display width

     DISPLAY_H:  the display height

     RATIO:  wished map ratio

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6map_style_t * STYLE,
          lw6ldr_hints_t * HINTS)
     STYLE:  the style structure to process.

     HINTS:  additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed. The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed. Note that the background
     color itself is not changed by this function. Background can only
     be guessed from texture.

     *Return value:*  none.

 -- Function: int lw6ldr_cursor_texture_read (lw6map_cursor_texture_t *
          CURSOR_TEXTURE, char * DIRNAME)
     CURSOR_TEXTURE:  the cursor texture (out param)

     DIRNAME:  the directory we load the data form (map dir)

     Reads the cursor texture information, if not available, will use
     defaults

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ldr_free_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to free

     Frees a map entry.

     *Return value:*  none.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (char * MAP_PATH, char
          * RELATIVE_PATH, char * USER_DIR)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     Lists all maps in a given directory. Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps. Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:*  a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (char * MAP_PATH, char *
          RELATIVE_PATH, char * USER_DIR, int RECURSIVE,
          lw6sys_list_callback_func_t CALLBACK_FUNC, void * FUNC_DATA)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     RECURSIVE:  if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC:  the function which will be called on each entry

     FUNC_DATA:  an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:*  none.

 -- Function: int lw6ldr_exp_validate (lw6map_level_t * LEVEL, char *
          USER_DIR)
     LEVEL:  the level to validate

     USER_DIR:  user directory

     Validates a level, acknowledges you've won it. Upgrades exp.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_grease_apply (lw6map_layer_t * LAYER,
          lw6map_rules_t * RULES, lw6ldr_hints_t * HINTS,
          lw6sys_progress_t * PROGRESS)
     LAYER:  the layer on which to apply the grease

     RULES:  map rules

     HINTS:  map hints

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_hints_defaults (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Set the hints struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_zero (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Zeros the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_clear (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Clears the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: int lw6ldr_hints_read (lw6ldr_hints_t * HINTS, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the hints (hints.xml) of a map. Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6ldr_hints_t * HINTS, char * KEY,
          char * VALUE)
     HINTS:  the hints to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a hints structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6ldr_hints_get (lw6ldr_hints_t * HINTS, char *
          KEY)
     HINTS:  the hints to modify

     KEY:  the key to modify

     Gets one single parameter in a hints structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6ldr_hints_get_default (char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given hints key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6ldr_hints_update (lw6ldr_hints_t * HINTS,
          lw6sys_assoc_t * VALUES)
     HINTS:  the hints struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides hints with values. Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_meta_layer_read (lw6map_meta_layer_t *
          META_LAYER, char * FILENAME, int TARGET_W, int TARGET_H, int
          ANALOG)
     META_LAYER:  the meta layer to read

     FILENAME:  the file to open

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6map_meta_layer_t
          * META_LAYER, char * DIRNAME, char * FILE_ONLY, int TARGET_W,
          int TARGET_H, int ANALOG)
     META_LAYER:  the meta layer to read

     DIRNAME:  the map directory

     FILE_ONLY:  the meta-layer file name only (without the path)

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters. This function is different from
     `lw6ldr_meta_layer_read' for it will 1) concatenate `dirname' and
     `file_only' and 2) return OK (1) if file does not exist.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_param_read (lw6map_param_t * PARAM, char *
          DIRNAME)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     DIRNAME:  the directory of the map

     Read the parameters associated to a map. Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6map_param_t * PARAM,
          lw6sys_assoc_t * VALUES)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides param with values. Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:*  1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_hints_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_style_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map style.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_teams_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map teams.xml file.

     *Return value:*  none.

 -- Function: int lw6ldr_print_examples (char * USER_DIR)
     USER_DIR:  the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (char * DIRNAME,
          lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t *
          FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, char * USER_DIR, lw6sys_progress_t *
          PROGRESS)
     DIRNAME:  the directory containing the map

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Loads a map from dist. The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps. 1st, a default value is picked by
     the program.  2nd, any value in `default_param' replaces previous
     values. 3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in `forced_param' replaces previous
     values. In practice, the `default_param' allows the user to set
     defaults which can still be overwritten by the map, while
     `forced_param' is a definitive 'ignore what is is defined in the
     map' way of doing things.  See also `lw6ldr_read_relative'.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (char * MAP_PATH,
          char * RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM,
          lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H,
          int BENCH_VALUE, int MAGIC_NUMBER, char * USER_DIR,
          lw6sys_progress_t * PROGRESS)
     MAP_PATH:  a collection of paths where to find maps

     RELATIVE_PATH:  something which will be appended to a `map_path'
     member

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file. `default_param' and `forced_param'
     work as in the function `lw6ldr_read'.

     *Return value:*  1 if success, 0 if failure.

 -- Function: int lw6ldr_rules_read (lw6map_rules_t * RULES, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the rules (rules.xml) of a map. Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6map_rules_t * RULES,
          lw6sys_assoc_t * VALUES)
     RULES:  the rules struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides rules with values. Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6map_style_t * STYLE, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the style (style.xml) of a map. Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6map_style_t * STYLE, char * KEY,
          char * VALUE)
     STYLE:  the style to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a style structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6map_style_t * STYLE,
          lw6sys_assoc_t * VALUES)
     STYLE:  the style struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides style with values. Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_read (lw6map_teams_t * TEAMS, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the teams (teams.xml) of a map. Pointer to teams must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_update (lw6map_teams_t * TEAMS,
          lw6sys_assoc_t * VALUES)
     TEAMS:  the teams struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides teams with values. Pointer to teams must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing teams.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ldr' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_use_update (lw6ldr_use_t * USE, lw6sys_assoc_t
          * VALUES)
     USE:  the use struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides use with values. Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:*  1 if success, 0 if failed.


File: liquidwar6.info,  Node: libmap,  Next: libmsg,  Prev: libldr,  Up: C API

5.26 libmap
===========

5.26.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/map/index.html'.

5.26.2 API
----------

 -- Function: void lw6map_body_builtin_custom (lw6map_body_t * BODY,
          int W, int H, int D, int NOISE_PERCENT, lw6map_rules_t *
          RULES)
     BODY:  the body to initialize

     W:  the width

     H:  the height

     D:  the depth

     NOISE_PERCENT:  the noise level to fill meta layers with

     RULES:  the map rules

     Sets up a default body structure.

     *Return value:*  none

 -- Function: void lw6map_body_clear (lw6map_body_t * BODY)
     BODY:  the structure to clear

     Clears a body structure.

     *Return value:*  none.

 -- Function: void lw6map_body_fix_checksum (lw6map_body_t * BODY)
     BODY:  the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:*  none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6map_body_t *
          BODY, lw6map_rules_t * RULES)
     BODY:  the structure to update

     RULES:  the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected. If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:*  none.

 -- Function: int lw6map_body_coord_from_texture (lw6map_level_t *
          LEVEL, int * BODY_X, int * BODY_Y, int TEXTURE_X, int
          TEXTURE_Y)
     LEVEL:  the level to work on

     BODY_X:  the body (logical) x coord

     BODY_Y:  the body (logical) y coord

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:*  1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6map_level_t * LEVEL, int TEXTURE_X, int TEXTURE_Y, int Z)
     LEVEL:  the level to work on

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Z:  the z position (depth related)

     Tells wether a given map position is free or not, but using
     texture coords.

     *Return value:*  1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6map_color_couple_t * COLOR)
     COLOR:  the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:*  none.

 -- Function: int lw6map_color_is_same (lw6map_color_couple_t * COLOR1,
          lw6map_color_couple_t * COLOR2)
     COLOR1:  1st color to compare

     COLOR2:  2nd color to compare

     Compares two colors.

     *Return value:*  1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (char * KEY)
     KEY:  key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:*  an integer.

 -- Function: void lw6map_cursor_texture_clear (lw6map_cursor_texture_t
          * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Clears a cursor texture (set it all transparent).

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_builtin
          (lw6map_cursor_texture_t * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Sets a cursor texture to the builtin defauts, that is a circle
     that is black on the outside and gets white/transparent in the
     middle.

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_layer_set
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y, lw6sys_color_8_t COLOR)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to change

     X:  x coord

     Y:  y coord

     COLOR:  the color

     Sets a pixel in the cursor texture_layer.

     *Return value:*  none

 -- Function: lw6sys_color_8_t lw6map_cursor_texture_layer_get
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to query

     X:  x coord

     Y:  y coord

     Gets a pixel in the cursor texture_layer.

     *Return value:*  the color

 -- Function: lw6map_level_t * lw6map_dup (lw6map_level_t * SOURCE,
          lw6sys_progress_t * PROGRESS)
     SOURCE:  the map to copy

     PROGRESS:  to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:*  a newly allocated map, may be NULL.

 -- Function: int lw6map_exp_get_highest_color_allowed (int EXP)
     EXP:  the player experience

     Gets the highest color available for a given exp.

     *Return value:*  a color id

 -- Function: int lw6map_exp_get_highest_weapon_allowed (int EXP)
     EXP:  the player experience

     Gets the highest weapon available for a given exp.

     *Return value:*  a weapon id

 -- Function: char * lw6map_to_hexa (lw6map_level_t * LEVEL)
     Converts a map to something that is later readable by
     `lw6map_from_hexa' to reproduce the exact same map. Just a
     serializer.

     *Return value:*  a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (char * HEXA)
     HEXA:  an hexadecimal ASCII string, created by `lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     `lw6map_to_hexa'. Just an un-serializer.

     *Return value:*  a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6map_layer_t * LAYER,
          int W, int H)
     LAYER:  the layer to init

     W:  width

     H:  height

     Creates a default layer. This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:*  none

 -- Function: void lw6map_layer_clear (lw6map_layer_t * LAYER)
     LAYER:  the layer to init

     Clears a layer struct. This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:*  none

 -- Function: lw6map_level_t * lw6map_new ()
     Creates a new empty map. This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:*  a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults ()
     Creates a map, set to defaults. This is usefull mostly for testing.
     This builtin map has walls, paths, it's playable.

     *Return value:*  a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (int W, int H, int
          D, int NOISE_PERCENT)
     W:  the width of the map

     H:  the height of the map

     D:  the depth (number of layers) of the map

     NOISE_PERCENT:  percentage of noise to use for metalayers

     Creates a map, set to defaults. This is usefull mostly for testing.
     This one, unlike `lw6map_builtin_defaults'  will let you give a
     width, height and a depth.

     *Return value:*  a newly allocated map.

 -- Function: void lw6map_free (lw6map_level_t * LEVEL)
     Frees a map and releases all its internal ressources.

     *Return value:*  none.

 -- Function: int lw6map_memory_footprint (lw6map_level_t * LEVEL)
     Reports how many bytes the map needs, in memory. Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6map_level_t * LEVEL)
     Returns a string describing the map. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: int lw6map_is_same (lw6map_level_t * LEVEL_A,
          lw6map_level_t * LEVEL_B)
     LEVEL_A:  the first level to compare

     LEVEL_B:  the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:*  1 if they're the same, 0 if not.

 -- Function: int lw6map_local_info_set_music_dir (lw6map_local_info_t
          * LOCAL_INFO, char * MUSIC_DIR)
     LOCAL_INFO:  the structure to modify

     MUSIC_DIR:  the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6map_local_info_t *
          LOCAL_INFO)
     LOCAL_INFO:  the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:*  none

 -- Function: void lw6map_meta_layer_set (lw6map_meta_layer_t *
          META_LAYER, int X, int Y, u_int8_t VALUE)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     VALUE:  the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:*  none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6map_meta_layer_t *
          META_LAYER, int X, int Y)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     Simple getter for the meta_layer struct.

     *Return value:*  the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6map_meta_layer_t *
          META_LAYER)
     META_LAYER:  the meta_layer to clear

     Clears a meta_layer struct. This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:*  none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6map_meta_layer_t
          * META_LAYER, int W, int H, int ANALOG, int NOISE_PERCENT,
          int SEED)
     META_LAYER:  the object to init

     W:  width

     H:  height

     ANALOG:  wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT:  the quantity of noise to initialise the layer with

     SEED:  a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with. If noise is 100
     then metalayer is "full". If noise is 0, then meta layer is empty.

     *Return value:*  1 if OK, 0 on failure.

 -- Function: void lw6map_param_defaults (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:*  none

 -- Function: void lw6map_param_clear (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Resets a param structure to nothing. Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:*  none

 -- Function: void lw6map_param_copy (lw6map_param_t * DST,
          lw6map_param_t * SRC)
     DST:  the destination param struct

     SRC:  the source param struct

     Copies parameters. Both structures must be zeroed or correctly
     initialized.

     *Return value:*  none

 -- Function: int lw6map_param_set (lw6map_param_t * PARAM, char * KEY,
          char * VALUE)
     PARAM:  the param struct to modify

     KEY:  the name of the parameter to modify

     VALUE:  the value of the parameter to modify

     Sets an entry in a param struct. All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance. It will also dispatch
     automatically between rules, style and teams.

     *Return value:*  1 if parameter successfully set, 0 on error.

 -- Function: char * lw6map_param_get (lw6map_param_t * PARAM, char *
          KEY)
     PARAM:  the param struct to query

     KEY:  the name of the parameter to get

     Gets an entry from a param struct. All values returned as strings,
     do not use this in performance bottlenecks, this is just to export
     values to scripts, for instance.

     *Return value:*  dynamically allocated string, NULL on error,
     might return a string containing 0 on bad keys.

 -- Function: int lw6map_param_is_same (lw6map_param_t * PARAM_A,
          lw6map_param_t * PARAM_B)
     PARAM_A:  one struct to compare

     PARAM_B:  another struct to compare

     Compares the contents of two param structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: void lw6map_teams_zero (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Zeros the teams struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_defaults (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Set the teams struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_clear (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Clears the teams struct, this is not the same as setting to
     defaults.  This one supposes the struct has been properly
     initialized, at least zeroed before usage, it might contain
     pointers which should be freed.

     *Return value:*  none.

 -- Function: void lw6map_teams_copy (lw6map_teams_t * DST,
          lw6map_teams_t * SRC)
     DST:  destination

     SRC:  source

     Copies the contents of the teams struct. It's a real duplicate,
     any string is reallocated.

     *Return value:*  none.

 -- Function: int lw6map_teams_set (lw6map_teams_t * TEAMS, char * KEY,
          char * VALUE)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a teams structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6map_teams_get (lw6map_teams_t * TEAMS, char *
          KEY)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     Gets one single parameter in a teams structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6map_teams_get_default (char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given teams key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6map_teams_is_same (lw6map_teams_t * TEAMS_A,
          lw6map_teams_t * TEAMS_B)
     TEAMS_A:  one struct to compare

     TEAMS_B:  another struct to compare

     Compares the contents of two teams structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: int lw6map_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `map' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: char * lw6map_weapon_index_to_key (int INDEX)
     INDEX:  index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form,
     which can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_weapon_key_to_index (char * KEY)
     KEY:  key of the weapon, for instance "red"

     The index of the weapon, between 0 & 19

     *Return value:*  an integer.


File: liquidwar6.info,  Node: libmsg,  Next: libnet,  Prev: libmap,  Up: C API

5.27 libmsg
===========

5.27.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/msg/index.html'.

5.27.2 API
----------

 -- Function: char * lw6msg_cmd_generate_hello (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a HELLO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_ticket (lw6nod_info_t * INFO,
          u_int64_t TICKET)
     INFO:  the node info to use

     TICKET:  the ticket to send

     Generate a TICKET command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_foo (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a FOO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_bar (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a BAR command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_goodbye (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a GOODBYE command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_data (int SERIAL, int I, int
          N, int ROUND, char * KER_MSG)
     SERIAL:  the message serial number

     I:  the message index in the group

     N:  the number of messages in the group

     ROUND:  the message round (can have an offset with real round)

     KER_MSG:  the actual content of the message (passed to core algo)

     Generate a DATA command. Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_cmd_analyse_hello (lw6nod_info_t ** INFO, char
          * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a HELLO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_ticket (lw6nod_info_t ** INFO,
          u_int64_t * TICKET, char * MSG)
     INFO:  will contain (remote) node info on success

     TICKET:  if not NULL, will contain the ticket value on success

     MSG:  the message to analyse

     Analyzes a TICKET message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_foo (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a FOO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_bar (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a BAR message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_goodbye (lw6nod_info_t ** INFO,
          char * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_data (int * SERIAL, int * I, int *
          N, int * ROUND, char ** KER_MSG, char * MSG)
     SERIAL:  will contain serial number on success

     I:  will contain group index on success

     N:  will contain group size on success

     ROUND:  will contain round on success (can have an offset with
     real round)

     KER_MSG:  will contain actual message on success

     Analyzes a DATA message.

     *Return value:*  1 on success, 0 on failure

 -- Function: char * lw6msg_cmd_guess_from_url (char * MSG)
     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  the from url, if found (dynamically allocated)

 -- Function: char * lw6msg_envelope_generate (lw6msg_envelope_mode_t
          MODE, char * VERSION, char * PASSWORD_CHECKSUM, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          PHYSICAL_FROM_ID, u_int64_t PHYSICAL_TO_ID, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, char * MSG)
     MODE:  mode to use (a la TELNET or URL compatible)

     VERSION:  the program version to use (note: can be changed when
     testing)

     PASSWORD_CHECKSUM:  the password string to send

     PHYSICAL_TICKET_SIG:  the signature of the message, calculated
     with ticket + physical from/to

     LOGICAL_TICKET_SIG:  the signature of the message, calculated with
     ticket + logical from/to

     PHYSICAL_FROM_ID:  the sender id

     PHYSICAL_TO_ID:  the receiver id

     LOGICAL_FROM_ID:  the message creator id

     LOGICAL_TO_ID:  the message final destination id

     MSG:  the body of the message

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_envelope_analyse (char * ENVELOPE,
          lw6msg_envelope_mode_t MODE, char * LOCAL_URL, char *
          PASSWORD, u_int64_t EXPECTED_PHYSICAL_FROM_ID, u_int64_t
          EXPECTED_PHYSICAL_TO_ID, char ** MSG, u_int32_t *
          PHYSICAL_TICKET_SIG, u_int32_t * LOGICAL_TICKET_SIG,
          u_int64_t * PHYSICAL_FROM_ID, u_int64_t * PHYSICAL_TO_ID,
          u_int64_t * LOGICAL_FROM_ID, u_int64_t * LOGICAL_TO_ID, char
          ** PHYSICAL_FROM_URL)
     ENVELOPE:  the envelope to analyse

     MODE:  mode to use (a la TELNET or URL compatible)

     LOCAL_URL:  the url of local server (usefull for password)

     PASSWORD:  the password to check against

     EXPECTED_PHYSICAL_FROM_ID:  the sender id, if NULL, no check
     performed

     EXPECTED_PHYSICAL_TO_ID:  the receiver id, if NULL, no check
     performed

     MSG:  if not NULL, will contain body of the message

     PHYSICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     LOGICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     PHYSICAL_FROM_ID:  if not NULL, will contain sender id

     PHYSICAL_TO_ID:  if not NULL, will contain receiver id

     LOGICAL_FROM_ID:  if not NULL, will contain message creator id

     LOGICAL_TO_ID:  if not NULL, will contain message final
     destination id

     PHYSICAL_FROM_URL:  if not NULL and if message allows, will
     contain sender public URL

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_info (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the INFO question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_list (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the LIST question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed. There's a max length because we don't want the udp
     buffer to be saturated + too long lists do not really mean
     anything anyway.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_pong (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the PING question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_request (char * COMMAND, char
          * REMOTE_URL, char * PASSWORD, char * LOCAL_URL)
     COMMAND:  the command to send (PING, INFO, LIST)

     REMOTE_URL:  the remote URL (used to seed password)

     PASSWORD:  the password, can be NULL or ""

     LOCAL_URL:  the public URL to send along with the message, can be
     NULL or ""

     Generates a simple clear text OOB request, with a password if
     needed.

     *Return value:*  a newly allocated string

 -- Function: int lw6msg_oob_analyse_request (int * SYNTAX_OK, char **
          COMMAND, int * PASSWORD_OK, char ** REMOTE_URL, char *
          REQUEST, char * LOCAL_URL, char * PASSWORD)
     SYNTAX_OK:  will contain 1 if syntax is OK, 0 if not

     COMMAND:  the command (out param, needs *not* to be freed)

     PASSWORD_OK:  will contain 1 if password is OK, 0 if not

     REMOTE_URL:  the URL detected, if provided (out param, does needs
     to be freed)

     REQUEST:  the request to analyse

     LOCAL_URL:  the local url (used to seed password)

     PASSWORD:  the password to check against

     Analyses a simple OOB message of the form COMMAND <passwd> <url>.

     *Return value:*  1 if OK, 0 if not. If 0, check the value of
     password_ok.

 -- Function: char * lw6msg_oob_analyse_pong (char * TEXT)
     TEXT:  the text of the message to parse

     Analyses a PONG message and gets the public_url from it, if it
     exists.

     *Return value:*  newly allocated string containing public_url if
     OK, NULL on error.

 -- Function: int lw6msg_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: u_int32_t lw6msg_ticket_calc_sig (u_int64_t TICKET,
          u_int64_t FROM_ID, u_int64_t TO_ID, char * MSG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     Produces a little signature, which is clearly vulnerable to
     brute-force attacks but makes it possible to be 100% sure if it's
     wrong, someone is trying to do something nasty (or there's a
     serious bug!).

     *Return value:*  the sig, always non-zero

 -- Function: int lw6msg_ticket_check_sig (u_int64_t TICKET, u_int64_t
          FROM_ID, u_int64_t TO_ID, char * MSG, u_int32_t TICKET_SIG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     TICKET_SIG:  the signature to check against

     Checks a sig is OK.

     *Return value:*  1 if they are the same, 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_ptr (char ** KEY,
          char ** VALUE, char * LINE)
     KEY:  will contain the key detected

     VALUE:  will contain the value detected

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and returns the key and the
     value in the passed pointers.

     *Return value:*  1 if line OK (and in this case `key' and `value'
     are set), 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_assoc (lw6sys_assoc_t
          ** ASSOC, char * LINE)
     ASSOC:  an assoc object which will contain the result

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and sets the `assoc' parameter
     according to detected values. Note that `assoc' must be set to
     contain string, and free them automatically with
     `lw6sys_free_callback' for instance.

     *Return value:*  1 if line OK (and in this case `assoc' is
     updated), 0 if not.

 -- Function: char * lw6msg_utils_get_assoc_str_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, char * DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_utils_get_assoc_int_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, int DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over. This one will returned an int
     converted with `lw6sys_atoi'.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_word_first (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_x (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     This special `x' function will consider slash ("/") as valid
     separator. It can't be used all the time but for almost every
     field but URLs, it's fine. Internally, this one is used to parse
     integers, IDs, etc.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_base64 (lw6msg_word_t * WORD, char
          ** NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     The word is expected to be base64 encoded and is decoded
     on-the-fly.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int (int * PARSED_VALUE, char **
          NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_gt0 (int * PARSED_VALUE, char
          ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_16 (u_int16_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     16-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_32 (u_int32_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     32-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_64 (u_int64_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     64-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: char * lw6msg_z_encode (char * MSG, int LIMIT)
     MSG:  message to encode

     LIMIT:  if under this limit (length in bytes), do not encode,
     return as is

     Z-encode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     There's an optional limit *not* to encode anything, just when we
     know there are no special characters to escape and string is
     small, it's useless to fire this big artillery.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.

 -- Function: char * lw6msg_z_decode (char * MSG)
     MSG:  message to decode

     Z-decode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     This decode string does it the reverse way, un64-encode the string
     then uncompress it back to a readable string.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.


File: liquidwar6.info,  Node: libnet,  Next: libnod,  Prev: libmsg,  Up: C API

5.28 libnet
===========

5.28.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/net/index.html'.

5.28.2 API
----------

 -- Function: int lw6net_dns_is_ip (char * IP)
     IP:  the string to check

     Tests if a given string is a valid IP (IPV4). Test is only
     syntaxic, it's just to know if we're likely to need to query the
     DNS, it does not mean the IP is *really* valid.

     *Return value:*  1 if it's an IP, O if not.

 -- Function: char * lw6net_dns_gethostbyname (char * NAME)
     NAME:  name of the host

     A wrapper over the standard gethostbyname function, will even
     accept an IP as an input (in this case, will copy it...) and
     allocate a new string for the result.

     *Return value:*  an IP if success, NULL on error.

 -- Function: int lw6net_dns_lock ()
     Locks access to dns function `lw6net_dns_gethostbyname'.  This is
     because `gethostbyname' isn't reentrant plus, even if we didn't
     use it but its multithreadable equivalent (which is however not
     standard and always available) other libs (such as `libcurl' not
     to name it) might use this function too so in a general manner
     it's a good idea to use a mutex to protect multiple accesses to
     this.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_dns_unlock ()
     Unlocks access to dns function `lw6net_dns_gethostbyname'.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_last_error ()
     Reports the last network error. This is basically a debug function,
     designed mostly for Microsoft Winsock API, but can be safely called
     on any platform.

     *Return value:*  the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local ()
     Guess the local IP address. This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on. But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed. Will return NULL if interface can't
     be guessed.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (char * BIND_IP, int
          BIND_PORT)
     BIND_IP:  the IP address used to bind on

     BIND_PORT:  the IP port used to bind on

     Guess the server public url, based on `lw6net_if_guess_local'
     which tries to find a valid local IP address which is not
     loopback. This is only in case `bind_ip' is 0.0.0.0 (listen on all
     addresses) else it will just use `bind_ip' as you would expect.
     Function isn't foolproof, that's why one can override its default
     with a user settings.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (int SOCK)
     SOCK:  the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (int SOCK, char * LINE)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket,
     that is, stream oriented. The "\n" is automatically added, do not
     bother sending it.

     *Return value:*  non-zero if success

 -- Function: char * lw6net_recv_line_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: lw6sys_list_t * lw6net_recv_lines_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives several lines terminated by LF ("\n", chr(10)) or CR/LF
     ("\r\n", chr(10)chr(13)) on a UDP socket, that is, datagram
     oriented. If there's no complete line available, function returns
     immediately with NULL. Same if socket is closed, broken, whatever.
     Only if there's something consistent will the function return
     non-NULL.  By-value parameters allow the caller to know where the
     data come from. This variant of `lw6net_recv_line_tcp' will return
     a list of lines, this is mandatory since in UDP we can't call recv
     several times.

     *Return value:*  a list of dynamically allocated strings.  The
     tailing (CR)/LF is stripped from strings.

 -- Function: int lw6net_send_line_udp (int SOCK, char * LINE, char *
          IP, int PORT)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     IP:  the IP address of the target

     PORT:  the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket,
     that is, datagram oriented. The "\n" is automatically added, do
     not bother sending it.

     *Return value:*  the number of bytes sent, 0 if failure

 -- Function: int lw6net_init (int ARGC, char * [] ARGV, int NET_LOG)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     NET_LOG:  1 if you want to enable net log, 0 if not

     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:*  non-zero if success

 -- Function: void lw6net_quit ()
     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:*  void

 -- Function: int lw6net_socket_set_blocking_mode (int SOCK, int MODE)
     SOCK:  the socket to modify

     MODE:  the mode to use (1 -> blocking mode, 0 -> non-blocking)

     Sets the blocking mode of a socket, the reason we use this is that
     `ioctl' isn't portable (`ioctlsocket' on MS-Windows).

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6net_socket_is_valid (int SOCK)
     SOCK:  the socket to test

     Tells if a socket is valid or not. This does not mean the socket
     is opened/connected and/or the peer is reachable, it just checks
     the socket is a valid descriptor. In practice it's just to avoid
     copy/pasting if (sock>=0)" everywhere.

     *Return value:*  1 if valid, 0 if not

 -- Function: void lw6net_socket_close (int SOCK)
     SOCK:  the socket to close

     Closes a socket, that is, stop activity and free its descriptor.

     *Return value:*  none.

 -- Function: int lw6net_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `net' module test suite. This one could fail if some
     sockets are already bound, for instance. It's still run even in
     check-only (mode=0) mode.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libnod,  Next: libp2p,  Prev: libnet,  Up: C API

5.29 libnod
===========

5.29.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/nod/index.html'.

5.29.2 API
----------

 -- Function: void lw6nod_dyn_info_free (lw6nod_dyn_info_t * DYN_INFO)
     DYN_INFO:  the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     `lw6nod_info_dup_dyn' for instance.

     *Return value:*  none

 -- Function: lw6nod_info_t * lw6nod_info_new (char * PROGRAM, char *
          VERSION, char * CODENAME, int STAMP, u_int64_t ID, char *
          URL, char * TITLE, char * DESCRIPTION, char * PASSWORD, int
          BENCH, int OPEN_RELAY, int UPTIME, int IDLE_SCREENSHOT_SIZE,
          void * IDLE_SCREENSHOT_DATA)
     PROGRAM:  the program (normally it's liquidwar6)

     VERSION:  the version

     CODENAME:  the codename

     STAMP:  the stamp

     ID:  the node id

     URL:  the node public url

     TITLE:  the node title

     DESCRIPTION:  the node description

     PASSWORD:  the node password

     BENCH:  the node bench

     OPEN_RELAY:  open relay or not

     UPTIME:  uptime in seconds

     IDLE_SCREENSHOT_SIZE:  the size (bytes) of the image to display
     when game is idle

     IDLE_SCREENSHOT_DATA:  the data (jpeg) of the image to display
     when game is idle

     Creates a node info object. The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     `lw6nod_info_update' which can be called later.

     *Return value:*  newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6nod_info_t * INFO)
     INFO:  the node info to free

     Frees a node info object.

     *Return value:*  none

 -- Function: int lw6nod_info_lock (lw6nod_info_t * INFO)
     INFO:  the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:*  1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6nod_info_t * INFO)
     INFO:  the node info to unlock

     Unlocks a node info object, this is the compation of the
     `lw6nod_info_lock' function.

     *Return value:*  1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6nod_info_t * INFO)
     INFO:  the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values. This is what we want when the node is idle,
     not playing.

     *Return value:*  none.

 -- Function: int lw6nod_info_update (lw6nod_info_t * INFO, u_int64_t
          COMMUNITY_ID, int ROUND, char * LEVEL, int REQUIRED_BENCH,
          int NB_COLORS, int MAX_NB_COLORS, int NB_CURSORS, int
          MAX_NB_CURSORS, int NB_NODES, int MAX_NB_NODES, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     INFO:  the node info to update

     COMMUNITY_ID:  the id of the community the node belongs to

     ROUND:  the current round (can have an offset with real round
     number)

     LEVEL:  the name of the current level (map)

     REQUIRED_BENCH:  the bench required to connect

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  max number of colors allowed

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  max number of cursors allowed

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  max number of nodes allowed

     GAME_SCREENSHOT_SIZE:  size of screenshot (bytes)

     GAME_SCREENSHOT_DATA:  screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes. Call this whenever the
     node has changed some parameter. Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:*  1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6nod_info_t *
          INFO)
     INFO:  the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it,
     this is to avoid protection fault error when concurrent threads
     access this info.

     *Return value:*  newly allocated object, must be freed.

 -- Function: lw6sys_hash_t * lw6nod_info_new_discovered_nodes ()
     Creates a new hash, to be used as a discovered nodes list.  Using
     this function has the advantage of setting the hash options to
     their defaults.  We use a hash to avoid having uselessly long
     lists containing always the same node due to multiple detections.

     *Return value:*  an empty hash

 -- Function: int lw6nod_info_add_discovered_node (lw6nod_info_t *
          INFO, char * PUBLIC_URL)
     INFO:  the node info to update

     PUBLIC_URL:  the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting. We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards. This is also a good way to avoid trivial DOS attacks.

     *Return value:*  1 if OK, O if error.

 -- Function: lw6sys_list_t * lw6nod_info_pop_discovered_nodes
          (lw6nod_info_t * INFO)
     INFO:  the node info to query

     Returns a list of all discovered nodes (their public URL) and
     empties the current queue as well.

     *Return value:*  a list of dynamically allocated strings.

 -- Function: lw6sys_list_t * lw6nod_info_new_verified_nodes ()
     Creates a new list, to be filled with nodes and typically passed
     to `lw6nod_info_set_verified_nodes'. Using this function has the
     advantage of setting the listh options to their defaults.

     *Return value:*  an empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6nod_info_t * INFO,
          lw6sys_list_t * LIST)
     INFO:  the node info to modify

     LIST:  the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page. We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very
     important about this function is that `list' will be freed by
     function, that is, if you call this, then you can (you should)
     forget your object, it will disappear any time soon.

     *Return value:*  1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6nod_info_t *
          INFO, lw6sys_list_callback_func_t FUNC, void * FUNC_DATA)
     INFO:  the node info concerned

     FUNC:  the function to apply

     FUNC_DATA:  arbitrary pointer holding data to pass to function

     Calls `lw6sys_hash_map' with `func' on every member of the list of
     verified nodes. The reason there's a function for this is that it
     is very important that list object is locked when doing this.
     This function does perform a lock/unlock so it is safe.

     *Return value:*  none.

 -- Function: int lw6nod_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

