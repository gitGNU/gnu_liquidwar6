@deftypefun {int} {lw6dat_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{dat} module test suite.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_init} (lw6dat_warehouse_t * @var{warehouse}, u_int64_t @var{local_node_id})
@var{warehouse}:  object to initialize 

@var{local_node_id}:  id of local node, used to handle local messages


Initializes a warehouse object. Won't free anything, will just
erase values if they're here

@strong{Return value:}  new object, allocated dynamically
@end deftypefun

@deftypefun {lw6dat_warehouse_t *} {lw6dat_warehouse_new} (u_int64_t @var{local_node_id})
@var{local_node_id}:  id of local node, used to handle local messages


Creates a new warehouse object.

@strong{Return value:}  new object, allocated dynamically
@end deftypefun

@deftypefun {void} {lw6dat_warehouse_free} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the object to free

Frees a warehouse object.

@strong{Return value:}  new object, allocated dynamically
@end deftypefun

@deftypefun {void} {lw6dat_warehouse_clear} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the object to clear

Clears a warehouse object. Clears means emptying everything
and resetting the current seq_id to the minimal/start value.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6dat_warehouse_purge} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the object to purge

Purges a warehouse object. Purges means emptying everything
but keeping the current seq_id and the nodes list unchanged.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_get_nb_nodes} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the warehouse object to query.

Tells how many nodes are registered in the object.

@strong{Return value:}  integer, number of nodes
@end deftypefun

@deftypefun {u_int64_t} {lw6dat_warehouse_get_local_id} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the warehouse object to query.

Returns the local id.

@strong{Return value:}  64-bit id.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_get_local_serial} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  the warehouse object to query.

Returns the latest (highest) serial number given for local node.

@strong{Return value:}  integer, latest serial number
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_register_node} (lw6dat_warehouse_t * @var{warehouse}, u_int64_t @var{node_id}, int @var{serial_0})
@var{warehouse}:  object to update

@var{node_id}:  id of node to register

@var{serial_0}:  serial number of first message 

Registers a node, in practice this is automatically done when receiving
a data message but it might be interesting to do it elsewhere and force it.

@strong{Return value:}  the stack index of the registered node, <0 is invalid.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_is_node_registered} (lw6dat_warehouse_t * @var{warehouse}, u_int64_t @var{node_id})
@var{warehouse}:  object to update

@var{node_id}:  id of node to register

Tells wether a node is registered or not in our list.

@strong{Return value:}  1 if registered, 0 if not.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_put_atom_str} (lw6dat_warehouse_t * @var{warehouse}, u_int64_t @var{logical_from}, const char * @var{full_str})
@var{warehouse}:  warehouse object to use

@var{logical_from}:  from who the message came from originally

@var{full_str}:  message of the form serial i n seq from cmd

Puts an atomic string in the object, this kind of string is
typically received on the network.

@strong{Return value:}  1 on success, 0 on error
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_calc_serial_draft_and_reference} (lw6dat_warehouse_t *         @var{warehouse})
@var{warehouse}:  object to work on

The various @code{get_seq} functions can perform slowly if 
we don't pre-calculate the serial number of draft and reference
atoms. So this calculation is not within the functions themselves
but can be cached by using this function. Just call it and
after you might query the object for reference and draft info.

@strong{Return value:}  1 if some valid informations were found, else 0,
which means no interesting (complete) atoms where found, and
there's probably nothing to do yet.
@end deftypefun

@deftypefun {int} {lw6dat_warehouse_put_local_msg} (lw6dat_warehouse_t * @var{warehouse}, const char * @var{msg})
@var{warehouse}:  warehouse object to use

@var{msg}:  message

Puts a message in the object. The message will be splitted into
several atoms if needed, it can be arbitrary long.

@strong{Return value:}  1 on success, 0 on error
@end deftypefun

@deftypefun {int64_t} {lw6dat_warehouse_get_seq_min} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  object to query

Tells the lowest seq referenced in the warehouse. Does not
mean this is the lowest ever received, only we really have
no chances of going below that point, nothing is stored, either
complete or partial, below that.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int64_t} {lw6dat_warehouse_get_seq_max} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  object to query

Tells the highest seq referenced in the warehouse. Does not
mean an actual message can be built from it, only we've
got some traces of such a high seq.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int64_t} {lw6dat_warehouse_get_seq_draft} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  object to query

Tells the highest seq that can be considered as a valid draft.
This is not exactly the maximimum seq encountered, for here we
want at least one complete message and not just one chunk of
data (an atom) referring to a high seq, we want the complete
stuff. However there can be missing messages in between.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {int64_t} {lw6dat_warehouse_get_seq_reference} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  object to query

Tells the highest seq that can be considered as a reference.
Being considered as a reference means we received all messages
for this seq *and* at least one message from the following seq,
and this for every node involved. This being said, we're sure
to have the right information, nothing is missing.

@strong{Return value:}  integer.
@end deftypefun

@deftypefun {lw6sys_list_t *} {lw6dat_warehouse_get_msg_list_by_seq} (lw6dat_warehouse_t * @var{warehouse}, int64_t @var{seq_min}, int64_t @var{seq_max}, int @var{for_reference})
@var{warehouse}:  object to query

@var{seq_min}:  lowest sequence number (round or chat index)

@var{seq_max}:  highest sequence number (round or chat index)

@var{for_reference}:  set to 1 if this is for reference building else 0 for draft

Gets the list of messages for a given sequence (round or chat index),
polling all the nodes. The from and to boundaries are included.

@strong{Return value:}  a list of strings.
@end deftypefun

@deftypefun {lw6sys_list_t *} {lw6dat_warehouse_get_atom_str_list_not_sent} (lw6dat_warehouse_t *           @var{warehouse}, u_int64_t @var{logical_to})
@var{warehouse}:  object to query

@var{logical_to}:  the id of the node that we want to send data to

Returns all the messages that were not sent for the given warehouse.

@strong{Return value:}  a list of strings, containing atoms.
@end deftypefun

@deftypefun {lw6sys_list_t *} {lw6dat_warehouse_get_miss_list} (lw6dat_warehouse_t * @var{warehouse})
@var{warehouse}:  object to query

Returns a list of @code{lw6dat_miss_t} objects which contains informations about
the messages which need to be re-sent by peers. The function will always
return something, the list is not cleared if it's called several times,
so one should not poll this too often.

@strong{Return value:}  a list of pointers to @code{lw6dat_miss_t} structs, NULL on failure.
@end deftypefun

@deftypefun {void} {lw6dat_warehouse_miss_invalidate} (lw6dat_warehouse_t * @var{warehouse}, u_int64_t @var{from_id}, u_int64_t @var{to_id}, int @var{serial_min}, int @var{serial_max})
@var{warehouse}:  object to modify

@var{from_id}:  node which needs to resend data

@var{to_id}:  node which needs to get the data

@var{serial_min}:  minimum serial number to send

@var{serial_max}:  maximum serial number to send

Re-sends messages in a given serial range. Actually, does not really resend
messages, but marks them as needing to be sent again. We might, or not, have
those messages in stock, if we have them we send them, if not we just do nothing,
someone else might have them.

@strong{Return value:}  none
@end deftypefun

