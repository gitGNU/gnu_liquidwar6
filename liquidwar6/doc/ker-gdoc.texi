@deftypefun {char *} {lw6ker_capture_str} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game state to represent

Gives a string representation, an ASCII capture of the game.
This representation is suitable for debugging, typically print
it to a VT100 console.

@strong{Return value:}  dynamically allocated string.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_checksum_log_set_interval} (lw6ker_game_state_t * @var{game_state}, int @var{checksum_log_interval})
@var{game_state}:  the game_state to track

@var{checksum_log_interval}:  dump interval, if 0, feature is disabled


Debugging function used to set automatically an interval at which engine
will log a checksum automatically. This is typically to track down where
and when there starts to be a difference between two game_states that have
evolved separately.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6ker_cursor_reset} (lw6ker_cursor_t * @var{cursor})
@var{cursor}:  the cursor to reset

Sets a cursor to defaults (disabled). This function will not touch
the node_id and cursor_id fields, so you can call it on an already
used cursor, it will stay usable.

@strong{Return value:}  none
@end deftypefun

@deftypefun {lw6ker_game_state_t *} {lw6ker_game_state_new} (lw6ker_game_struct_t * @var{game_struct}, lw6sys_progress_t * @var{progress})
@var{game_struct}:  game_struct use to construct the object

@var{progress}:  progress indicator

Creates a game state from a game struct. The game struct must be kept
(never freed) while game_state is in use.

@strong{Return value:}  newly created object.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_free} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the object to free

Frees a game_state object, releases all required objects. At this stage
the map_struct must still be available.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6ker_game_state_point_to} (lw6ker_game_state_t * @var{game_state}, lw6ker_game_struct_t * @var{game_struct})
@var{game_state}:  the game_state to modify

@var{game_struct}:  the game_struct to point to

This can be used when one makes a copy (dup) of a game struct and for some
reason want the game_state to point on this new copy. Of course you should
make the game_state point to a game_struct that is identical to the one
that was used to construct the object in the first place. Use at your own
risk.

@strong{Return value:}  none
@end deftypefun

@deftypefun {int} {lw6ker_game_state_memory_footprint} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the approximative amount of memory taken by the object.

@strong{Return value:}  number of bytes (approximation)
@end deftypefun

@deftypefun {char *} {lw6ker_game_state_repr} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Gives a readable representation of the object.

@strong{Return value:}  newly allocated string, must be freed
@end deftypefun

@deftypefun {int} {lw6ker_game_state_can_sync} (lw6ker_game_state_t * @var{dst}, lw6ker_game_state_t * @var{src})
@var{dst}:  the destination game_state

@var{src}:  the source game_state

Tells wether src and dst can be synced. This is not a fool proof function
but in most cases it will raise the error, use it to avoid blunders. It
just compares @code{dst} and @code{src} and tries to guess if they correspond to the
same logical objects.

@strong{Return value:}  1 if they are syncable, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_sync} (lw6ker_game_state_t * @var{dst}, lw6ker_game_state_t * @var{src})
@var{dst}:  the destination game_state

@var{src}:  the source game_state

Fundamental function, used to carbon copy a game state to another,
this is intensively used to keep too tracks of the game state, one
most-up-to-date but probably wrong, the one we use to display on the
screen, and one slightly outdated (or very outdated if network is
slow) but that we're sure of, something 100% bullet proof we can
rely on.

@strong{Return value:}  1 on success, 0 on error
@end deftypefun

@deftypefun {lw6ker_game_state_t *} {lw6ker_game_state_dup} (lw6ker_game_state_t * @var{game_state}, lw6sys_progress_t * @var{progress})
@var{game_state}:  the game_state to copy

@var{progress}:  progress indicator

Dups (copy) a game_state object. The newly created object points to
the same game_struct but is an independant copy, you can play
a whole different game on it. In practice this is often used
to create the game_state objects for anticipation in network games.

@strong{Return value:}  newly created object
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_state_checksum} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Calculates the checksum of a game_state, this can be very usefull
to make sure two states are identicall (prevent network errors and/or
cheating).

@strong{Return value:}  32-bit checksum
@end deftypefun

@deftypefun {void} {lw6ker_game_state_get_shape} (lw6ker_game_state_t * @var{game_state}, lw6sys_whd_t * @var{shape})
@var{game_state}:  the game_state to query

@var{shape}:  the shape (out param)

Retrieves the shape (w*h*d)of the game_state.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_w} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Retrieves the width (shape.w) of the game_state.

@strong{Return value:}  the width.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_h} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Retrieves the height (shape.h) of the game_state.

@strong{Return value:}  the height.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_d} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Retrieves the depth (shape.d, AKA number of layers) of the game_state.

@strong{Return value:}  the depth.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_register_node} (lw6ker_game_state_t * @var{game_state}, u_int64_t @var{node_id})
@var{game_state}:  the game_state to act on

@var{node_id}:  the id of the node to register

Registers a node in the game, this must be done, else no action will
be allowed (such as adding a cursor or moving it). There's a limited number
of nodes allowed, and ids must be unique.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_unregister_node} (lw6ker_game_state_t * @var{game_state}, u_int64_t @var{node_id})
@var{game_state}:  the game_state to act on

@var{node_id}:  the id of the node to register

Unregisters a node in the game, this must be done when a node leaves the
game, it will free ressources and allow others to connect.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_node_exists} (lw6ker_game_state_t * @var{game_state}, u_int64_t @var{node_id})
@var{game_state}:  the game_state to query

@var{node_id}:  the node to test

Tells wether a node is present in a game.

@strong{Return value:}  1 if node is in game, 0 if not
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_node_info} (lw6ker_game_state_t *      @var{game_state}, u_int16_t @var{node_id}, u_int32_t * @var{last_command_round})
@var{game_state}:  game_state to query

@var{node_id}:  the node to get info about

@var{last_command_round}:  the last round for which a command was issued (out parameter)

Queries information about a given node, mostly, what was the last round
we got a command.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_add_cursor} (lw6ker_game_state_t * @var{game_state}, u_int64_t @var{node_id}, u_int16_t @var{cursor_id}, int @var{team_color})
@var{game_state}:  the game_state to act upon

@var{node_id}:  the node issuing the command

@var{cursor_id}:  the id of the cursor to add

@var{team_color}:  the color we wish

Adds a cursor in a game. Note that if there's already a cursor with
that id, it will fail, and the color is only the color we wish, 
we might indeed be attributed another color on a successfull call.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_remove_cursor} (lw6ker_game_state_t * @var{game_state}, u_int64_t @var{node_id}, u_int16_t @var{cursor_id})
@var{game_state}:  the game_state to act upon

@var{node_id}:  the node issuing the command

@var{cursor_id}:  the id of the cursor to remove

Removes a cursor from the game, corresponding teams will be removed
if needed.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_cursor_exists} (lw6ker_game_state_t * @var{game_state}, u_int16_t @var{cursor_id})
@var{game_state}:  the game_state to query

@var{cursor_id}:  the cursor to test

Tells wether a cursor is present in the game.

@strong{Return value:}  1 if cursor exists, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_cursor} (lw6ker_game_state_t *          @var{game_state}, lw6ker_cursor_t * @var{cursor}, u_int16_t @var{cursor_id})
@var{game_state}:  the game_state to query

@var{cursor}:  the cursor data (out param)

@var{cursor_id}:  the cursor to query


@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_get_cursor_by_index} (lw6ker_game_state_t *            @var{game_state}, lw6ker_cursor_t * @var{cursor}, int @var{i})
@var{game_state}:  the game state to query

@var{cursor}:  the cursor (out param)

@var{i}:  the index

Gets the cursor information, using its index. This is usefull to walk
the whole cursor without knowing their ids.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_set_cursor} (lw6ker_game_state_t * @var{game_state}, lw6ker_cursor_t * @var{cursor})
@var{game_state}:  the game_state to act upon

@var{cursor}:  the cursor

Sets a cursor, that is, changes its position, this is pretty much
anything we can do about a cursor except adding or removing it, just
because of Liquid War very simple rules. The passed pointer may be
freed after the call, only the @code{cursor_id}, @code{node_id}, @code{x}, @code{y} and @code{fire} fields
are used, others are ignored. More precisely, the @code{enabled} will be ignored,
it's not a valid way to add/remove teams.

@strong{Return value:}  1 on success, 0 on failure
@end deftypefun

@deftypefun {int} {lw6ker_game_state_team_exists} (lw6ker_game_state_t * @var{game_state}, int @var{team_color})
@var{game_state}:  the game_state to query

@var{team_color}:  the team color to test

Tells wether a team color is present in the game. Note that this is
different from cursor ids.

@strong{Return value:}  1 if team exists, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_team_info} (lw6ker_game_state_t *      @var{game_state}, int @var{team_color}, int32_t * @var{nb_cursors}, int32_t * @var{nb_fighters})
@var{game_state}:  the game_state to query

@var{team_color}:  the color to get informations about

@var{nb_cursors}:  number of cursors with this color (out param)

@var{nb_fighters}:  number of fighters with this color (out param)

Gets informations about a given color. Indeed, a color can have several
cursors, and knowing how many fighters there are with a given color
is probably the most important things about a color.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_nb_teams} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Tells how many teams there are in a game. This is different from the
cursors number, there can be more cursors than teams, because a team
can have several cursors.

@strong{Return value:}  the number of teams.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_do_spread} (lw6ker_game_state_t *         @var{game_state}, u_int32_t @var{team_mask})
@var{game_state}:  the game_state to act upon

@var{team_mask}:  a binary mask of which gradients (teams) must be spreaded

Spreads the gradient, that is, calculates the potential of each point
on the map, ie the distance to the closest cursor. The binary mask
allows gradient to be spread for only some teams, this is usefull
in a multithreaded context, as gradients can be calculated separately.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6ker_game_state_do_move} (lw6ker_game_state_t *       @var{game_state}, u_int32_t @var{team_mask})
@var{game_state}:  the game_state to act upon

@var{team_mask}:  a binary mask of which teams must be moved

Moves the fighters, note that you must calculate the gradient from
time to time else they go to the wrong places. The @code{team_mask} allows
the moving of only some given teams, but moving (for instance) even
teams then odd teams isn't the same as moving odd teams then even teams.
Whereas as far as gradient calculation is concerned, this could have been
true, you could have multithreaded that.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_finish_round} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to act upon

Finishes a round, that is, vaccums various stuff, checks if some team
has lost, and so on. This is complementary to the spread and move
steps, it should be called at each round.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6ker_game_state_do_round} (lw6ker_game_state_t * @var{game_state})

game_state: the game_state to act upon

This is a fundamental function, it's called at each round,
it fires all the complex calculations in the game, the
real core algorithm. Every time this function is called,
the round is "over" and the game state is ready for the
next... round. It's equivalent to calling the spread, move
and finish functions.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_state_get_moves} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the number of moves done on this game.

@strong{Return value:}  number of moves.
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_state_get_spreads} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the number of spreads done on this game.

@strong{Return value:}  number of spreads.
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_state_get_rounds} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the number of rounds done on this game.

@strong{Return value:}  number of rounds.
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_state_get_total_rounds} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the number of playable rounds in the game, that is the number
of rounds to be played if game goes up to the time limit. This is
a fixed number, if game slows down then time is stretched, but the
the exact maximum number of rounds is known at game start, and it is
the number returned by this function.

@strong{Return value:}  number of rounds in the game
@end deftypefun

@deftypefun {int} {lw6ker_game_state_is_over} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Tells wether the game is over or not. The answer depends on time limit,
game rules, and of course what happened on the battlefield.

@strong{Return value:}  1 if over, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_did_cursor_win} (lw6ker_game_state_t * @var{game_state}, u_int16_t @var{cursor_id})
@var{game_state}:  game_state to query

@var{cursor_id}:  the cursor to test

Tells wether a cursor was the winner after a game is over.

@strong{Return value:}  1 if cursor is in winning team, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_winner} (lw6ker_game_state_t * @var{game_state}, int @var{excluded_team})
@var{game_state}:  the game_state to query

@var{excluded_team}:  a team to exclude

Returns the winner, if you set excluded_team to something else
than a valid team number (for instance -1, but 0 is a valid team)
then this team will be excluded from search. This is usefull if
you want to find out who's the best positionned player while
excluding yourself, for instance if you're a bot.

@strong{Return value:}  the winner team number, note that it can be
invalid (-1) if there's no winner (for example, there are no
teams on the map).
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_looser} (lw6ker_game_state_t * @var{game_state}, int @var{excluded_team})
@var{game_state}:  the game_state to query

@var{excluded_team}:  a team to exclude

Returns the looser, if you set excluded_team to something else
than a valid team number (for instance -1, but 0 is a valid team)
then this team will be excluded from search. This is usefull if
you want to find out who's the worst positionned player while
excluding yourself, for instance if you're a bot.

@strong{Return value:}  the looser team number, note that it can be
invalid (-1) if there's no looser (for example, there are no
teams on the map).
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_nb_active_fighters} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Gets the number of active fighters, this is relatively constant within the
game, it does not change when someone looses, but it can vary when a new
team arrives or disappears.

@strong{Return value:}  number of fighters.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_time_elapsed} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the time elapsed, this is not the real time you'd time
with an atomic clock, rather the time that would have elapsed if
game had been run at its nominal speed. There can be a difference
if your computer is too slow, among other things.

@strong{Return value:}  time elapsed, in seconds.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_time_left} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  the game_state to query

Returns the time left, this is not the real time you'd time
with an atomic clock, rather the time that would theorically
be left is game was to be run at its nominal speed. There can
be a difference if your computer is too slow, among other things.
You shouldn't rely on this to know wether a game is over or not,
there's another dedicated function for that.

@strong{Return value:}  time left, in seconds.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_global_history} (lw6ker_game_state_t * @var{game_state}, int @var{i}, int @var{team_id})
@var{game_state}:  the game_state to query

@var{i}:  the index of the history point

@var{team_id}:  the team to query

Returns the number of fighters at some point in the past (the lower i,
the oldest). The history scrolls automatically and erases itself at
some point, it's of constant length. This is the global, long term
history, reflects the whole game and could be used for an end-game
score screen.

@strong{Return value:}  number of fighters at that time.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_latest_history} (lw6ker_game_state_t * @var{game_state}, int @var{i}, int @var{team_id})
@var{game_state}:  the game_state to query

@var{i}:  the index of the history point

@var{team_id}:  the team to query

Returns the number of fighters at some point in the past (the lower i,
the oldest). The history scrolls automatically and erases itself at
some point, it's of constant length. This is the latest, short term
history, reflects the recent game evolutions and could be used to
display an in-game monitor.

@strong{Return value:}  number of fighters at that time.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_global_history_max} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game_state to query

Returns the maximum value, that is, the maximum number of fighters, all teams
combined, for this history. This can be used to scale charts.
This function for the global long term history.

@strong{Return value:}  max number of fighters.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_latest_history_max} (lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game_state to query

Returns the maximum value, that is, the maximum number of fighters, all teams
combined, for this history. This can be used to scale charts.
This function for the latest short term history.

@strong{Return value:}  max number of fighters.
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_state_get_fighter_id} (lw6ker_game_state_t * @var{game_state}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_state}:  game_state to query

@var{x}:  x position

@var{y}:  y position

@var{z}:  z position

Gets the id of a fighter in a given position. Previous versions of the
game used to have this declared inline static for speed, but the price
to pay in terms of maintainability was too high: too much stuff from the
ker module had to be kept public. This functions is very likely to be
called often when one wants to know what's happening on the battlefield,
to draw it, for instance. If there's no fighter, the id is negative,
any id equal or greater than 0 (returned by this function) is valid.

@strong{Return value:}  the id of the fighter at that position.
@end deftypefun

@deftypefun {lw6ker_fighter_t *} {lw6ker_game_state_get_fighter_by_id} (lw6ker_game_state_t * @var{game_state}, int32_t @var{fighter_id})
@var{game_state}:  game_state to query

@var{fighter_id}:  the id of the fighter

Gets a fighter by its id. Internally, all fighters are stored in an array
so it could be "safe" to get fighter with id 0 then walk the array.
Previous versions of the game used to have this public (the array),
it has been hidden since.

@strong{Return value:}  pointer to the fighter with the given id.
@end deftypefun

@deftypefun {lw6ker_fighter_t *} {lw6ker_game_state_get_fighter_safe} (lw6ker_game_state_t * @var{game_state}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_state}:  game_state to query

@var{x}:  x position

@var{y}:  y position

@var{z}:  z position

Gets a fighter by its position. This function will check for boundaries, if there's
no fighter in this place, it will return NULL, but nothing worse can happen. More
precisely, if the place is in a wall, it won't bug, unlike the non-bullet-proof
equivalent of this function.

@strong{Return value:}  pointer to the fighter at this position, or NULL if none.
@end deftypefun

@deftypefun {lw6ker_fighter_t *} {lw6ker_game_state_get_fighter_unsafe} (lw6ker_game_state_t * @var{game_state}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_state}:  game_state to query

@var{x}:  x position

@var{y}:  y position

@var{z}:  z position

Gets a fighter by its position. This function will not check for boundaries, if there's
no fighter in this place, not only will it probably not return a valid value, but it will also
even segfault before that, trying to access non-existing structures in menory. So only
call this if you're sure there's a fighter here.

@strong{Return value:}  pointer to the fighter at this position, or NULL if none.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_zone_potential} (lw6ker_game_state_t * @var{game_state}, int @var{i}, int @var{team_id})
@var{game_state}:  the game_state to query

@var{team_id}:  the team id (color)

Gets the potential of a zone. In practice this is not needed to
make the game function, you need not call this to know how to move
fighters, however the information can be interesting for debugging.

@strong{Return value:}  the potential
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_charge_per1000} (lw6ker_game_state_t * @var{game_state}, int @var{team_color})
@var{game_state}:  game_state to query

@var{team_color}:  the team color to query

Returns the charge ratio for a given team/color. A value of 100
means fire is enabled, more than 1000 means super-charge, under 100
means you have to wait.

@strong{Return value:}  integer value.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_weapon_per1000_left} (lw6ker_game_state_t * @var{game_state}, int @var{team_color})
@var{game_state}:  game_state to query

@var{team_color}:  the team color to query

Returns how much of the weapon is yet to be consumed for a given
team. More than 1000 means extra time, 1000 is standard time to
be elapsed, 0 means it's over.

@strong{Return value:}  integer value.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_latest_weapon} (lw6ker_game_state_t *          @var{game_state}, int * @var{team_color}, int * @var{weapon_id}, int * @var{per1000_left})
@var{game_state}:  game_state to query

@var{team_color}:  the team color corresponding to last weapon (out param)

@var{weapon_id}:  the corresponding weapon_id (out param)

@var{per1000_left}:  how much of the weapon is yet to be spent (out param)

Returns informations about the latest weapon, this is typically
for drawing purposes, just query this and you know if you need
to paint everything in red, green, whatever, as far as the default
backend is concerned. In case there's no weapon, well, parameters
are untouched. Pointers can be passed as NULL.

@strong{Return value:}  1 if found, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_nb_colors} (const lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game state to query

Gives the max number of colors (AKA teams) that are present
in the game. This is just a simple utility/wrapper function
which is meant to be exported to Guile scripts.

@strong{Return value:}  number of colors
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_nb_cursors} (const lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game state to query

Gives the max number of cursors that are present
in the game. This is just a simple utility/wrapper function
which is meant to be exported to Guile scripts.

@strong{Return value:}  number of cursors
@end deftypefun

@deftypefun {int} {lw6ker_game_state_get_nb_nodes} (const lw6ker_game_state_t * @var{game_state})
@var{game_state}:  game state to query

Gives the max number of nodes that are present
in the game. This is just a simple utility/wrapper function
which is meant to be exported to Guile scripts.

@strong{Return value:}  number of nodes
@end deftypefun

@deftypefun {lw6ker_game_struct_t *} {lw6ker_game_struct_new} (lw6map_level_t * @var{level}, lw6sys_progress_t * @var{progress})
@var{level}:  the level on which the game_struct is based

@var{progress}:  progress indicator

Creates a new game_struct from a level. The game_struct is different from
the level in the sense that the game_struct does contain algorithmic specific
optimizations, it's a ready-to-use struct desgined for execution speed, while
the plain level just stores information.

@strong{Return value:}  newly allocated object
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_free} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to free

Frees a game_struct object, releasing all required stuff. The source
level must still be available when freeing this.

@strong{Return value:}  none
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_point_to} (lw6ker_game_struct_t * @var{game_struct}, lw6map_level_t * @var{level})
@var{game_struct}:  the game_struct to modify

@var{level}:  the level to point to

This can be used when one makes a copy (dup) of a level and for some
reason want the game_struct to point on this new copy. Of course you should
make the game_struct point to a level that is identical to the one
that was used to construct the object in the first place. Use at your own
risk.

@strong{Return value:}  none
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_memory_footprint} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Returns the approximative amount of memory taken by the object.

@strong{Return value:}  number of bytes (approximation)
@end deftypefun

@deftypefun {char *} {lw6ker_game_struct_repr} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Gives a readable representation of the object.

@strong{Return value:}  newly allocated string, must be freed
@end deftypefun

@deftypefun {lw6ker_game_struct_t *} {lw6ker_game_struct_dup} (lw6ker_game_struct_t * @var{game_struct}, lw6sys_progress_t * @var{progress})
@var{game_struct}:  the game_struct to copy

@var{progress}:  progress indicator

Dups (copy) a game_struct object. The newly created object points to
the same game_struct but is an independant copy, you can play
a whole different game on it. In practice this is often used
to create the game_struct objects for anticipation in network games.

@strong{Return value:}  newly created object
@end deftypefun

@deftypefun {u_int32_t} {lw6ker_game_struct_checksum} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Calculates the checksum of a game_struct, this can be very usefull
to make sure two structs are identicall (prevent network errors and/or
cheating).

@strong{Return value:}  32-bit checksum
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_get_shape} (lw6ker_game_struct_t * @var{game_struct}, lw6sys_whd_t * @var{shape})
@var{game_struct}:  the game_struct to query

@var{shape}:  the shape (out param)

Retrieves the shape (w*h*d)of the game_struct.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_get_w} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Retrieves the width (shape.w) of the game_struct.

@strong{Return value:}  the width.
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_get_h} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Retrieves the height (shape.h) of the game_struct.

@strong{Return value:}  the height.
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_get_d} (lw6ker_game_struct_t * @var{game_struct})
@var{game_struct}:  the game_struct to query

Retrieves the depth (shape.d, AKA number of layers) of the game_struct.

@strong{Return value:}  the depth.
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_is_fg} (lw6ker_game_struct_t * @var{game_struct}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_struct}:  the game_struct to query

@var{x}:  x position

@var{y}:  y position

@var{z}:  z position

Tests wether a given position is foreground, that is, occupied by a wall.

@strong{Return value:}  1 if foreground (wall, fighters can't move), 0 if not
@end deftypefun

@deftypefun {int} {lw6ker_game_struct_is_bg} (lw6ker_game_struct_t * @var{game_struct}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_struct}:  the game_struct to query

@var{x}:  x position

@var{y}:  y position

@var{z}:  z position

Tests wether a given position is background, that is, there's no wall.

@strong{Return value:}  1 if background (wall, fighters can move), 0 if not
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_get_zones_info} (lw6ker_game_struct_t * @var{game_struct}, int * @var{nb_zones}, int * @var{max_zone_size})
@var{game_struct}:  game_struct to query

@var{nb_zones}:  the maximum zone size (out param, can be NULL)

@var{max_zone_size}:  the maximum zone size (out param, can be NULL)

This function gets information about the internal zoning system, can
be used for debugging.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_get_zone_info} (lw6ker_game_struct_t * @var{game_struct}, int @var{i}, lw6sys_xyz_t * @var{zone_pos}, int * @var{zone_size})
@var{game_struct}:  game_struct to query

@var{i}:  index of the zone to query

@var{zone_pos}:  coord of the zone, top-left corner (out param, can be NULL)

@var{zone_size}:  size of the zone (out param, can be NULL)

This function gets information about the internal zoning system, can
be used for debugging.

@strong{Return value:}  none
@end deftypefun

@deftypefun {int32_t} {lw6ker_game_struct_get_zone_id} (lw6ker_game_struct_t * @var{game_struct}, int32_t @var{x}, int32_t @var{y}, int32_t @var{z})
@var{game_struct}:  the game_struct to query

@var{x}:  x pos

@var{y}:  y pos

@var{z}:  z pos

Gets the zone id for a given position. The id returned can then be
used to query for a potential, for instance.

@strong{Return value:}  the zone id
@end deftypefun

@deftypefun {void} {lw6ker_game_struct_find_free_slot_near} (lw6ker_game_struct_t *      @var{game_struct}, lw6sys_xyz_t * @var{there}, lw6sys_xyz_t @var{here})
@var{game_struct}:  the game_struct to query

@var{there}:  the closest free slot (out param)

@var{here}:  where we'd like to be

Tries to find the closest free slot (there) near a given position (here).
This is typically used internally to find out where to apply the cursor
when it's flying over walls.

@strong{Return value:}  none
@end deftypefun

@deftypefun {char *} {lw6ker_game_struct_to_hexa} (lw6ker_game_struct_t * @var{game_struct})
Converts a map to something that is later readable by @code{lw6ker_game_struct_from_hexa}
to reproduce the exact same map. Just a serializer.

@strong{Return value:}  a newly allocated pointer, NULL if conversion failed.
@end deftypefun

@deftypefun {lw6ker_game_struct_t *} {lw6ker_game_struct_from_hexa} (const char * @var{hexa}, lw6map_level_t * @var{level})
@var{hexa}:  an hexadecimal ASCII string, created by @code{lw6ker_game_struct_to_hexa}

@var{level}:  the level this game_struct is bounded to

Constructs a game struct from an hexadecimal string generated
by @code{lw6ker_game_struct_to_hexa}. Just an un-serializer.

@strong{Return value:}  a new map, might be NULL if string isn't correct.
@end deftypefun

@deftypefun {char *} {lw6ker_game_state_to_hexa} (lw6ker_game_state_t * @var{game_state})
Converts a map to something that is later readable by @code{lw6ker_game_state_from_hexa}
to reproduce the exact same map. Just a serializer.

@strong{Return value:}  a newly allocated pointer, NULL if conversion failed.
@end deftypefun

@deftypefun {lw6ker_game_state_t *} {lw6ker_game_state_from_hexa} (const char * @var{hexa}, lw6ker_game_struct_t * @var{game_struct})
@var{hexa}:  an hexadecimal ASCII string, created by @code{lw6ker_game_state_to_hexa}

@var{game_struct}:  the game_struct this game_state is bounded to

Constructs a game state from an hexadecimal string generated
by @code{lw6ker_game_state_to_hexa}. Just an un-serializer.

@strong{Return value:}  a new map, might be NULL if string isn't correct.
@end deftypefun

@deftypefun {int} {lw6ker_move_get_best_next_pos} (lw6ker_game_state_t * @var{game_state}, lw6sys_xyz_t * @var{next_pos}, lw6sys_xyz_t * @var{current_pos}, int @var{team_color})
@var{game_state}:  the game_state to work on

@var{next_pos}:  the next position (out param)

@var{current_pos}:  the current position

@var{team_color}:  the team color

Tries to find the best move given a position and a team. Note that
this function does not check for the presence of another fighter,
it will only check walls and can even (sometimes) fail when there's
a path. The reason is that it uses the game_state at a given
round and does not recalculate gradient while a real fighter
has an ever-changing gradient. Whatsoever, this can be
used to move cursors like they were fighters, it's not perfect
but gives a good illusion.

@strong{Return value:}  1 if best place found, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_score_array_update} (lw6ker_score_array_t * @var{score_array}, lw6ker_game_state_t * @var{game_state})
@var{score_array}:  the score array to modify

@var{game_state}:  the game_state to get the information from

Updates a score array, that is, calculates all scores, so that they
can be displayed, for instance.

@strong{Return value:}  1 on success, 0 on failure.
@end deftypefun

@deftypefun {void} {lw6ker_team_mask_get} (u_int32_t * @var{even}, u_int32_t * @var{odd}, int32_t @var{round})
@var{even}:  even team mask (out param)

@var{odd}:  odd team mask (out param)

@var{round}:  round concerned

Returns a default team mask for a given round, even and odd will contain
ready to use masks (for spread and move functions for instance).

@strong{Return value:}  none.
@end deftypefun

@deftypefun {void} {lw6ker_team_mask_best} (u_int32_t * @var{even}, u_int32_t * @var{odd}, lw6ker_game_state_t * @var{game_state})
@var{even}:  even team mask (out param)

@var{odd}:  odd team mask (out param)

@var{game_state}:  the game_state concerned

Returns an optimal team mask for a given round, even and odd will contain
ready to use masks (for spread and move functions for instance). The difference
with the default team mask is that this one will test for which teams are present
and try and manage to find an equilibrated set of odd/even teams.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {int} {lw6ker_team_mask_is_concerned} (int @var{team_color}, u_int32_t @var{team_mask})
@var{team_color}:  color index

@var{team_mask}:  team mask

Tells wether a given team is concerned by a team mask.

@strong{Return value:}  1 if concerned, 0 if not.
@end deftypefun

@deftypefun {int} {lw6ker_team_mask_color2mask} (int @var{team_color})
@var{team_color}:  color index

Gives the mask corresponding to a given color.

@strong{Return value:}  bitwise mask.
@end deftypefun

@deftypefun {int} {lw6ker_test_register} (int @var{mode})
@var{mode}:  test mode (bitmask)

Registers all tests for the libker module.
Thoses tests Will perform deep checksums
and *really* check many things. If this passes, the algorithm
is fine. What could make it fail is a serious bug and/or some
weird combination of endianess, byte alignment... *

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

@deftypefun {int} {lw6ker_test_run} (int @var{mode})
@var{mode}:  test mode (bitmask)

Runs the @code{ker} module test suite, testing most (if not all...)
functions.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

