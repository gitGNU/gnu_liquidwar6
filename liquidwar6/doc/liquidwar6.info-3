This is /home/ufoot/Home/_/liquidwar6/doc/liquidwar6.info, produced by
makeinfo version 4.13 from
/home/ufoot/Home/_/liquidwar6/doc/liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c)  2005, 2006, 2007, 2008, 2009, 2010, 2011  Christian
Mauduit <ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: libhlp,  Next: libimg,  Prev: libgui,  Up: C API

5.22 libhlp
===========

5.22.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/hlp/index.html'.

5.22.2 API
----------

 -- Function: int lw6hlp_is_documented (char * KEYWORD)
     KEYWORD:  the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:*  1 if documented, 0 if not.

 -- Function: char * lw6hlp_about (lw6hlp_type_t * TYPE, char **
          DEFAULT_VALUE, int * MIN_VALUE, int * MAX_VALUE, char *
          KEYWORD)
     TYPE:  the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE:  the default value for the keyword, will be written

     MIN_VALUE:  the min value for the keyword, will be written

     MAX_VALUE:  the max value for the keyword, will be written

     KEYWORD:  the keyword we want help about

     Returns the documentation string associated to a keyword. The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without
     checking it. String is localized if a translation is available.
     It's safe to call this function with type or other parameters
     being NULL.

     *Return value:*  a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (char * KEYWORD)
     KEYWORD:  the keyword we want the type of

     Returns the type of a keyword. Calls lw6hlp_about internally.

     *Return value:*  the type, might be LW6HLP_TYPE_VOID.

 -- Function: char * lw6hlp_get_default_value (char * KEYWORD)
     KEYWORD:  the keyword we want the default for

     Returns the default value for a keyword. Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:*  a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (char * KEYWORD)
     KEYWORD:  the keyword we want the min for

     Returns the min value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: int lw6hlp_get_max_value (char * KEYWORD)
     KEYWORD:  the keyword we want the max for

     Returns the max value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: char * lw6hlp_get_credits (int ID)
     ID:  the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on. One can pass an arbitraty high `id', no
     risk.

     *Return value:*  the string, must be freed.

 -- Function: int lw6hlp_match (char * KEYWORD1, char * KEYWORD2)
     KEYWORD1:  the 1st keyword

     KEYWORD2:  the 2nd keyword

     Checks wether a keyword matches another. Not only a string
     comparison, will also try and guess if the error is only about
     dash "-" replaced by underscode "_", for instance.

     *Return value:*  1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list_quick ()
     Returns the list of keywords concerning quick options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_doc ()
     Returns the list of keywords concerning self-documentation system.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_show ()
     Returns the list of keywords concerning the show options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_path ()
     Returns the list of keywords concerning the path options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_players ()
     Returns the list of keywords concerning the players options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_input ()
     Returns the list of keywords concerning the input options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_graphics ()
     Returns the list of keywords concerning the graphics options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_sound ()
     Returns the list of keywords concerning the sound options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_network ()
     Returns the list of keywords concerning the network options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map ()
     Returns the list of keywords concerning the map options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_rules ()
     Returns the list of keywords concerning the rules options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_hints ()
     Returns the list of keywords concerning the hints options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_style ()
     Returns the list of keywords concerning the style options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_teams ()
     Returns the list of keywords concerning the teams options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_funcs ()
     Returns the list of C-function exported to Guile.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_hooks ()
     Returns the list of hooks.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_advanced ()
     Returns the list of keywords concerning advanced options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_aliases ()
     Returns the list of command-line aliases.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_team_colors ()
     Returns the list of team_colors.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_weapons ()
     Returns the list of weapons.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list ()
     Returns the list of all available keywords.

     *Return value:*  list of static strings (can't modify them)

 -- Function: void lw6hlp_print_keyword (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list. One keyword per line.

     *Return value:*  none.

 -- Function: void lw6hlp_print_content (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file. Output is formatted to fit on the
     standard terminal/console.

     *Return value:*  none.

 -- Function: void lw6hlp_print_about (char * KEYWORD, FILE * F)
     KEYWORD:  the keyword to print help about

     F:  the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:*  none

 -- Function: int lw6hlp_reference_init ()
     Initializes the help reference, this must be called before any
     call to lw6hlp_about or such help related functions.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit ()
     un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:*  1 on success, 0 if failed

 -- Function: int lw6hlp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `hlp' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libimg,  Next: libker,  Prev: libhlp,  Up: C API

5.23 libimg
===========

5.23.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/img/index.html'.

5.23.2 API
----------

 -- Function: int lw6img_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `img' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libker,  Next: libldr,  Prev: libimg,  Up: C API

5.24 libker
===========

5.24.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ker/index.html'.

5.24.2 API
----------

 -- Function: char * lw6ker_capture_str (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  game state to represent

     Gives a string representation, an ASCII capture of the game.  This
     representation is suitable for debugging, typically print it to a
     VT100 console.

     *Return value:*  dynamically allocated string.

 -- Function: void lw6ker_cursor_reset (lw6ker_cursor_t * CURSOR)
     CURSOR:  the cursor to reset

     Sets a cursor to defaults (disabled). This function will not touch
     the node_id and cursor_id fields, so you can call it on an already
     used cursor, it will stay usable.

     *Return value:*  none

 -- Function: lw6ker_game_state_t * lw6ker_game_state_new
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  game_struct use to construct the object

     PROGRESS:  progress indicator

     Creates a game state from a game struct. The game struct must be
     kept (never freed) while game_state is in use.

     *Return value:*  newly created object.

 -- Function: void lw6ker_game_state_free (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the object to free

     Frees a game_state object, releases all required objects. At this
     stage the map_struct must still be available.

     *Return value:*  none

 -- Function: void lw6ker_game_state_point_to (lw6ker_game_state_t *
          GAME_STATE, lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STATE:  the game_state to modify

     GAME_STRUCT:  the game_struct to point to

     This can be used when one makes a copy (dup) of a game struct and
     for some reason want the game_state to point on this new copy. Of
     course you should make the game_state point to a game_struct that
     is identical to the one that was used to construct the object in
     the first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_state_memory_footprint
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_state_repr (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: int lw6ker_game_state_can_sync (lw6ker_game_state_t *
          DST, lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Tells wether src and dst can be synced. This is not a fool proof
     function but in most cases it will raise the error, use it to
     avoid blunders. It just compares `dst' and `src' and tries to
     guess if they correspond to the same logical objects.

     *Return value:*  1 if they are syncable, 0 if not.

 -- Function: int lw6ker_game_state_sync (lw6ker_game_state_t * DST,
          lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Fundamental function, used to carbon copy a game state to another,
     this is intensively used to keep too tracks of the game state, one
     most-up-to-date but probably wrong, the one we use to display on
     the screen, and one slightly outdated (or very outdated if network
     is slow) but that we're sure of, something 100% bullet proof we can
     rely on.

     *Return value:*  1 on success, 0 on error

 -- Function: lw6ker_game_state_t * lw6ker_game_state_dup
          (lw6ker_game_state_t * GAME_STATE, lw6sys_progress_t *
          PROGRESS)
     GAME_STATE:  the game_state to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_state object. The newly created object points to
     the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_state objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_state_checksum (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to query

     Calculates the checksum of a game_state, this can be very usefull
     to make sure two states are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_state_get_shape (lw6ker_game_state_t *
          GAME_STATE, lw6sys_whd_t * SHAPE)
     GAME_STATE:  the game_state to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_state.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_get_w (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the width (shape.w) of the game_state.

     *Return value:*  the width.

 -- Function: int lw6ker_game_state_get_h (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the height (shape.h) of the game_state.

     *Return value:*  the height.

 -- Function: int lw6ker_game_state_get_d (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_state.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_state_register_node (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Registers a node in the game, this must be done, else no action
     will be allowed (such as adding a cursor or moving it). There's a
     limited number of nodes allowed, and ids must be unique.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_unregister_node
          (lw6ker_game_state_t * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Unregisters a node in the game, this must be done when a node
     leaves the game, it will free ressources and allow others to
     connect.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_node_exists (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to query

     NODE_ID:  the node to test

     Tells wether a node is present in a game.

     *Return value:*  1 if node is in game, 0 if not

 -- Function: int lw6ker_game_state_get_node_info (lw6ker_game_state_t
          * GAME_STATE, u_int16_t NODE_ID, u_int32_t *
          LAST_COMMAND_ROUND)
     GAME_STATE:  game_state to query

     NODE_ID:  the node to get info about

     LAST_COMMAND_ROUND:  the last round for which a command was issued
     (out parameter)

     Queries information about a given node, mostly, what was the last
     round we got a command.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_add_cursor (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID, int
          TEAM_COLOR)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to add

     TEAM_COLOR:  the color we wish

     Adds a cursor in a game. Note that if there's already a cursor with
     that id, it will fail, and the color is only the color we wish, we
     might indeed be attributed another color on a successfull call.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_remove_cursor (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to remove

     Removes a cursor from the game, corresponding teams will be removed
     if needed.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_cursor_exists (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor is present in the game.

     *Return value:*  1 if cursor exists, 0 if not.

 -- Function: int lw6ker_game_state_get_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR:  the cursor data (out param)

     CURSOR_ID:  the cursor to query

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_game_state_get_cursor_by_index
          (lw6ker_game_state_t * GAME_STATE, lw6ker_cursor_t * CURSOR,
          int I)
     GAME_STATE:  the game state to query

     CURSOR:  the cursor (out param)

     I:  the index

     Gets the cursor information, using its index. This is usefull to
     walk the whole cursor without knowing their ids.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_set_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR)
     GAME_STATE:  the game_state to act upon

     CURSOR:  the cursor

     Sets a cursor, that is, changes its position, this is pretty much
     anything we can do about a cursor except adding or removing it,
     just because of Liquid War very simple rules. The passed pointer
     may be freed after the call, only the `cursor_id', `node_id', `x',
     `y' and `fire' fields are used, others are ignored. More
     precisely, the `enabled' will be ignored, it's not a valid way to
     add/remove teams.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ker_game_state_team_exists (lw6ker_game_state_t *
          GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the team color to test

     Tells wether a team color is present in the game. Note that this is
     different from cursor ids.

     *Return value:*  1 if team exists, 0 if not.

 -- Function: int lw6ker_game_state_get_team_info (lw6ker_game_state_t
          * GAME_STATE, int TEAM_COLOR, int32_t * NB_CURSORS, int32_t *
          NB_FIGHTERS)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the color to get informations about

     NB_CURSORS:  number of cursors with this color (out param)

     NB_FIGHTERS:  number of fighters with this color (out param)

     Gets informations about a given color. Indeed, a color can have
     several cursors, and knowing how many fighters there are with a
     given color is probably the most important things about a color.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_get_nb_teams (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells how many teams there are in a game. This is different from
     the cursors number, there can be more cursors than teams, because
     a team can have several cursors.

     *Return value:*  the number of teams.

 -- Function: void lw6ker_game_state_do_spread (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which gradients (teams) must be
     spreaded

     Spreads the gradient, that is, calculates the potential of each
     point on the map, ie the distance to the closest cursor. The
     binary mask allows gradient to be spread for only some teams, this
     is usefull in a multithreaded context, as gradients can be
     calculated separately.

     *Return value:*  none

 -- Function: void lw6ker_game_state_do_move (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which teams must be moved

     Moves the fighters, note that you must calculate the gradient from
     time to time else they go to the wrong places. The `team_mask'
     allows the moving of only some given teams, but moving (for
     instance) even teams then odd teams isn't the same as moving odd
     teams then even teams.  Whereas as far as gradient calculation is
     concerned, this could have been true, you could have multithreaded
     that.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_finish_round (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to act upon

     Finishes a round, that is, vaccums various stuff, checks if some
     team has lost, and so on. This is complementary to the spread and
     move steps, it should be called at each round.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_do_round (lw6ker_game_state_t *
          GAME_STATE)
     game_state: the game_state to act upon

     This is a fundamental function, it's called at each round, it
     fires all the complex calculations in the game, the real core
     algorithm. Every time this function is called, the round is "over"
     and the game state is ready for the next... round. It's equivalent
     to calling the spread, move and finish functions.

     *Return value:*  none.

 -- Function: u_int32_t lw6ker_game_state_get_moves
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of moves done on this game.

     *Return value:*  number of moves.

 -- Function: u_int32_t lw6ker_game_state_get_spreads
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of spreads done on this game.

     *Return value:*  number of spreads.

 -- Function: u_int32_t lw6ker_game_state_get_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of rounds done on this game.

     *Return value:*  number of rounds.

 -- Function: u_int32_t lw6ker_game_state_get_total_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of playable rounds in the game, that is the
     number of rounds to be played if game goes up to the time limit.
     This is a fixed number, if game slows down then time is stretched,
     but the the exact maximum number of rounds is known at game start,
     and it is the number returned by this function.

     *Return value:*  number of rounds in the game

 -- Function: int lw6ker_game_state_is_over (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells wether the game is over or not. The answer depends on time
     limit, game rules, and of course what happened on the battlefield.

     *Return value:*  1 if over, 0 if not.

 -- Function: int lw6ker_game_state_did_cursor_win (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor was the winner after a game is over.

     *Return value:*  1 if cursor is in winning team, 0 if not.

 -- Function: int lw6ker_game_state_get_winner (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the winner, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the best positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the winner team number, note that it can be
     invalid (-1) if there's no winner (for example, there are no teams
     on the map).

 -- Function: int lw6ker_game_state_get_looser (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the looser, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the worst positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the looser team number, note that it can be
     invalid (-1) if there's no looser (for example, there are no teams
     on the map).

 -- Function: int32_t lw6ker_game_state_get_nb_active_fighters
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Gets the number of active fighters, this is relatively constant
     within the game, it does not change when someone looses, but it
     can vary when a new team arrives or disappears.

     *Return value:*  number of fighters.

 -- Function: int32_t lw6ker_game_state_get_time_elapsed
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time elapsed, this is not the real time you'd time
     with an atomic clock, rather the time that would have elapsed if
     game had been run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.

     *Return value:*  time elapsed, in seconds.

 -- Function: int32_t lw6ker_game_state_get_time_left
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time left, this is not the real time you'd time with
     an atomic clock, rather the time that would theorically be left is
     game was to be run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.  You shouldn't
     rely on this to know wether a game is over or not, there's another
     dedicated function for that.

     *Return value:*  time left, in seconds.

 -- Function: int32_t lw6ker_game_state_get_global_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the global,
     long term history, reflects the whole game and could be used for
     an end-game score screen.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_latest_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the latest,
     short term history, reflects the recent game evolutions and could
     be used to display an in-game monitor.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_global_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the global long term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_latest_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the latest short term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_fighter_id
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets the id of a fighter in a given position. Previous versions of
     the game used to have this declared inline static for speed, but
     the price to pay in terms of maintainability was too high: too
     much stuff from the ker module had to be kept public. This
     functions is very likely to be called often when one wants to know
     what's happening on the battlefield, to draw it, for instance. If
     there's no fighter, the id is negative, any id equal or greater
     than 0 (returned by this function) is valid.

     *Return value:*  the id of the fighter at that position.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_by_id
          (lw6ker_game_state_t * GAME_STATE, int32_t FIGHTER_ID)
     GAME_STATE:  game_state to query

     FIGHTER_ID:  the id of the fighter

     Gets a fighter by its id. Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.

     *Return value:*  pointer to the fighter with the given id.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_safe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen. More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_unsafe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: int lw6ker_game_state_get_zone_potential
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     TEAM_ID:  the team id (color)

     Gets the potential of a zone. In practice this is not needed to
     make the game function, you need not call this to know how to move
     fighters, however the information can be interesting for debugging.

     *Return value:*  the potential

 -- Function: int lw6ker_game_state_get_charge_per1000
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns the charge ratio for a given team/color. A value of 100
     means fire is enabled, more than 1000 means super-charge, under 100
     means you have to wait.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_weapon_per1000_left
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns how much of the weapon is yet to be consumed for a given
     team. More than 1000 means extra time, 1000 is standard time to be
     elapsed, 0 means it's over.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_latest_weapon
          (lw6ker_game_state_t * GAME_STATE, int * TEAM_COLOR, int *
          WEAPON_ID, int * PER1000_LEFT)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color corresponding to last weapon (out
     param)

     WEAPON_ID:  the corresponding weapon_id (out param)

     PER1000_LEFT:  how much of the weapon is yet to be spent (out
     param)

     Returns informations about the latest weapon, this is typically
     for drawing purposes, just query this and you know if you need to
     paint everything in red, green, whatever, as far as the default
     backend is concerned. In case there's no weapon, well, parameters
     are untouched. Pointers can be passed as NULL.

     *Return value:*  1 if found, 0 if not.

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_new
          (lw6map_level_t * LEVEL, lw6sys_progress_t * PROGRESS)
     LEVEL:  the level on which the game_struct is based

     PROGRESS:  progress indicator

     Creates a new game_struct from a level. The game_struct is
     different from the level in the sense that the game_struct does
     contain algorithmic specific optimizations, it's a ready-to-use
     struct desgined for execution speed, while the plain level just
     stores information.

     *Return value:*  newly allocated object

 -- Function: void lw6ker_game_struct_free (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to free

     Frees a game_struct object, releasing all required stuff. The
     source level must still be available when freeing this.

     *Return value:*  none

 -- Function: void lw6ker_game_struct_point_to (lw6ker_game_struct_t *
          GAME_STRUCT, lw6map_level_t * LEVEL)
     GAME_STRUCT:  the game_struct to modify

     LEVEL:  the level to point to

     This can be used when one makes a copy (dup) of a level and for
     some reason want the game_struct to point on this new copy. Of
     course you should make the game_struct point to a level that is
     identical to the one that was used to construct the object in the
     first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_struct_memory_footprint
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_struct_repr (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_dup
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  the game_struct to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_struct object. The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_struct objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_struct_checksum
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Calculates the checksum of a game_struct, this can be very usefull
     to make sure two structs are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_struct_get_shape (lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_whd_t * SHAPE)
     GAME_STRUCT:  the game_struct to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_struct.

     *Return value:*  none.

 -- Function: int lw6ker_game_struct_get_w (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the width (shape.w) of the game_struct.

     *Return value:*  the width.

 -- Function: int lw6ker_game_struct_get_h (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the height (shape.h) of the game_struct.

     *Return value:*  the height.

 -- Function: int lw6ker_game_struct_get_d (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_struct.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_struct_is_fg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is foreground, that is, occupied by
     a wall.

     *Return value:*  1 if foreground (wall, fighters can't move), 0 if
     not

 -- Function: int lw6ker_game_struct_is_bg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is background, that is, there's no
     wall.

     *Return value:*  1 if background (wall, fighters can move), 0 if
     not

 -- Function: void lw6ker_game_struct_get_zones_info
          (lw6ker_game_struct_t * GAME_STRUCT, int * NB_ZONES, int *
          MAX_ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     NB_ZONES:  the maximum zone size (out param, can be NULL)

     MAX_ZONE_SIZE:  the maximum zone size (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none.

 -- Function: void lw6ker_game_struct_get_zone_info
          (lw6ker_game_struct_t * GAME_STRUCT, int I, lw6sys_xyz_t *
          ZONE_POS, int * ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     I:  index of the zone to query

     ZONE_POS:  coord of the zone, top-left corner (out param, can be
     NULL)

     ZONE_SIZE:  size of the zone (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none

 -- Function: int32_t lw6ker_game_struct_get_zone_id
          (lw6ker_game_struct_t * GAME_STRUCT, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x pos

     Y:  y pos

     Z:  z pos

     Gets the zone id for a given position. The id returned can then be
     used to query for a potential, for instance.

     *Return value:*  the zone id

 -- Function: void lw6ker_game_struct_find_free_slot_near
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_xyz_t * THERE,
          lw6sys_xyz_t HERE)
     GAME_STRUCT:  the game_struct to query

     THERE:  the closest free slot (out param)

     HERE:  where we'd like to be

     Tries to find the closest free slot (there) near a given position
     (here).  This is typically used internally to find out where to
     apply the cursor when it's flying over walls.

     *Return value:*  none

 -- Function: int lw6ker_move_get_best_next_pos (lw6ker_game_state_t *
          GAME_STATE, lw6sys_xyz_t * NEXT_POS, lw6sys_xyz_t *
          CURRENT_POS, int TEAM_COLOR)
     GAME_STATE:  the game_state to work on

     NEXT_POS:  the next position (out param)

     CURRENT_POS:  the current position

     TEAM_COLOR:  the team color

     Tries to find the best move given a position and a team. Note that
     this function does not check for the presence of another fighter,
     it will only check walls and can even (sometimes) fail when there's
     a path. The reason is that it uses the game_state at a given round
     and does not recalculate gradient while a real fighter has an
     ever-changing gradient. Whatsoever, this can be used to move
     cursors like they were fighters, it's not perfect but gives a good
     illusion.

     *Return value:*  1 if best place found, 0 if not.

 -- Function: int lw6ker_score_array_update (lw6ker_score_array_t *
          SCORE_ARRAY, lw6ker_game_state_t * GAME_STATE)
     SCORE_ARRAY:  the score array to modify

     GAME_STATE:  the game_state to get the information from

     Updates a score array, that is, calculates all scores, so that they
     can be displayed, for instance.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_team_mask_get (u_int32_t * EVEN, u_int32_t *
          ODD, int32_t ROUND)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     ROUND:  round concerned

     Returns a default team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).

     *Return value:*  none.

 -- Function: void lw6ker_team_mask_best (u_int32_t * EVEN, u_int32_t *
          ODD, lw6ker_game_state_t * GAME_STATE)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     GAME_STATE:  the game_state concerned

     Returns an optimal team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance). The difference with the default team mask is that this
     one will test for which teams are present and try and manage to
     find an equilibrated set of odd/even teams.

     *Return value:*  none.

 -- Function: int lw6ker_team_mask_is_concerned (int TEAM_COLOR,
          u_int32_t TEAM_MASK)
     TEAM_COLOR:  color index

     TEAM_MASK:  team mask

     Tells wether a given team is concerned by a team mask.

     *Return value:*  1 if concerned, 0 if not.

 -- Function: int lw6ker_team_mask_color2mask (int TEAM_COLOR)
     TEAM_COLOR:  color index

     Gives the mask corresponding to a given color.

     *Return value:*  bitwise mask.

 -- Function: int lw6ker_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ker' module test suite. Will perform deep checksums and
     *really* check many things. If this passes, the algorithm is fine.
     What could make it fail is a serious bug and/or some weird
     combination of endianess, byte alignment...

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libldr,  Next: libmap,  Prev: libker,  Up: C API

5.25 libldr
===========

5.25.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ldr/index.html'.

5.25.2 API
----------

 -- Function: int lw6ldr_body_read (lw6map_body_t * BODY, char *
          DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float RATIO, int BENCH_VALUE, int
          MAGIC_NUMBER, lw6sys_progress_t * PROGRESS)
     BODY:  the body to read, must point to allocated memory

     DIRNAME:  the directory of the map

     PARAM:  map parameters

     HINTS:  map hints

     DISPLAY_W:  the display width

     DISPLAY_H:  the display height

     RATIO:  wished map ratio

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6map_style_t * STYLE,
          lw6ldr_hints_t * HINTS)
     STYLE:  the style structure to process.

     HINTS:  additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed. The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed. Note that the background
     color itself is not changed by this function. Background can only
     be guessed from texture.

     *Return value:*  none.

 -- Function: int lw6ldr_cursor_texture_read (lw6map_cursor_texture_t *
          CURSOR_TEXTURE, char * DIRNAME)
     CURSOR_TEXTURE:  the cursor texture (out param)

     DIRNAME:  the directory we load the data form (map dir)

     Reads the cursor texture information, if not available, will use
     defaults

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ldr_free_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to free

     Frees a map entry.

     *Return value:*  none.

 -- Function: lw6ldr_entry_t * lw6ldr_dup_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to dup

     Dup a map entry.

     *Return value:*  newly allocated object.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (char * MAP_PATH, char
          * RELATIVE_PATH, char * USER_DIR)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     Lists all maps in a given directory. Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps. Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:*  a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (char * MAP_PATH, char *
          RELATIVE_PATH, char * USER_DIR, int RECURSIVE,
          lw6sys_list_callback_func_t CALLBACK_FUNC, void * FUNC_DATA)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     RECURSIVE:  if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC:  the function which will be called on each entry

     FUNC_DATA:  an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:*  none.

 -- Function: lw6ldr_entry_t * lw6ldr_chain_entry (char * MAP_PATH,
          char * RELATIVE_PATH, char * USER_DIR)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     Gets the next entry used in test programs.

     *Return value:*  none.

 -- Function: int lw6ldr_exp_validate (lw6map_level_t * LEVEL, char *
          USER_DIR)
     LEVEL:  the level to validate

     USER_DIR:  user directory

     Validates a level, acknowledges you've won it. Upgrades exp.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_grease_apply (lw6map_layer_t * LAYER,
          lw6map_rules_t * RULES, lw6ldr_hints_t * HINTS,
          lw6sys_progress_t * PROGRESS)
     LAYER:  the layer on which to apply the grease

     RULES:  map rules

     HINTS:  map hints

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_hints_defaults (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Set the hints struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_zero (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Zeros the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_clear (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Clears the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: int lw6ldr_hints_read (lw6ldr_hints_t * HINTS, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the hints (hints.xml) of a map. Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6ldr_hints_t * HINTS, char * KEY,
          char * VALUE)
     HINTS:  the hints to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a hints structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6ldr_hints_get (lw6ldr_hints_t * HINTS, char *
          KEY)
     HINTS:  the hints to modify

     KEY:  the key to modify

     Gets one single parameter in a hints structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6ldr_hints_get_default (char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given hints key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6ldr_hints_update (lw6ldr_hints_t * HINTS,
          lw6sys_assoc_t * VALUES)
     HINTS:  the hints struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides hints with values. Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_metadata_read (lw6map_metadata_t * METADATA,
          char * DIRNAME)
     METADATA:  structure containting read data (out param)

     DIRNAME:  map dirname (absolute path)

     Reads the metadata, will first parse metadata.xml, and if not
     available read README and guess a title from map path. When
     function returns, all fields in structure are non-NULL.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_meta_layer_read (lw6map_meta_layer_t *
          META_LAYER, char * FILENAME, int TARGET_W, int TARGET_H, int
          ANALOG)
     META_LAYER:  the meta layer to read

     FILENAME:  the file to open

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6map_meta_layer_t
          * META_LAYER, char * DIRNAME, char * FILE_ONLY, int TARGET_W,
          int TARGET_H, int ANALOG)
     META_LAYER:  the meta layer to read

     DIRNAME:  the map directory

     FILE_ONLY:  the meta-layer file name only (without the path)

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters. This function is different from
     `lw6ldr_meta_layer_read' for it will 1) concatenate `dirname' and
     `file_only' and 2) return OK (1) if file does not exist.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_param_read (lw6map_param_t * PARAM, char *
          DIRNAME)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     DIRNAME:  the directory of the map

     Read the parameters associated to a map. Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6map_param_t * PARAM,
          lw6sys_assoc_t * VALUES)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides param with values. Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:*  1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_hints_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_style_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map style.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_teams_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map teams.xml file.

     *Return value:*  none.

 -- Function: int lw6ldr_print_examples (char * USER_DIR)
     USER_DIR:  the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (char * DIRNAME,
          lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t *
          FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, char * USER_DIR, lw6sys_progress_t *
          PROGRESS)
     DIRNAME:  the directory containing the map

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Loads a map from dist. The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps. 1st, a default value is picked by
     the program.  2nd, any value in `default_param' replaces previous
     values. 3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in `forced_param' replaces previous
     values. In practice, the `default_param' allows the user to set
     defaults which can still be overwritten by the map, while
     `forced_param' is a definitive 'ignore what is is defined in the
     map' way of doing things.  See also `lw6ldr_read_relative'.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (char * MAP_PATH,
          char * RELATIVE_PATH, lw6sys_assoc_t * DEFAULT_PARAM,
          lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W, int DISPLAY_H,
          int BENCH_VALUE, int MAGIC_NUMBER, char * USER_DIR,
          lw6sys_progress_t * PROGRESS)
     MAP_PATH:  a collection of paths where to find maps

     RELATIVE_PATH:  something which will be appended to a `map_path'
     member

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file. `default_param' and `forced_param'
     work as in the function `lw6ldr_read'.

     *Return value:*  1 if success, 0 if failure.

 -- Function: void lw6ldr_resampler_init (lw6ldr_resampler_t *
          RESAMPLER, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS,
          int SOURCE_W, int SOURCE_H, int DISPLAY_W, int DISPLAY_H,
          float TARGET_RATIO, int BENCH_VALUE, int MAGIC_NUMBER, int
          EXPECTED_DEPTH, float GRAY_LEVEL)
     RESAMPLER:  resampler object to init

     PARAM:  map parameters to use

     HINTS:  loading hints

     SOURCE_W:  width of source map

     SOURCE_H:  height of source map

     DISPLAY_W:  width of source display

     DISPLAY_H:  height of source display

     TARGET_RATIO:  ratio, that is width/height of the target

     BENCH_VALUE:  rough estimation of this computer power

     MAGIC_NUMBER:  arbitrary constant, needed to calibrate speed

     EXPECTED_DEPTH:  how thick the map could be (in practice, looks
     like d in whd)

     GRAY_LEVEL:  used to estimate capacity, 1.0f is white and means
     many slots

     Initializes a resampler. There is wizardry based on the bench,
     magic number map size, gray level. This is bot bullet proof, but
     has been experience driven and is the result of many tries /
     failures and hopefully successes.  Might need tuning as the
     algorithm evolves. This is the very function that chooses the
     actual logical map size.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_force (lw6ldr_resampler_t *
          RESAMPLER, int SOURCE_W, int SOURCE_H, int TARGET_W, int
          TARGET_H)
     RESAMPLER:  resampler to set

     SOURCE_W:  source map width

     SOURCE_H:  source map height

     TARGET_W:  target map width

     TARGET_H:  target map height

     Initializes a resampler with hardcoded values, does not calibrate
     according to context, simply set it to rescale the size you want.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_source2target (lw6ldr_resampler_t *
          RESAMPLER, int * TARGET_X, int * TARGET_Y, int SOURCE_X, int
          SOURCE_Y)
     TARGET_X:  target x coordinate (out param)

     TARGET_Y:  target y coordinate (out param)

     SOURCE_X:  source x coordinate (in param)

     SOURCE_Y:  source y coordinate (in param)

     Transforms from source coordinate to target coordinates.  Does
     rounding fine-tuning, it's not a simple integer division.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_target2source (lw6ldr_resampler_t *
          RESAMPLER, int * SOURCE_X, int * SOURCE_Y, int TARGET_X, int
          TARGET_Y)
     SOURCE_X:  source x coordinate (out param)

     SOURCE_Y:  source y coordinate (out param)

     TARGET_X:  target x coordinate (in param)

     TARGET_Y:  target y coordinate (in param)

     Transforms from target coordinate to source coordinates.  Yes,
     target to source. Target is our final logical map, source is what
     we loaded from disk, here we want to know, given a point in the
     target, where to fetch its data from source.  Does rounding
     fine-tuning, it's not a simple integer division.

     *Return value:*  none.

 -- Function: int lw6ldr_rules_read (lw6map_rules_t * RULES, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the rules (rules.xml) of a map. Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6map_rules_t * RULES,
          lw6sys_assoc_t * VALUES)
     RULES:  the rules struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides rules with values. Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6map_style_t * STYLE, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the style (style.xml) of a map. Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6map_style_t * STYLE, char * KEY,
          char * VALUE)
     STYLE:  the style to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a style structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6map_style_t * STYLE,
          lw6sys_assoc_t * VALUES)
     STYLE:  the style struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides style with values. Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_read (lw6map_teams_t * TEAMS, char *
          DIRNAME)
     DIRNAME:  the directory of the map

     Read the teams (teams.xml) of a map. Pointer to teams must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_update (lw6map_teams_t * TEAMS,
          lw6sys_assoc_t * VALUES)
     TEAMS:  the teams struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides teams with values. Pointer to teams must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing teams.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ldr' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_texture_read (lw6map_texture_t * TEXTURE, char
          * DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS,
          int USE_TEXTURE, int DISPLAY_W, int DISPLAY_H, float * RATIO,
          int * TEXTURE_EXISTS, lw6sys_progress_t * PROGRESS)
     TEXTURE:  structure to hold read data

     DIRNAME:  map dirname (absolute path)

     PARAM:  parameters to use

     HINTS:  loading hints to use

     USE_TEXTURE:  wether to use texture.png

     DISPLAY_W:  display width

     DISPLAY_H:  display height

     RATIO:  target width/height factor (out param)

     TEXTURE_EXISTS:  true if texture.png is here (out param)

     PROGRESS:  progress indicator (in/out param)

     Read the texture associated to a map. Pointer to texture must be
     valid, it's modified in-place. The function will automatically
     figure out if texture.png exists or if we must use
     foreground.png/background.png.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ldr_use_defaults (lw6ldr_use_t * USE)
     USE:  struct to initialize

     Sets the use structure to its defaults, this structure being used
     to now wether we should use texture, cursor textures, rules,
     hints, style, teams and music.

     *Return value:*  none.

 -- Function: void lw6ldr_use_clear (lw6ldr_use_t * USE)
     USE:  struct to clear

     Clears the use structure, set it to the use nothing mode.

     *Return value:*  none.

 -- Function: int lw6ldr_use_set (lw6ldr_use_t * USE, char * KEY, char
          * VALUE)
     USE:  struct to modify

     KEY:  key to change (as a string)

     VALUE:  value to set (as a string)

     Sets a key to the given value, OK all fields are integer, this is
     just a convenient function to be called in more general functions
     which are fed with those string pointers, typically coming from an
     XML file.

     *Return value:*  1 on success, 0 on failure (key not found).

 -- Function: int lw6ldr_use_update (lw6ldr_use_t * USE, lw6sys_assoc_t
          * VALUES)
     USE:  the use struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides use with values. Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:*  1 if success, 0 if failed.


File: liquidwar6.info,  Node: libmap,  Next: libmsg,  Prev: libldr,  Up: C API

5.26 libmap
===========

5.26.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/map/index.html'.

5.26.2 API
----------

 -- Function: void lw6map_body_builtin_custom (lw6map_body_t * BODY,
          int W, int H, int D, int NOISE_PERCENT, lw6map_rules_t *
          RULES)
     BODY:  the body to initialize

     W:  the width

     H:  the height

     D:  the depth

     NOISE_PERCENT:  the noise level to fill meta layers with

     RULES:  the map rules

     Sets up a default body structure.

     *Return value:*  none

 -- Function: void lw6map_body_clear (lw6map_body_t * BODY)
     BODY:  the structure to clear

     Clears a body structure.

     *Return value:*  none.

 -- Function: void lw6map_body_fix_checksum (lw6map_body_t * BODY)
     BODY:  the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:*  none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6map_body_t *
          BODY, lw6map_rules_t * RULES)
     BODY:  the structure to update

     RULES:  the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected. If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:*  none.

 -- Function: int lw6map_body_coord_from_texture (lw6map_level_t *
          LEVEL, int * BODY_X, int * BODY_Y, int TEXTURE_X, int
          TEXTURE_Y)
     LEVEL:  the level to work on

     BODY_X:  the body (logical) x coord

     BODY_Y:  the body (logical) y coord

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:*  1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6map_level_t * LEVEL, int TEXTURE_X, int TEXTURE_Y, int Z)
     LEVEL:  the level to work on

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Z:  the z position (depth related)

     Tells wether a given map position is free or not, but using
     texture coords.

     *Return value:*  1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6map_color_couple_t * COLOR)
     COLOR:  the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:*  none.

 -- Function: int lw6map_color_is_same (lw6map_color_couple_t * COLOR1,
          lw6map_color_couple_t * COLOR2)
     COLOR1:  1st color to compare

     COLOR2:  2nd color to compare

     Compares two colors.

     *Return value:*  1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (char * KEY)
     KEY:  key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:*  an integer.

 -- Function: char * lw6map_team_color_index_to_label (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used to display information to players.

     *Return value:*  a string, must *not* be freed.

 -- Function: void lw6map_cursor_texture_clear (lw6map_cursor_texture_t
          * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Clears a cursor texture (set it all transparent).

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_builtin
          (lw6map_cursor_texture_t * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Sets a cursor texture to the builtin defauts, that is a circle
     that is black on the outside and gets white/transparent in the
     middle.

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_layer_set
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y, lw6sys_color_8_t COLOR)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to change

     X:  x coord

     Y:  y coord

     COLOR:  the color

     Sets a pixel in the cursor texture_layer.

     *Return value:*  none

 -- Function: lw6sys_color_8_t lw6map_cursor_texture_layer_get
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to query

     X:  x coord

     Y:  y coord

     Gets a pixel in the cursor texture_layer.

     *Return value:*  the color

 -- Function: lw6map_level_t * lw6map_dup (lw6map_level_t * SOURCE,
          lw6sys_progress_t * PROGRESS)
     SOURCE:  the map to copy

     PROGRESS:  to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:*  a newly allocated map, may be NULL.

 -- Function: int lw6map_exp_get_highest_team_color_allowed (int EXP)
     EXP:  the player experience

     Gets the highest color available for a given exp.

     *Return value:*  a color id

 -- Function: int lw6map_exp_get_highest_weapon_allowed (int EXP)
     EXP:  the player experience

     Gets the highest weapon available for a given exp.

     *Return value:*  a weapon id

 -- Function: int lw6map_exp_is_team_color_allowed (lw6map_rules_t *
          RULES, int TEAM_COLOR_ID)
     RULES:  set of rules to use

     TEAM_COLOR_ID:  color id to test

     Tests wether a team color is allowed for a given set of rules.

     *Return value:*  1 if allowed, 0 if not.

 -- Function: int lw6map_exp_is_weapon_allowed (lw6map_rules_t * RULES,
          int WEAPON_ID)
     RULES:  set of rules to use

     WEAPON_ID:  weapon id to test

     Tests wether a weapon is allowed for a given set of rules.

     *Return value:*  1 if allowed, 0 if not.

 -- Function: int lw6map_exp_get_unlocked_team_color (int EXP)
     EXP:  exp to test

     Get the unlocked team color for a given exp, if applyable.

     *Return value:*  -1 if nothing unlocked, else the team color

 -- Function: int lw6map_exp_get_unlocked_weapon (int EXP)
     EXP:  exp to test

     Get the unlocked primary weapon for a given exp, if applyable.

     *Return value:*  -1 if nothing unlocked, else the weapon id

 -- Function: char * lw6map_to_hexa (lw6map_level_t * LEVEL)
     Converts a map to something that is later readable by
     `lw6map_from_hexa' to reproduce the exact same map. Just a
     serializer.

     *Return value:*  a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (char * HEXA)
     HEXA:  an hexadecimal ASCII string, created by `lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     `lw6map_to_hexa'. Just an un-serializer.

     *Return value:*  a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6map_layer_t * LAYER,
          int W, int H)
     LAYER:  the layer to init

     W:  width

     H:  height

     Creates a default layer. This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:*  none

 -- Function: void lw6map_layer_clear (lw6map_layer_t * LAYER)
     LAYER:  the layer to init

     Clears a layer struct. This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:*  none

 -- Function: lw6map_level_t * lw6map_new ()
     Creates a new empty map. This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:*  a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults ()
     Creates a map, set to defaults. This is usefull mostly for testing.
     This builtin map has walls, paths, it's playable.

     *Return value:*  a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (int W, int H, int
          D, int NOISE_PERCENT)
     W:  the width of the map

     H:  the height of the map

     D:  the depth (number of layers) of the map

     NOISE_PERCENT:  percentage of noise to use for metalayers

     Creates a map, set to defaults. This is usefull mostly for testing.
     This one, unlike `lw6map_builtin_defaults'  will let you give a
     width, height and a depth.

     *Return value:*  a newly allocated map.

 -- Function: void lw6map_free (lw6map_level_t * LEVEL)
     Frees a map and releases all its internal ressources.

     *Return value:*  none.

 -- Function: int lw6map_memory_footprint (lw6map_level_t * LEVEL)
     Reports how many bytes the map needs, in memory. Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6map_level_t * LEVEL)
     Returns a string describing the map. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: int lw6map_is_same (lw6map_level_t * LEVEL_A,
          lw6map_level_t * LEVEL_B)
     LEVEL_A:  the first level to compare

     LEVEL_B:  the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:*  1 if they're the same, 0 if not.

 -- Function: int lw6map_local_info_set_music_dir (lw6map_local_info_t
          * LOCAL_INFO, char * MUSIC_DIR)
     LOCAL_INFO:  the structure to modify

     MUSIC_DIR:  the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6map_local_info_t *
          LOCAL_INFO)
     LOCAL_INFO:  the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:*  none

 -- Function: void lw6map_metadata_defaults (lw6map_metadata_t *
          METADATA)
     METADATA:  struct to set to defaults

     Sets the metadata struct to defaults, this does not set fields to
     NULL/empty values, but rather fills it with data claiming, for
     instance, that this is a default map.

     *Return value:*  none.

 -- Function: void lw6map_metadata_clear (lw6map_metadata_t * METADATA)
     METADATA:  struct to clear

     Clears a metadata, will expect it to be in a consistent state,
     that is either filled with proper values or completely zeroed.

     *Return value:*  none.

 -- Function: int lw6map_metadata_is_same (lw6map_metadata_t *
          METADATA_A, lw6map_metadata_t * METADATA_B)
     METADATA_A:  first item to compare

     METADATA_B:  second item to compare

     Tells wether both metadata items contain the same values.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_meta_layer_set (lw6map_meta_layer_t *
          META_LAYER, int X, int Y, u_int8_t VALUE)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     VALUE:  the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:*  none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6map_meta_layer_t *
          META_LAYER, int X, int Y)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     Simple getter for the meta_layer struct.

     *Return value:*  the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6map_meta_layer_t *
          META_LAYER)
     META_LAYER:  the meta_layer to clear

     Clears a meta_layer struct. This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:*  none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6map_meta_layer_t
          * META_LAYER, int W, int H, int ANALOG, int NOISE_PERCENT,
          int SEED)
     META_LAYER:  the object to init

     W:  width

     H:  height

     ANALOG:  wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT:  the quantity of noise to initialise the layer with

     SEED:  a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with. If noise is 100
     then metalayer is "full". If noise is 0, then meta layer is empty.

     *Return value:*  1 if OK, 0 on failure.

 -- Function: void lw6map_param_defaults (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:*  none

 -- Function: void lw6map_param_clear (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Resets a param structure to nothing. Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:*  none

 -- Function: void lw6map_param_copy (lw6map_param_t * DST,
          lw6map_param_t * SRC)
     DST:  the destination param struct

     SRC:  the source param struct

     Copies parameters. Both structures must be zeroed or correctly
     initialized.

     *Return value:*  none

 -- Function: int lw6map_param_set (lw6map_param_t * PARAM, char * KEY,
          char * VALUE)
     PARAM:  the param struct to modify

     KEY:  the name of the parameter to modify

     VALUE:  the value of the parameter to modify

     Sets an entry in a param struct. All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance. It will also dispatch
     automatically between rules, style and teams.

     *Return value:*  1 if parameter successfully set, 0 on error.

 -- Function: char * lw6map_param_get (lw6map_param_t * PARAM, char *
          KEY)
     PARAM:  the param struct to query

     KEY:  the name of the parameter to get

     Gets an entry from a param struct. All values returned as strings,
     do not use this in performance bottlenecks, this is just to export
     values to scripts, for instance.

     *Return value:*  dynamically allocated string, NULL on error,
     might return a string containing 0 on bad keys.

 -- Function: int lw6map_param_is_same (lw6map_param_t * PARAM_A,
          lw6map_param_t * PARAM_B)
     PARAM_A:  one struct to compare

     PARAM_B:  another struct to compare

     Compares the contents of two param structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: void lw6map_rules_defaults (lw6map_rules_t * RULES)
     RULES:  struct to set to defaults

     Set rules to default values, as these are all integers, you can
     call this on any rules object.

     *Return value:*  none.

 -- Function: void lw6map_rules_copy (lw6map_rules_t * DST,
          lw6map_rules_t * SRC)
     DST:  destination (out param)

     SRC:  source (in param)

     Copies the data from source to destination, simple wrapper on
     memcpy.

     *Return value:*  none.

 -- Function: void lw6map_rules_update_checksum (lw6map_rules_t *
          RULES, u_int32_t * CHECKSUM)
     RULES:  rules struct to check

     CHECKSUM:  checksum to update (in/out param)

     Updates a checksum with the rules data.

     *Return value:*  none.

 -- Function: int32_t lw6map_rules_get_default (char * KEY)
     KEY:  key to query

     Get the default value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_min (char * KEY)
     KEY:  key to query

     Get the min value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_max (char * KEY)
     KEY:  key to query

     Get the min value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_int (lw6map_rules_t * RULES,
          char * KEY)
     RULES:  struct to use

     KEY:  key to query

     Get the value for a given string key, as an integer. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int lw6map_rules_set_int (lw6map_rules_t * RULES, char *
          KEY, int32_t VALUE)
     RULES:  struct to use

     KEY:  key to set

     VALUE:  new integer value for key

     Set the value for a given string key, as an integer. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  1 on success, 0 on failure (eg key not found)

 -- Function: int lw6map_rules_get_bool (lw6map_rules_t * RULES, char *
          KEY)
     RULES:  struct to use

     KEY:  key to query

     Get the value for a given string key, as a boolean. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  boolean.

 -- Function: int lw6map_rules_set_bool (lw6map_rules_t * RULES, char *
          KEY, int VALUE)
     RULES:  struct to use

     KEY:  key to set

     VALUE:  new boolean value for key

     Set the value for a given string key, as a boolean. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  1 on success, 0 on failure (eg key not found)

 -- Function: void lw6map_rules_clear (lw6map_rules_t * RULES)
     RULES:  struct to init

     Set rules to 0, this is not defaults, this is 0 (probably unusable
     as a real-world setting).

     *Return value:*  none.

 -- Function: int lw6map_rules_is_same (lw6map_rules_t * RULES_A,
          lw6map_rules_t * RULES_B)
     RULES_A:  first item to compare

     RULES_B:  second item to compare

     Compares two rules items. Will tell if they contain the same data.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_style_zero (lw6map_style_t * STYLE)
     STYLE:  struct to initialize

     Sets a style struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:*  none.

 -- Function: void lw6map_style_defaults (lw6map_style_t * STYLE)
     STYLE:  struct to modify

     Sets a style struct to defaults values, expects the object to be
     in a consistent style, that's to say either containing real data
     or being zeroed.

     *Return value:*  none.

 -- Function: void lw6map_style_clear (lw6map_style_t * STYLE)
     STYLE:  struct to clear

     Clears a style struct. This function won't work on an unitialized
     structure, structure must be zeroed by some CALLOC or something,
     else automatic freeing of pointers will fail.

     *Return value:*  none.

 -- Function: void lw6map_style_copy (lw6map_style_t * DST,
          lw6map_style_t * SRC)
     DST:  destination

     SRC:  source

     Copies style data from source to destination.  Like with clear,
     `dst' must be either initialized or totally zeroed, else function
     will fail (core dump)

     *Return value:*  none.

 -- Function: int lw6map_style_set (lw6map_style_t * STYLE, char * KEY,
          char * VALUE)
     STYLE:  style struct to modify (out param)

     KEY:  key to use

     VALUE:  value to use

     Sets a style entry, takes string values and will identify the
     struct offset and convert the value to whatever C type is needed.

     *Return value:*  1 on success, 0 on failure (key not found)

 -- Function: char * lw6map_style_get (lw6map_style_t * STYLE, char *
          KEY)
     STYLE:  style struct to query

     KEY:  key to use

     Get a style entry, takes a string key and will identify the struct
     offset. The return value is converted to string, typically the
     cannonical representation suitable to write in an XML config file.

     *Return value:*  dynamically allocated string.

 -- Function: char * lw6map_style_get_default (char * KEY)
     KEY:  key to query

     Get the default value for a style entry. This is quite a
     cost-expensive function given what it does, indeed it will convert
     anything to a string, and also perform key lookup to fetch the
     value.

     *Return value:*  dynamically allocated string.

 -- Function: int lw6map_color_set_is_same (lw6map_color_set_t *
          COLOR_SET_A, lw6map_color_set_t * COLOR_SET_B)
     COLOR_SET_A:  first item to compare

     COLOR_SET_B:  second item to compare

     Compares two color sets, telling if they contain the same data.

     *Return value:*  1 if same, 0 if different.

 -- Function: int lw6map_style_is_same (lw6map_style_t * STYLE_A,
          lw6map_style_t * STYLE_B)
     STYLE_A:  first item to compare

     STYLE_B:  second item to compare

     Compares two style structures, telling if they contain the same
     data.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_teams_zero (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Zeros the teams struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_defaults (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Set the teams struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_clear (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Clears the teams struct, this is not the same as setting to
     defaults.  This one supposes the struct has been properly
     initialized, at least zeroed before usage, it might contain
     pointers which should be freed.

     *Return value:*  none.

 -- Function: void lw6map_teams_copy (lw6map_teams_t * DST,
          lw6map_teams_t * SRC)
     DST:  destination

     SRC:  source

     Copies the contents of the teams struct. It's a real duplicate,
     any string is reallocated.

     *Return value:*  none.

 -- Function: int lw6map_teams_set (lw6map_teams_t * TEAMS, char * KEY,
          char * VALUE)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a teams structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6map_teams_get (lw6map_teams_t * TEAMS, char *
          KEY)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     Gets one single parameter in a teams structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6map_teams_get_default (char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given teams key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6map_teams_is_same (lw6map_teams_t * TEAMS_A,
          lw6map_teams_t * TEAMS_B)
     TEAMS_A:  one struct to compare

     TEAMS_B:  another struct to compare

     Compares the contents of two teams structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: int lw6map_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `map' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6map_texture_from_body (lw6map_texture_t * TEXTURE,
          lw6map_body_t * BODY, lw6map_color_couple_t * COLOR)
     TEXTURE:  texture to load (out param)

     BODY:  body to pick data from

     COLOR:  colors to use

     Will create a default bicolor texture from the body data, this is
     in case we don't want to use the texture or there is none. Result
     is not beautifull but might be very comfortable to play.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_texture_clear (lw6map_texture_t * TEXTURE)
     TEXTURE:  data to clear

     Clears a texture object, expects it to be in a consitent state,
     either filled with real data of zeroed.

     *Return value:*  none.

 -- Function: int lw6map_texture_coord_from_body (lw6map_level_t *
          LEVEL, int * TEXTURE_X, int * TEXTURE_Y, int BODY_X, int
          BODY_Y)
     LEVEL:  map to work on

     TEXTURE_X:  texture x coordinate (out param)

     TEXTURE_Y:  texture y coordinate (out param)

     BODY_X:  body x coordinate (in param)

     BODY_Y:  body y coordinate (in param)

     Translates from body coordinate space to texture coordinate space.

     *Return value:*  1 on success, 0 if failure.

 -- Function: lw6sys_color_8_t lw6map_texture_get_with_body_coord
          (lw6map_level_t * LEVEL, int BODY_X, int BODY_Y)
     LEVEL:  map to use

     BODY_X:  x coordinate in body space

     BODY_Y:  y coordinate in body space

     Get the color of a given point in the texture, using the body
     coordinate space.

     *Return value:*  RGBA 8-bit color.

 -- Function: int lw6map_texture_has_alpha (lw6map_texture_t * TEXTURE)
     TEXTURE:  texture object to test

     Finds out if the texture is fully opaque or not. If it has an
     alpha layer (typically, PNG file) but this one is filled at 100%
     everywhere, then it will consider opaque. This is a slow function
     but the result is cached in the has_alpha member, so as the
     function is called at map loading, use the cached value instead.

     *Return value:*  1 if has used alpha layer, 0 if opaque.

 -- Function: char * lw6map_weapon_index_to_key (int INDEX)
     INDEX:  index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form,
     which can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_weapon_key_to_index (char * KEY)
     KEY:  key of the weapon, for instance "red"

     The index of the weapon, between 0 & 19

     *Return value:*  an integer.

 -- Function: char * lw6map_weapon_index_to_label (int INDEX)
     INDEX:  index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form,
     which can be used to display information to players.

     *Return value:*  a string, must *not* be freed.


File: liquidwar6.info,  Node: libmsg,  Next: libnet,  Prev: libmap,  Up: C API

5.27 libmsg
===========

5.27.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/msg/index.html'.

5.27.2 API
----------

 -- Function: char * lw6msg_cmd_generate_hello (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a HELLO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_ticket (lw6nod_info_t * INFO,
          u_int64_t TICKET)
     INFO:  the node info to use

     TICKET:  the ticket to send

     Generate a TICKET command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_foo (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a FOO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_bar (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a BAR command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_goodbye (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a GOODBYE command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_data (int SERIAL, int I, int
          N, int ROUND, char * KER_MSG)
     SERIAL:  the message serial number

     I:  the message index in the group

     N:  the number of messages in the group

     ROUND:  the message round (can have an offset with real round)

     KER_MSG:  the actual content of the message (passed to core algo)

     Generate a DATA command. Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_cmd_analyse_hello (lw6nod_info_t ** INFO, char
          * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a HELLO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_ticket (lw6nod_info_t ** INFO,
          u_int64_t * TICKET, char * MSG)
     INFO:  will contain (remote) node info on success

     TICKET:  if not NULL, will contain the ticket value on success

     MSG:  the message to analyse

     Analyzes a TICKET message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_foo (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a FOO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_bar (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a BAR message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_goodbye (lw6nod_info_t ** INFO,
          char * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_data (int * SERIAL, int * I, int *
          N, int * ROUND, char ** KER_MSG, char * MSG)
     SERIAL:  will contain serial number on success

     I:  will contain group index on success

     N:  will contain group size on success

     ROUND:  will contain round on success (can have an offset with
     real round)

     KER_MSG:  will contain actual message on success

     Analyzes a DATA message.

     *Return value:*  1 on success, 0 on failure

 -- Function: char * lw6msg_cmd_guess_from_url (char * MSG)
     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  the from url, if found (dynamically allocated)

 -- Function: char * lw6msg_envelope_generate (lw6msg_envelope_mode_t
          MODE, char * VERSION, char * PASSWORD_CHECKSUM, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          PHYSICAL_FROM_ID, u_int64_t PHYSICAL_TO_ID, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, char * MSG)
     MODE:  mode to use (a la TELNET or URL compatible)

     VERSION:  the program version to use (note: can be changed when
     testing)

     PASSWORD_CHECKSUM:  the password string to send

     PHYSICAL_TICKET_SIG:  the signature of the message, calculated
     with ticket + physical from/to

     LOGICAL_TICKET_SIG:  the signature of the message, calculated with
     ticket + logical from/to

     PHYSICAL_FROM_ID:  the sender id

     PHYSICAL_TO_ID:  the receiver id

     LOGICAL_FROM_ID:  the message creator id

     LOGICAL_TO_ID:  the message final destination id

     MSG:  the body of the message

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_envelope_analyse (char * ENVELOPE,
          lw6msg_envelope_mode_t MODE, char * LOCAL_URL, char *
          PASSWORD, u_int64_t EXPECTED_PHYSICAL_FROM_ID, u_int64_t
          EXPECTED_PHYSICAL_TO_ID, char ** MSG, u_int32_t *
          PHYSICAL_TICKET_SIG, u_int32_t * LOGICAL_TICKET_SIG,
          u_int64_t * PHYSICAL_FROM_ID, u_int64_t * PHYSICAL_TO_ID,
          u_int64_t * LOGICAL_FROM_ID, u_int64_t * LOGICAL_TO_ID, char
          ** PHYSICAL_FROM_URL)
     ENVELOPE:  the envelope to analyse

     MODE:  mode to use (a la TELNET or URL compatible)

     LOCAL_URL:  the url of local server (usefull for password)

     PASSWORD:  the password to check against

     EXPECTED_PHYSICAL_FROM_ID:  the sender id, if NULL, no check
     performed

     EXPECTED_PHYSICAL_TO_ID:  the receiver id, if NULL, no check
     performed

     MSG:  if not NULL, will contain body of the message

     PHYSICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     LOGICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     PHYSICAL_FROM_ID:  if not NULL, will contain sender id

     PHYSICAL_TO_ID:  if not NULL, will contain receiver id

     LOGICAL_FROM_ID:  if not NULL, will contain message creator id

     LOGICAL_TO_ID:  if not NULL, will contain message final
     destination id

     PHYSICAL_FROM_URL:  if not NULL and if message allows, will
     contain sender public URL

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_info (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the INFO question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_list (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the LIST question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed. There's a max length because we don't want the udp
     buffer to be saturated + too long lists do not really mean
     anything anyway.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_pong (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the PING question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_request (char * COMMAND, char
          * REMOTE_URL, char * PASSWORD, char * LOCAL_URL)
     COMMAND:  the command to send (PING, INFO, LIST)

     REMOTE_URL:  the remote URL (used to seed password)

     PASSWORD:  the password, can be NULL or ""

     LOCAL_URL:  the public URL to send along with the message, can be
     NULL or ""

     Generates a simple clear text OOB request, with a password if
     needed.

     *Return value:*  a newly allocated string

 -- Function: int lw6msg_oob_analyse_request (int * SYNTAX_OK, char **
          COMMAND, int * PASSWORD_OK, char ** REMOTE_URL, char *
          REQUEST, char * LOCAL_URL, char * PASSWORD)
     SYNTAX_OK:  will contain 1 if syntax is OK, 0 if not

     COMMAND:  the command (out param, needs *not* to be freed)

     PASSWORD_OK:  will contain 1 if password is OK, 0 if not

     REMOTE_URL:  the URL detected, if provided (out param, does needs
     to be freed)

     REQUEST:  the request to analyse

     LOCAL_URL:  the local url (used to seed password)

     PASSWORD:  the password to check against

     Analyses a simple OOB message of the form COMMAND <passwd> <url>.

     *Return value:*  1 if OK, 0 if not. If 0, check the value of
     password_ok.

 -- Function: char * lw6msg_oob_analyse_pong (char * TEXT)
     TEXT:  the text of the message to parse

     Analyses a PONG message and gets the public_url from it, if it
     exists.

     *Return value:*  newly allocated string containing public_url if
     OK, NULL on error.

 -- Function: int lw6msg_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: u_int32_t lw6msg_ticket_calc_sig (u_int64_t TICKET,
          u_int64_t FROM_ID, u_int64_t TO_ID, char * MSG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     Produces a little signature, which is clearly vulnerable to
     brute-force attacks but makes it possible to be 100% sure if it's
     wrong, someone is trying to do something nasty (or there's a
     serious bug!).

     *Return value:*  the sig, always non-zero

 -- Function: int lw6msg_ticket_check_sig (u_int64_t TICKET, u_int64_t
          FROM_ID, u_int64_t TO_ID, char * MSG, u_int32_t TICKET_SIG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     TICKET_SIG:  the signature to check against

     Checks a sig is OK.

     *Return value:*  1 if they are the same, 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_ptr (char ** KEY,
          char ** VALUE, char * LINE)
     KEY:  will contain the key detected

     VALUE:  will contain the value detected

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and returns the key and the
     value in the passed pointers.

     *Return value:*  1 if line OK (and in this case `key' and `value'
     are set), 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_assoc (lw6sys_assoc_t
          ** ASSOC, char * LINE)
     ASSOC:  an assoc object which will contain the result

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and sets the `assoc' parameter
     according to detected values. Note that `assoc' must be set to
     contain string, and free them automatically with
     `lw6sys_free_callback' for instance.

     *Return value:*  1 if line OK (and in this case `assoc' is
     updated), 0 if not.

 -- Function: char * lw6msg_utils_get_assoc_str_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, char * DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_utils_get_assoc_int_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, int DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over. This one will returned an int
     converted with `lw6sys_atoi'.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_word_first (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_x (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     This special `x' function will consider slash ("/") as valid
     separator. It can't be used all the time but for almost every
     field but URLs, it's fine. Internally, this one is used to parse
     integers, IDs, etc.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_base64 (lw6msg_word_t * WORD, char
          ** NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     The word is expected to be base64 encoded and is decoded
     on-the-fly.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int (int * PARSED_VALUE, char **
          NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_ge0 (int * PARSED_VALUE, char
          ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_gt0 (int * PARSED_VALUE, char
          ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_16 (u_int16_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     16-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_32 (u_int32_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     32-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_64 (u_int64_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     64-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: char * lw6msg_z_encode (char * MSG, int LIMIT)
     MSG:  message to encode

     LIMIT:  if under this limit (length in bytes), do not encode,
     return as is

     Z-encode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     There's an optional limit *not* to encode anything, just when we
     know there are no special characters to escape and string is
     small, it's useless to fire this big artillery.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.

 -- Function: char * lw6msg_z_decode (char * MSG)
     MSG:  message to decode

     Z-decode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     This decode string does it the reverse way, un64-encode the string
     then uncompress it back to a readable string.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.


File: liquidwar6.info,  Node: libnet,  Next: libnod,  Prev: libmsg,  Up: C API

5.28 libnet
===========

5.28.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/net/index.html'.

5.28.2 API
----------

 -- Function: int lw6net_dns_is_ip (char * IP)
     IP:  the string to check

     Tests if a given string is a valid IP (IPV4). Test is only
     syntaxic, it's just to know if we're likely to need to query the
     DNS, it does not mean the IP is *really* valid.

     *Return value:*  1 if it's an IP, O if not.

 -- Function: char * lw6net_dns_gethostbyname (char * NAME)
     NAME:  name of the host

     A wrapper over the standard gethostbyname function, will even
     accept an IP as an input (in this case, will copy it...) and
     allocate a new string for the result.

     *Return value:*  an IP if success, NULL on error.

 -- Function: int lw6net_dns_lock ()
     Locks access to dns function `lw6net_dns_gethostbyname'.  This is
     because `gethostbyname' isn't reentrant plus, even if we didn't
     use it but its multithreadable equivalent (which is however not
     standard and always available) other libs (such as `libcurl' not
     to name it) might use this function too so in a general manner
     it's a good idea to use a mutex to protect multiple accesses to
     this.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_dns_unlock ()
     Unlocks access to dns function `lw6net_dns_gethostbyname'.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_last_error ()
     Reports the last network error. This is basically a debug function,
     designed mostly for Microsoft Winsock API, but can be safely called
     on any platform.

     *Return value:*  the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local ()
     Guess the local IP address. This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on. But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed. Will return NULL if interface can't
     be guessed.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (char * BIND_IP, int
          BIND_PORT)
     BIND_IP:  the IP address used to bind on

     BIND_PORT:  the IP port used to bind on

     Guess the server public url, based on `lw6net_if_guess_local'
     which tries to find a valid local IP address which is not
     loopback. This is only in case `bind_ip' is 0.0.0.0 (listen on all
     addresses) else it will just use `bind_ip' as you would expect.
     Function isn't foolproof, that's why one can override its default
     with a user settings.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (int SOCK)
     SOCK:  the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (int SOCK, char * LINE)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket,
     that is, stream oriented. The "\n" is automatically added, do not
     bother sending it.

     *Return value:*  non-zero if success

 -- Function: char * lw6net_recv_line_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: lw6sys_list_t * lw6net_recv_lines_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives several lines terminated by LF ("\n", chr(10)) or CR/LF
     ("\r\n", chr(10)chr(13)) on a UDP socket, that is, datagram
     oriented. If there's no complete line available, function returns
     immediately with NULL. Same if socket is closed, broken, whatever.
     Only if there's something consistent will the function return
     non-NULL.  By-value parameters allow the caller to know where the
     data come from. This variant of `lw6net_recv_line_tcp' will return
     a list of lines, this is mandatory since in UDP we can't call recv
     several times.

     *Return value:*  a list of dynamically allocated strings.  The
     tailing (CR)/LF is stripped from strings.

 -- Function: int lw6net_send_line_udp (int SOCK, char * LINE, char *
          IP, int PORT)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     IP:  the IP address of the target

     PORT:  the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket,
     that is, datagram oriented. The "\n" is automatically added, do
     not bother sending it.

     *Return value:*  the number of bytes sent, 0 if failure

 -- Function: int lw6net_init (int ARGC, const char * [] ARGV, int
          NET_LOG)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     NET_LOG:  1 if you want to enable net log, 0 if not

     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:*  non-zero if success

 -- Function: void lw6net_quit ()
     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:*  void

 -- Function: int lw6net_socket_set_blocking_mode (int SOCK, int MODE)
     SOCK:  the socket to modify

     MODE:  the mode to use (1 -> blocking mode, 0 -> non-blocking)

     Sets the blocking mode of a socket, the reason we use this is that
     `ioctl' isn't portable (`ioctlsocket' on MS-Windows).

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6net_socket_is_valid (int SOCK)
     SOCK:  the socket to test

     Tells if a socket is valid or not. This does not mean the socket
     is opened/connected and/or the peer is reachable, it just checks
     the socket is a valid descriptor. In practice it's just to avoid
     copy/pasting if (sock>=0)" everywhere.

     *Return value:*  1 if valid, 0 if not

 -- Function: void lw6net_socket_close (int SOCK)
     SOCK:  the socket to close

     Closes a socket, that is, stop activity and free its descriptor.

     *Return value:*  none.

 -- Function: int lw6net_tcp_listen (char * IP, int PORT)
     IP:  IP address to bind to

     PORT:  IP port to listen on

     Listens in TCP on a given port.

     *Return value:*  >=0 on success, -1 on failure.

 -- Function: int lw6net_tcp_accept (char ** INCOMING_IP, int *
          INCOMING_PORT, int LISTENING_SOCK, int DELAY_MSEC)
     INCOMING_IP:  address of remote peer (out param, dynamically
     allocated)

     INCOMING_PORT:  port of remote peer (out param)

     LISTENING_SOCK:  socket to listen on

     DELAY_MSEC:  delay, in msec, after which we stop accepting

     Accepts for a connexion on the given socket.

     *Return value:*  the new socket (>=0) if accepted, else -1

 -- Function: int lw6net_tcp_connect (char * IP, int PORT, int
          DELAY_MSEC)
     IP:  address to connect to

     PORT:  port to connect to

     DELAY_MSEC:  delay before we consider it's too late

     Tries to connect on a given socket.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_tcp_send (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC, int LOOP)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  delay after which we give up

     LOOP:  accept to do several calls if needed

     Will send data, possibly looping until all is send, and waiting for
     a maximum time of delay_msec.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6net_tcp_peek (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  maximum time to wait

     Tells wether data is available. Will actually fill the buffer with
     the data, but not remove it from the fifo list.

     *Return value:*  number of bytes available, 0 when nothing

 -- Function: int lw6net_tcp_recv (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC, int LOOP)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  maximum time to wait

     LOOP:  wether to loop or not

     If data is available, put it in buffer. If needed, will loop until
     `delay_msec' is elapsed. Data is removed from queue.

     *Return value:*  number of bytes received, 0 when nothing

 -- Function: int lw6net_tcp_is_alive (int SOCK)
     SOCK:  socket to test

     Tells wether a socket is alive and able to send data. This function
     will attempt a write to test if it's really usable.

     *Return value:*  1 if alive, 0 if not.

 -- Function: int lw6net_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `net' module test suite. This one could fail if some
     sockets are already bound, for instance. It's still run even in
     check-only (mode=0) mode.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6net_udp_client ()
     Creates an UDP client socket, that is, creates it and does not
     bind it to any address.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_udp_server (char * IP, int PORT)
     IP:  IP address to bind to

     PORT:  IP port to listen on

     Creates an UDP listening socket, that is, creates it and binds it
     on a given address.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_udp_send (int SOCK, char * BUF, int LEN, char
          * IP, int PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     IP:  IP address to send data to

     PORT:  IP port to send data to

     Sends an UDP datagram. Size can't be longer than about 1400 bytes,
     see problems about MTU, in practice all values arround 1000 are
     quite safe, 500 is pretty much garanteed to work everywhere, and
     for various reasons 1452 is a good maximum bet.

     *Return value:*  number of bytes sent

 -- Function: int lw6net_udp_peek (int SOCK, char * BUF, int LEN, char
          ** INCOMING_IP, int * INCOMING_PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     Peeks for a UDP datagram. Will not remove the data from queue.

     *Return value:*  number of bytes received

 -- Function: int lw6net_udp_recv (int SOCK, char * BUF, int LEN, char
          ** INCOMING_IP, int * INCOMING_PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     Receives a UDP datagram. Will remove the data from queue.

     *Return value:*  number of bytes received


File: liquidwar6.info,  Node: libnod,  Next: libp2p,  Prev: libnet,  Up: C API

5.29 libnod
===========

5.29.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/nod/index.html'.

5.29.2 API
----------

 -- Function: void lw6nod_dyn_info_free (lw6nod_dyn_info_t * DYN_INFO)
     DYN_INFO:  the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     `lw6nod_info_dup_dyn' for instance.

     *Return value:*  none

 -- Function: lw6nod_info_t * lw6nod_info_new (char * PROGRAM, char *
          VERSION, char * CODENAME, int STAMP, u_int64_t ID, char *
          URL, char * TITLE, char * DESCRIPTION, char * PASSWORD, int
          BENCH, int OPEN_RELAY, int UPTIME, int IDLE_SCREENSHOT_SIZE,
          void * IDLE_SCREENSHOT_DATA)
     PROGRAM:  the program (normally it's liquidwar6)

     VERSION:  the version

     CODENAME:  the codename

     STAMP:  the stamp

     ID:  the node id

     URL:  the node public url

     TITLE:  the node title

     DESCRIPTION:  the node description

     PASSWORD:  the node password

     BENCH:  the node bench

     OPEN_RELAY:  open relay or not

     UPTIME:  uptime in seconds

     IDLE_SCREENSHOT_SIZE:  the size (bytes) of the image to display
     when game is idle

     IDLE_SCREENSHOT_DATA:  the data (jpeg) of the image to display
     when game is idle

     Creates a node info object. The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     `lw6nod_info_update' which can be called later.

     *Return value:*  newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6nod_info_t * INFO)
     INFO:  the node info to free

     Frees a node info object.

     *Return value:*  none

 -- Function: int lw6nod_info_lock (lw6nod_info_t * INFO)
     INFO:  the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:*  1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6nod_info_t * INFO)
     INFO:  the node info to unlock

     Unlocks a node info object, this is the compation of the
     `lw6nod_info_lock' function.

     *Return value:*  1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6nod_info_t * INFO)
     INFO:  the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values. This is what we want when the node is idle,
     not playing.

     *Return value:*  none.

 -- Function: int lw6nod_info_update (lw6nod_info_t * INFO, u_int64_t
          COMMUNITY_ID, int ROUND, char * LEVEL, int REQUIRED_BENCH,
          int NB_COLORS, int MAX_NB_COLORS, int NB_CURSORS, int
          MAX_NB_CURSORS, int NB_NODES, int MAX_NB_NODES, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     INFO:  the node info to update

     COMMUNITY_ID:  the id of the community the node belongs to

     ROUND:  the current round (can have an offset with real round
     number)

     LEVEL:  the name of the current level (map)

     REQUIRED_BENCH:  the bench required to connect

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  max number of colors allowed

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  max number of cursors allowed

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  max number of nodes allowed

     GAME_SCREENSHOT_SIZE:  size of screenshot (bytes)

     GAME_SCREENSHOT_DATA:  screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes. Call this whenever the
     node has changed some parameter. Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:*  1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6nod_info_t *
          INFO)
     INFO:  the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it,
     this is to avoid protection fault error when concurrent threads
     access this info.

     *Return value:*  newly allocated object, must be freed.

 -- Function: lw6sys_hash_t * lw6nod_info_new_discovered_nodes ()
     Creates a new hash, to be used as a discovered nodes list.  Using
     this function has the advantage of setting the hash options to
     their defaults.  We use a hash to avoid having uselessly long
     lists containing always the same node due to multiple detections.

     *Return value:*  an empty hash

 -- Function: int lw6nod_info_add_discovered_node (lw6nod_info_t *
          INFO, char * PUBLIC_URL)
     INFO:  the node info to update

     PUBLIC_URL:  the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting. We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards. This is also a good way to avoid trivial DOS attacks.

     *Return value:*  1 if OK, O if error.

 -- Function: lw6sys_list_t * lw6nod_info_pop_discovered_nodes
          (lw6nod_info_t * INFO)
     INFO:  the node info to query

     Returns a list of all discovered nodes (their public URL) and
     empties the current queue as well.

     *Return value:*  a list of dynamically allocated strings.

 -- Function: lw6sys_list_t * lw6nod_info_new_verified_nodes ()
     Creates a new list, to be filled with nodes and typically passed
     to `lw6nod_info_set_verified_nodes'. Using this function has the
     advantage of setting the listh options to their defaults.

     *Return value:*  an empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6nod_info_t * INFO,
          lw6sys_list_t * LIST)
     INFO:  the node info to modify

     LIST:  the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page. We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very
     important about this function is that `list' will be freed by
     function, that is, if you call this, then you can (you should)
     forget your object, it will disappear any time soon.

     *Return value:*  1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6nod_info_t *
          INFO, lw6sys_list_callback_func_t FUNC, void * FUNC_DATA)
     INFO:  the node info concerned

     FUNC:  the function to apply

     FUNC_DATA:  arbitrary pointer holding data to pass to function

     Calls `lw6sys_hash_map' with `func' on every member of the list of
     verified nodes. The reason there's a function for this is that it
     is very important that list object is locked when doing this.
     This function does perform a lock/unlock so it is safe.

     *Return value:*  none.

 -- Function: int lw6nod_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libp2p,  Next: libpil,  Prev: libnod,  Up: C API

5.30 libp2p
===========

5.30.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/p2p/index.html'.

5.30.2 API
----------

 -- Function: lw6p2p_db_t * lw6p2p_db_open (int ARGC, const char * []
          ARGV, char * NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Creates a new database object. Normally there's only one object
     like this at a given time, it can be shared among various nodes.
     The database name is appended to user directory path, this allows
     different databases to be created, in theory.

     *Return value:*  a pointer on the newly created object.

 -- Function: void lw6p2p_db_close (lw6p2p_db_t * DB)
     DB:  the db to close

     Closes a db object, memory ressources will be freed.

     *Return value:*  none.

 -- Function: char * lw6p2p_db_repr (lw6p2p_db_t * DB)
     DB:  the db to work on

     Gives a readable representation of the db

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_db_reset (int ARGC, const char * [] ARGV, char
          * NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Clears the database. Simply removes the db file, in fact. Do not
     call while database is used...

     *Return value:*  1 on success, 0 if failed.

 -- Function: char * lw6p2p_db_default_name ()
     Returns the default database name, should be p2p.db (this is a
     relative path, not an absolute path, will be appended to user dir).

     *Return value:*  the default database name, need not (must not) be
     freed.

 -- Function: int _lw6p2p_db_now (_lw6p2p_db_t * DB)
     DB:  the db object concerned (used to calculate time origin)

     Returns a timestamp suitable for db usage. The reason we don't use
     regular timestamps is that they are 1) too accurate (msec is
     useless for what's involved here) and 2) too big and likely to be
     negative in signed mode even if converted to seconds.

     *Return value:*  a timestamp, 0 means "beginning of program"
     (think of it as uptime)

 -- Function: lw6p2p_entry_t * lw6p2p_entry_new (int
          CREATION_TIMESTAMP, char * VERSION, char * CODENAME, int
          STAMP, char * ID, char * URL, char * TITLE, char *
          DESCRIPTION, int HAS_PASSWORD, int BENCH, int OPEN_RELAY,
          char * COMMUNITY_ID, int ROUND, char * LEVEL, int
          REQUIRED_BENCH, int NB_COLORS, int MAX_NB_COLORS, int
          NB_CURSORS, int MAX_NB_CURSORS, int NB_NODES, int
          MAX_NB_NODES, char * IP, int PORT, int LAST_PING_TIMESTAMP,
          int PING_DELAY_MSEC, int AVAILABLE)
     CREATION_TIMESTAMP:  when it has been created, UNIX timestamp

     VERSION:  version of the node

     CODENAME:  codename of the node

     STAMP:  stamp of the node

     ID:  id of the node (string representation)

     URL:  public url of the node

     TITLE:  title of the node

     DESCRIPTION:  description of the node

     HAS_PASSWORD:  wether node is password protected or not

     BENCH:  node bench

     OPEN_RELAY:  wether the node is in open relay mode or not

     ROUND:  current round

     LEVEL:  current level played

     REQUIRED_BENCH:  current bench

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  maximum number of colors

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  maximum number of cursors

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  maximum number of nodes

     IP:  node ip (string representation)

     PORT:  node port

     LAST_PING_TIMESTAMP:  UNIX timestamp of last contact with node

     PING_DELAY_MSEC:  ping delay, in milliseconds

     AVAILABLE:  wether node is available, wether we can connect to it

     Creates a new p2p entry. Will accept NULL parameters for strings
     as well as arbitrary long strings, will simply cut them short if
     there aren't already limited to max size.

     *Return value:*  newly allocated object

 -- Function: void lw6p2p_entry_free (lw6p2p_entry_t * ENTRY)
     ENTRY:  entry to free

     Frees a p2p entry.

     *Return value:*  none.

 -- Function: char * lw6p2p_entry_repr (lw6p2p_entry_t * ENTRY)
     ENTRY:  entry to represent

     Gives a human-readable representation of the entry

     *Return value:*  dynamically allocated string

 -- Function: lw6p2p_node_t * lw6p2p_node_new (int ARGC, const char *
          [] ARGV, lw6p2p_db_t * DB, char * CLIENT_BACKENDS, char *
          SERVER_BACKENDS, char * BIND_IP, int BIND_PORT, int
          BROADCAST, char * PUBLIC_URL, char * TITLE, char *
          DESCRIPTION, char * PASSWORD, int BENCH, int OPEN_RELAY, char
          * KNOWN_NODES, int NETWORK_RELIABILITY, int TROJAN)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     DB:  the database to use

     CLIENT_BACKENDS:  the list of client backends to use

     SERVER_BACKENDS:  the list of server backends to use

     BIND_IP:  the IP address to bind on

     BIND_PORT:  the IP port to listen on

     BROADCAST:  wether broadcast is allowed on this node

     PUBLIC_URL:  the public URL we want to show

     TITLE:  the title of the node

     DESCRIPTION:  the description of the node

     PASSWORD:  the password to use

     BENCH:  the bench of the node (its power)

     OPEN_RELAY:  act as an open relay or not

     KNOWN_NODES:  list of already known nodes

     NETWORK_RELIABILITY:  drop 1 packet out of X

     TROJAN:  act as a stupid trojan to test out automatic kick-off

     Creates a new "pear to pear" node. This will fire the server and
     allow client access, on demand. A lot of stuff can be done in the
     background once this is called.

     *Return value:*  a pointer on the newly created objects.

 -- Function: void lw6p2p_node_free (lw6p2p_node_t * NODE)
     NODE:  the node to free

     Frees a node object, all network communications will be shut.

     *Return value:*  none.

 -- Function: char * lw6p2p_node_repr (lw6p2p_node_t * NODE)
     NODE:  the node to work on

     Gives a readable representation of the node

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_node_poll (lw6p2p_node_t * NODE)
     NODE:  the node to poll

     Polls a p2p node. This must be called on a regular basis, else
     network communication is stalled.

     *Return value:*  1 on success, 0 on error.

 -- Function: void lw6p2p_node_close (lw6p2p_node_t * NODE)
     NODE:  the node to close

     Closes a p2p node. Closing is necessary in some contexts, for
     instance scheme/smob instanciation when you want to release the
     object ressources (sockets, ports, threads...) *before* it is
     deleted by, for instance, a garbage collector.

     *Return value:*  1 on success, 0 on error.

 -- Function: u_int64_t lw6p2p_node_get_id (lw6p2p_node_t * NODE)
     NODE:  the node to query

     Returns the node id, an id which is supposed to uniquely identify
     the node at run-time.

     *Return value:*  numerical id.

 -- Function: lw6sys_list_t * lw6p2p_node_get_entries (lw6p2p_node_t *
          NODE)
     NODE:  node to query

     Returns a list of all known nodes, this is a plain table dump,
     sorted so that the most likely to be interesting to connect
     oneself to are listed *last*, this is just a (little)
     optimization, since we know we'll need to parse this list to
     construct a Guile object, we reverse the order.

     *Return value:*  list object containing `lw6p2p_entry_t' objects

 -- Function: int lw6p2p_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `p2p' module test suite. This test can fail if one cannot
     bind on some network port, in a general manner it is dependent on
     the network environment, so it's better if there's some sort of
     human control on it.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libpil,  Next: libscm,  Prev: libp2p,  Up: C API

5.31 libpil
===========

5.31.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/pil/index.html'.

5.31.2 API
----------

 -- Function: int lw6pil_bench (float * BENCH_RESULT, lw6sys_progress_t
          * PROGRESS)
     BENCH_RESULT:  pointer to float, will contain the bench result

     PROGRESS:  to inform the caller of the process advancement

     Runs a standard, normalized bench on a default map. Results can be
     interpreted as an estimated speed/power of your computer.

     *Return value:*  1 on success, 0 if failure

 -- Function: void lw6pil_coords_fix (lw6map_rules_t * RULES,
          lw6sys_whd_t * SHAPE, float * X, float * Y, float * Z)
     RULES:  the set of rules to use (defines polarity)

     SHAPE:  the shape of the map (logical part)

     X:  the x coord to fix

     Y:  the y coord to fix

     Z:  the z coord to fix

     Similar to `lw6map_coords_fix' but using floats, this function can
     be used to check cursor position boundaries. Any float pointer can
     be NULL.

     *Return value:*  none.

 -- Function: void lw6pil_coords_fix_x10 (lw6map_rules_t * RULES,
          lw6sys_whd_t * SHAPE, float * X, float * Y, float * Z)
     RULES:  the set of rules to use (defines polarity)

     SHAPE:  the shape of the map (logical part)

     X:  the x coord to fix

     Y:  the y coord to fix

     Z:  the z coord to fix

     Similar to `lw6pil_coords_fix' but does use a wider range, say 10
     times the actual size of the map, this is not to contain the
     cursor within the map but just to avoid overflow errors.

     *Return value:*  none.

 -- Function: void lw6pil_local_cursors_reset (lw6pil_local_cursors_t *
          LOCAL_CURSORS)
     Resets a local cursors struct. Note that this need not be called
     very often, in fact the local cursors can cope with "dead" cursors
     easily. In practise, in a local game, there are only 4 of them,
     great maximum.

     *Return value:*  none.

 -- Function: lw6pil_local_cursor_t * lw6pil_local_cursors_get_cursor
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t CURSOR_ID)
     CURSOR_ID:  the id of the cursor to query

     Returns a pointer on the cursor with the given id.

     *Return value:*  a pointer (must *not* be freed) which is NULL is
     cursor does not exist.

 -- Function: int lw6pil_local_cursors_get_info (lw6pil_local_cursors_t
          * LOCAL_CURSORS, int * X, int * Y, int * MOUSE_CONTROLLED,
          u_int16_t CURSOR_ID)
     X:  a pointer to the x position, may be NULL

     Y:  a pointer to the y position, may be NULL

     MOUSE_CONTROLLED:  a pointer to the mouse_controlled flag, may be
     NULL

     CURSOR_ID:  the id of the cursor to query

     Gets the x,y position of the cursor, and tells if it's mouse
     controlled.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_xy (lw6pil_local_cursors_t *
          LOCAL_CURSORS, u_int16_t CURSOR_ID, int X, int Y)
     CURSOR_ID:  the id of the cursor to modify

     X:  the x position

     Y:  the y position

     Sets the position of a cursor in the local cursors struct. If
     cursor does not exists, it's appended to the list.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_mouse_controlled
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t CURSOR_ID,
          int MOUSE_CONTROLLED)
     CURSOR_ID:  the id of the cursor to modify

     MOUSE_CONTROLLED:  the mouse_controlled attribute

     Sets which cursor is mouse controlled. If mouse_controlled is 1,
     the flag is set for this cursor and cleared for all others. If set
     to 0, only this cursor's flag is cleared.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_get_main_info
          (lw6pil_local_cursors_t * LOCAL_CURSORS, u_int16_t *
          CURSOR_ID, int * X, int * Y, int * MOUSE_CONTROLLED)
     CURSOR_ID:  the id of the main cursor, may be NULL

     X:  a pointer to the x position, may be NULL

     Y:  a pointer to the y position, may be NULL

     MOUSE_CONTROLLED:  a pointer to the mouse_controlled flag, may be
     NULL

     Gets the x,y position of the main cursor, and tells if it's mouse
     controlled.

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: int lw6pil_local_cursors_set_main (lw6pil_local_cursors_t
          * LOCAL_CURSORS, u_int16_t CURSOR_ID)
     CURSOR_ID:  the id of the cursor to be labelled as main cursor

     Sets the main cursor attribute, the main cursor is later used, for
     instance, to decide how to display the map (centered on it, for
     instance).

     *Return value:*  1 on success (cursor exists), 0 on failure (no
     such cursor).

 -- Function: lw6pil_pilot_t * lw6pil_pilot_new (lw6ker_game_state_t *
          GAME_STATE, int64_t SEQ_0, int64_t TIMESTAMP,
          lw6sys_progress_t * PROGRESS)
     GAME_STATE:  the game state we're going to work on

     SEQ_0:  the start sequence to use, that is, the seq at round=0

     TIMESTAMP:  the current ticks (1000 ticks per sec, used to
     calibrate)

     PROGRESS:  object used to show the advancement of the process

     Initializes a 'pilot' object, this object is responsible for
     interpreting messages, transform them into low-level 'ker' module
     function calls, and handle all the thread-spooky stuff.

     *Return value:*  a working pilot object. May be NULL on memory
     failure.

 -- Function: void lw6pil_pilot_free (lw6pil_pilot_t * PILOT)
     PILOT:  the object to free.

     Frees a 'pilot' object, note that this might involve joining some
     threads, so it can 'take some time'.

     *Return value:*  none.

 -- Function: int lw6pil_pilot_send_command (lw6pil_pilot_t * PILOT,
          char * COMMAND_TEXT, int VERIFIED)
     PILOT:  the object to send commands to.

     COMMAND_TEXT:  the text of the command, as received form network

     VERIFIED:  wether we're sure this message is valid.

     Sends a command and handles it internally.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_local_command (lw6pil_pilot_t * PILOT,
          char * COMMAND_TEXT)
     PILOT:  the object to apply the local command on

     COMMAND_TEXT:  the command text

     This function is used to fix the annoying fact that by only sending
     commands a limited number of times per sec to the game state, the
     display always reflect an outdated position for cursors. But
     players do not want to see this, they want to see the cursor in
     the right place.  So what we do is that the pilot can process
     "local" commands which have absolutely no effect on the game but
     simply update a local cursor state, only used for display. It's
     here in the pil module for it's where the command interpreting
     code is, and the fact that there's this lag is directly linked
     with the pilot way of doing things.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6pil_pilot_commit (lw6pil_pilot_t * PILOT)
     PILOT:  the object to commit.

     Commits all commands sent and actually send them to the
     corresponding threads. This commit system allows better performance
     by sending, for instance, all the commands for a given round
     together.

     *Return value:*  none.

 -- Function: int lw6pil_pilot_make_backup (lw6pil_pilot_t * PILOT)
     PILOT:  the object to perform the backup on

     Makes a new backup in the pilot, that is, copy 'reference' to
     'backup'.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_can_sync (lw6ker_game_state_t * TARGET,
          lw6pil_pilot_t * PILOT)
     TARGET:  the target game_state we would sync on

     PILOT:  the object to perform the backup on

     Tests wether sync functions are callable with a given game state.
     It verifies if the internal game_state and the target look the
     same.

     *Return value:*  1 if sync functions can be called, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_backup (lw6ker_game_state_t *
          TARGET, lw6pil_pilot_t * PILOT)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     Gets the backup from the pilot object. This is the last snapshot
     taken by `make_backup' or, by default, the game_state the pilot
     was constructed with.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_reference (lw6ker_game_state_t
          * TARGET, lw6pil_pilot_t * PILOT)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     Gets the latest reference game_state, that is, a stable snapshot
     of the game, with no inconsistency, a game position that exists
     and that we can rely on. Note that getting this can take time
     since a global mutex is required, and computations must end before
     you get the data.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6pil_pilot_sync_from_draft (lw6ker_game_state_t *
          TARGET, lw6pil_pilot_t * PILOT, int DIRTY_READ)
     TARGET:  the game_state structure which will get the informations.

     PILOT:  the object to get informations from.

     DIRTY_READ:  wether to allow dirty read or not

     Gets the informations from the pilot object, not being worried
     about game consistency, this one will just return the latest
     version available.  It might even be in an inconsistent state, the
     position could reflect a position which will never exist. Still,
     the data returned will not correspond to a half-spread or
     half-moved game_state if dirty_read is set to 0. In this case the
     data has at least some basic consistency and getting this does
     require some mutex lock, however wait time should be fairly small
     (max. a round). But, in a general manner, this function is only
     used for display, and we do not care much if there's a small
     glitch, we prefer fast & smooth display.

     *Return value:*  1 if OK, 0 if not.

 -- Function: lw6ker_game_state_t * lw6pil_pilot_dirty_read
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to get informations from.

     Returns a direct access to the most up-to-date game_state, without
     locking anything whatsoever. This is clearly to implement a dirty
     read mode as the name of the function suggests.

     *Return value:*  1 if OK, 0 if not.

 -- Function: char * lw6pil_pilot_repr (lw6pil_pilot_t * PILOT)
     Returns a string describing the pilot. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: void lw6pil_pilot_calibrate (lw6pil_pilot_t * PILOT,
          int64_t TIMESTAMP, int64_t SEQ)
     PILOT:  the object to calibrate

     TIMESTAMP:  the current ticks setting (1000 ticks per second)

     SEQ:  the round expected to be returned with this ticks value

     Calibrates the pilot, that is, initializes it so that subsequent
     calls to `lw6pil_pilot_get_round' return consistent values.

     *Return value:*  none.

 -- Function: void lw6pil_pilot_speed_up (lw6pil_pilot_t * PILOT, int
          SEQ_INC)
     PILOT:  the pilot to speed up

     SEQ_INC:  the number of seqs

     Re-calibrates the pilot so that it speeds up a bit.  This will
     basically increase next_seq by seq_inc.

     *Return value:*  none.

 -- Function: void lw6pil_pilot_slow_down (lw6pil_pilot_t * PILOT, int
          SEQ_DEC)
     PILOT:  the pilot to speed up

     SEQ_DEC:  the number of seqs

     Re-calibrates the pilot so that it slows down a bit.  This will
     basically decrease next_seq by seq_inc.

     *Return value:*  none.

 -- Function: int64_t lw6pil_pilot_get_seq_0 (lw6pil_pilot_t * PILOT)
     PILOT:  pilot object to query

     Get the initial seq (the one passed at object construction) which
     says what the seq was at round=0, it's just an offset.

     *Return value:*  64-bit integer

 -- Function: int lw6pil_pilot_seq2round (lw6pil_pilot_t * PILOT,
          int64_t SEQ)
     PILOT:  pilot object to work on

     SEQ:  the seq to convert

     Converts a seq (64-bit) to a round (32-bit). 64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:*  the round (32-bit integer)

 -- Function: int64_t lw6pil_pilot_round2seq (lw6pil_pilot_t * PILOT,
          int ROUND)
     PILOT:  pilot object to work on

     ROUND:  the round to convert

     Converts a round (32-bit) to a seq (64-bit). 64-bit seqs are used
     to avoid out-of-range errors on very long games, OTOH a round is
     32-bit to garantee the atomicity of its affection, even on
     platforms which are not native 64-bit.

     *Return value:*  the seq (64-bit integer)

 -- Function: int64_t lw6pil_pilot_get_next_seq (lw6pil_pilot_t *
          PILOT, int64_t TIMESTAMP)
     PILOT:  the object to query

     TIMESTAMP:  the current ticks setting (1000 ticks per second)

     Returns the seq one should use to generate new events/commands at
     a given time (given in ticks).

     *Return value:*  none.

 -- Function: int64_t lw6pil_pilot_get_last_commit_seq (lw6pil_pilot_t
          * PILOT)
     PILOT:  the object to query

     Returns the seq of the last commit (reference game_state) for this
     object.

     *Return value:*  the commit seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_target_seq
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the seq which is targetted in the reference game_state,
     this is 'how far computation will go in the reference game_state
     if no new commands are issued'. Note that there can always be some
     commands which are not yet processed, so you should not rely on
     this too heavily, however it gives a good idea of how things are
     going.

     *Return value:*  the target seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_reference_current_seq
          (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the current seq in the reference game_state. There's no
     lock on this call so don't rely on this too heavily, it just gives
     you an idea of wether the pilot is very late on its objectives or
     just on time.

     *Return value:*  the current seq (reference object)

 -- Function: int64_t lw6pil_pilot_get_max_seq (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Returns the max current seq in the reference or draft game states.
     No lock on this call so don't rely on this too heavily, it just
     gives you an idea of computation state.

     *Return value:*  the current seq (reference object)

 -- Function: int lw6pil_pilot_is_over (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Tells wether the game is over or not.

     *Return value:*  1 if over, 0 if not

 -- Function: int lw6pil_pilot_did_cursor_win (lw6pil_pilot_t * PILOT,
          u_int16_t CURSOR_ID)
     PILOT:  the object to query

     CURSOR_ID:  the cursor_id concerned

     Tells wether a given cursor was winner or not.

     *Return value:*  1 if over, 0 if not

 -- Function: int lw6pil_pilot_get_winner (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Gets the winner color.

     *Return value:*  a team color, -1 if no winner and/or error.

 -- Function: int lw6pil_pilot_get_looser (lw6pil_pilot_t * PILOT)
     PILOT:  the object to query

     Gets the looser color.

     *Return value:*  a team color, -1 if no looser and/or error.

 -- Function: lw6pil_local_cursors_t * lw6pil_pilot_get_local_cursors
          (lw6pil_pilot_t * PILOT)
     PILOT:  object to query

     Returns a pointer on the local_cursors struct used within the
     object. Beware, this is the *real* pointer, not a copy...

     *Return value:*  pointer on internal object

 -- Function: int64_t lw6pil_seq_random_0 ()
     Gets a pseudo-random start seq, why do we use this? Just to make
     sure even in non-network situations, seq are always very high and
     random, this way this is one less bug to check in networked
     context.

     *Return value:*  random integer value, always greater than INT_MAX

 -- Function: int lw6pil_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `pil' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libscm,  Next: libsim,  Prev: libpil,  Up: C API

5.32 libscm
===========

5.32.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/scm/index.html'.

5.32.2 API
----------

 -- Function: int lw6scm_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `scm' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6scm_c_define_gsubr (char * NAME, int REQ, int OPT,
          int RST, lw6scm_func_t FCN)
     NAME:  name of the function when called from guile

     REQ:  required parameters

     OPT:  optional parameters

     RST:  ? should RTFM to find that out

     FCN:  the function itself (pointer on the C executable code)

     Wrapper on `scm_c_define_gsubr', one of the value of this function
     is that it does check wether it's documented before registering
     it. So if you try to register something not documented, it will
     fire a warning, which is a very nice code-quality tool.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6scm_c_primitive_load (char * FILENAME)
     FILENAME:  file to execute

     Loads and executes a script. Will add a log message while doing it.

     *Return value:*  1 on success, 0 on failure.


File: liquidwar6.info,  Node: libsim,  Next: libsnd,  Prev: libscm,  Up: C API

5.33 libsim
===========

5.33.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/sim/index.html'.

5.33.2 API
----------

 -- Function: void lw6sim_print (lw6sim_results_t * RESULTS, FILE * F)
     RESULTS:  data to print

     F:  file to print data to

     Pretty prints results on standard output.

     *Return value:*  none.

 -- Function: void lw6sim_results_zero (lw6sim_results_t * RESULTS)
     RESULTS:  out param, will be cleared

     Fills the struct with zeroes.

     *Return value:*  none.

 -- Function: int lw6sim_results_update_percents (lw6sim_results_t *
          RESULTS)
     RESULTS:  results set to work on (in/out param)

     Updates the structure so that the percent members are up to date.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sim_simulate (int ARGC, const char * [] ARGV,
          lw6sim_results_t * RESULTS, int NB_TEAMS, char * BOT_BACKEND)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     RESULTS:  out param, results of the simulation

     NB_TEAMS:  number of teams

     BOT_BACKEND:  bot backend to use

     Runs a simulation of several battle/games on the default map using
     different team settings. Will test teams up to the given number,
     for instance if you give 3 as an argument, will run tests with
     teams 0, 1 and 2 (that's to say a total of 3 teams).

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sim_simulate_basic (int ARGC, const char * []
          ARGV, lw6sim_results_t * RESULTS)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     RESULTS:  out param, results of the simulation

     Runs a simulation of several battle/games on the default map using
     different team settings. Will test the most common colors only,
     with the most popular bot.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sim_simulate_full (int ARGC, const char * [] ARGV,
          lw6sim_results_t * RESULTS)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     RESULTS:  out param, results of the simulation

     Runs a simulation of several battle/games on the default map using
     different team settings. Will test all colors, with the most
     popular bot.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6sim_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `sim' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libsnd,  Next: mod-csound,  Prev: libsim,  Up: C API

5.34 libsnd
===========

5.34.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/snd/index.html'.

5.34.2 API
----------

 -- Function: int lw6snd_play_fx (lw6snd_backend_t * BACKEND, int FX_ID)
     BACKEND:  sound backend to use

     FX_ID:  sound fx id

     Plays a sound fx.

     *Return value:*  1 on success, 0 on error

 -- Function: int lw6snd_is_music_file (lw6snd_backend_t * BACKEND,
          char * MAP_DIR, char * MUSIC_PATH, char * MUSIC_FILE)
     BACKEND:  sound backend to use

     MAP_DIR:  map directory, to search additionnal files

     MUSIC_PATH:  config entry containing multiple paths

     MUSIC_FILE:  relative/local name of a music file

     Tells wether a file is a valid music file, typicallly based on file
     existence and extension. Not bullet proof, file might actually not
     be loadable, but chances are 99%.

     *Return value:*  1 if music file, 0 if not

 -- Function: int lw6snd_play_music_file (lw6snd_backend_t * BACKEND,
          char * MAP_DIR, char * MUSIC_PATH, char * MUSIC_FILE)
     BACKEND:  sound backend to use

     MAP_DIR:  map directory, to search additionnal files

     MUSIC_PATH:  config entry containing multiple paths

     MUSIC_FILE:  relative/local name of a music file

     Plays a music file.

     *Return value:*  1 if OK, 0 if not.

 -- Function: int lw6snd_play_music_random (lw6snd_backend_t * BACKEND,
          char * MUSIC_PATH, char * MUSIC_FILTER, char * MUSIC_EXCLUDE)
     BACKEND:  sound backend to use

     MUSIC_PATH:  config entry containing multiple paths

     MUSIC_FILTER:  string filter, must be present

     MUSIC_EXCLUDE:  string filter, must not be present

     Plays a random music file. The filter and exclude mecanisms are
     not complete regex filters, only a quick and dirty feature which
     should still help in some cases, such as sorting musics for the
     menus and for the rest.

     *Return value:*  1 if OK, 0 if not.

 -- Function: void lw6snd_stop_music (lw6snd_backend_t * BACKEND)
     BACKEND:  sound backend to use

     Stops the music.

     *Return value:*  none.

 -- Function: int lw6snd_init (lw6snd_backend_t * BACKEND, float
          FX_VOLUME, float WATER_VOLUME, float MUSIC_VOLUME)
     BACKEND:  the graphical backend to use

     FX_VOLUME:  sound fx volume

     WATER_VOLUME:  water sounds volume

     MUSIC_VOLUME:  music volume

     Sets up the sound backend for good, initializing a playback engine
     ready to play sounds and set to defaults.  This call can typically
     fail if there's no device available, if the user doesn't have
     enough rights to access the hardware, and so on.

     *Return value:*  1 on success, 0 if not

 -- Function: void lw6snd_set_fx_volume (lw6snd_backend_t * BACKEND,
          float VOLUME)
     BACKEND:  sound backend to use

     VOLUME:  sound fx volume

     Changes sound fx volume.

     *Return value:*  none.

 -- Function: void lw6snd_set_water_volume (lw6snd_backend_t * BACKEND,
          float VOLUME)
     BACKEND:  sound backend to use

     VOLUME:  water sounds volume

     Changes water sounds volume.

     *Return value:*  none.

 -- Function: void lw6snd_set_music_volume (lw6snd_backend_t * BACKEND,
          float VOLUME)
     BACKEND:  sound backend to use

     VOLUME:  music volume

     Changes music volume.

     *Return value:*  none.

 -- Function: void lw6snd_poll (lw6snd_backend_t * BACKEND)
     BACKEND:  sound backend to use

     Polling function, must be called on a regular basis.

     *Return value:*  none.

 -- Function: void lw6snd_quit (lw6snd_backend_t * BACKEND)
     BACKEND:  the backend to quit

     Uninitializes the backend, that is, releases resources, stops
     playback.

     *Return value:*  none.

 -- Function: char * lw6snd_repr (lw6snd_backend_t * BACKEND)
     BACKEND:  the backend to represent

     Returns a readable version of the backend object.

     *Return value:*  a newly allocated pointer.

 -- Function: lw6sys_assoc_t * lw6snd_get_backends (int ARGC, const
          char * [] ARGV)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     List available snd backends. The hash contains pairs with id and
     name for each backend. The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface. The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:*  hash containing id/name pairs.

 -- Function: lw6snd_backend_t * lw6snd_create_backend (int ARGC, const
          char * [] ARGV, char * NAME)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     NAME:  string containing snd key, typically got from
     `lw6snd_get_backends'

     Creates a snd backend, this is just about loading the dynamic
     library if needed, and/or check snd engine is available, and
     connect to it. It does not perform initialization.

     *Return value:*  snd backend.

 -- Function: void lw6snd_destroy_backend (lw6snd_backend_t * BACKEND)
     BACKEND:  snd backend to destroy

     Frees the ressources associated to a snd, which must have been
     properly uninitialized before.

     *Return value:*  none.

 -- Function: int lw6snd_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `snd' module test suite. If run in check mode (0), won't
     really perform the test, since it could fail because of hardware
     problems, context, permissions...

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: mod-csound,  Next: mod-ogg,  Prev: libsnd,  Up: C API

5.35 mod-csound
===============

5.35.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/snd/mod-csound/index.html'.

5.35.2 API
----------


File: liquidwar6.info,  Node: mod-ogg,  Next: libsrv,  Prev: mod-csound,  Up: C API

5.36 mod-ogg
============

5.36.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/snd/mod-ogg/index.html'.

5.36.2 API
----------


File: liquidwar6.info,  Node: libsrv,  Next: mod-httpd,  Prev: mod-ogg,  Up: C API

5.37 libsrv
===========

5.37.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/srv/index.html'.

5.37.2 API
----------

 -- Function: int lw6srv_init (lw6srv_backend_t * BACKEND,
          lw6srv_listener_t * LISTENER)
     BACKEND:  backend to use

     Initializes a server backend. Must be performed before any other
     call.

     *Return value:*  1 on success, 0 on failure

 -- Function: void lw6srv_quit (lw6srv_backend_t * BACKEND)
     BACKEND:  unitialize a srv backend

     Closes a srv, but does not free all ressources.

 -- Function: int lw6srv_analyse_tcp (lw6srv_backend_t * BACKEND,
          lw6srv_tcp_accepter_t * TCP_ACCEPTER, lw6nod_info_t *
          NODE_INFO, u_int64_t * REMOTE_ID, char ** REMOTE_URL)
     BACKEND:  server backend to use

     TCP_ACCEPTER:  TCP mode accepter

     NODE_INFO:  this node information

     REMOTE_ID:  remote host id (out param)

     REMOTE_URL:  remote host URL (out param, dynamically allocated)

     Analyzes new TCP messages, typically handled within the accepter
     object. The result is a combination of bitwise flags, namely
     namely `LW6SRV_ANALYSE_DEAD', `LW6SRV_ANALYSE_UNDERSTANDABLE', and
     `LW6SRV_ANALYSE_OOB' which helps knowing what to do with message.

     *Return value:*  bitwise flag.

 -- Function: int lw6srv_analyse_udp (lw6srv_backend_t * BACKEND,
          lw6srv_udp_buffer_t * UDP_BUFFER, lw6nod_info_t * NODE_INFO,
          u_int64_t * REMOTE_ID, char ** REMOTE_URL)
     BACKEND:  server backend to use

     UDP_BUFFER:  UDP buffer

     NODE_INFO:  this node information

     REMOTE_ID:  remote host id (out param)

     REMOTE_URL:  remote host URL (out param, dynamically allocated)

     Analyzes an UDP buffer, received on a socket.  The result is a
     combination of bitwise flags, namely namely `LW6SRV_ANALYSE_DEAD',
     `LW6SRV_ANALYSE_UNDERSTANDABLE', and `LW6SRV_ANALYSE_OOB' which
     helps knowing what to do with message.

     *Return value:*  bitwise flag.

 -- Function: int lw6srv_process_oob (lw6srv_backend_t * BACKEND,
          lw6nod_info_t * NODE_INFO, lw6srv_oob_data_t * OOB_DATA)
     BACKEND:  server backend to use

     NODE_INFO:  this node information

     OOB_DATA:  OOB data received

     Processes an OOB message sent from a client.

     *Return value:*  1 if OK, 0 if not.

 -- Function: lw6cnx_connection_t * lw6srv_open (lw6srv_backend_t *
          BACKEND, lw6srv_listener_t * LISTENER, char * LOCAL_URL, char
          * REMOTE_URL, char * REMOTE_IP, int REMOTE_PORT, char *
          PASSWORD, u_int64_t LOCAL_ID, u_int64_t REMOTE_ID, int
          DNS_OK, int NETWORK_RELIABILITY, lw6cnx_recv_callback_t
          RECV_CALLBACK_FUNC, void * RECV_CALLBACK_DATA)
     BACKEND:  server backend to use

     LOCAL_URL:  local url to use (to send to peer)

     REMOTE_URL:  remote url to communicate with

     REMOTE_IP:  remote ip to communicate with

     REMOTE_PORT:  remote port to communicate with

     PASSWORD:  password to use (the real password, not a hash)

     LOCAL_ID:  the local 64-bit id

     REMOTE_ID:  the remove 64-bit id

     DNS_OK:  1 if no DNS mismatch, 0 if situation is unclear

     NETWORK_RELIABILITY:  the greater, the more reliable it is

     RECV_CALLBACK_FUNC:  callback fired when receiving data

     RECV_CALLBACK_DATA:  additionnal data passed to callback

     Opens a server connection. One might wonder, clients open
     connections, but servers? To some extent, this is the equivalent
     of `accept' in the socket API, it will actually create an object
     one can then use to communicate. Be carefull with the
     implementation of the callback, keep in mind it can be called any
     time in multithreaded mode, you need to set up locks when
     accessing shared objects, including, but not limited to, your own
     data buffers.

     *Return value:*  new connection object.

 -- Function: int lw6srv_feed_with_tcp (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION, lw6srv_tcp_accepter_t *
          TCP_ACCEPTER)
     CONNECTION:  connection to use

     TCP_ACCEPTER:  TCP accepter holding data

     When data is receivedm feeds the server object with data.  Will
     typically fire the callback receive function if there are actually
     some data stuff.

     *Return value:*  1 some data processed, else 0

 -- Function: int lw6srv_feed_with_udp (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION, lw6srv_udp_buffer_t *
          UDP_BUFFER)
     CONNECTION:  connection to use

     When data is receivedm feeds the server object with data.  Will
     typically fire the callback receive function if there are actually
     some data stuff.

     *Return value:*  1 some data processed, else 0

 -- Function: void lw6srv_close (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION)
     BACKEND:  server backend to use

     CONNECTION:  connection to close

     Closes a connection, will also free it.

     *Return value:*  none.

 -- Function: int lw6srv_send (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, char * MESSAGE)
     BACKEND:  server backend to use

     CONNECTION:  connection to use

     PHYSICAL_TICKET_SIG:  physical ticket

     LOGICAL_TICKET_SIG:  logical ticket

     LOGICAL_FROM_ID:  logical id of sender

     LOGICAL_TO_ID:  logical id of receiver

     MESSAGE:  string with the message to send

     Sends a message. The added value with a plain send is that it
     handles all the special ticket fields.

     *Return value:*  1 on success, 0 if not

 -- Function: void lw6srv_poll (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION)
     BACKEND:  server backend to use

     CONNECTION:  connection to use

     Polling function, to be called on a regular basis.

     *Return value:*  none.

 -- Function: char * lw6srv_repr (lw6srv_backend_t * BACKEND,
          lw6cnx_connection_t * CONNECTION)
     BACKEND:  backend to use

     CONNECTION:  connection to represent

     Gives a human readable representation of the connection.

     *Return value:*  dynamically allocated string.

 -- Function: lw6srv_listener_t * lw6srv_start (char * IP, int PORT)
     IP:  ip address to listen on

     PORT:  port IP to bind to

     Starts a server, binds the socket(s) and returns a listener object
     which can in turn be used to create connections.

     *Return value:*  new listener object.

 -- Function: void lw6srv_stop (lw6srv_listener_t * LISTENER)
     LISTENER:  listener to stop

     Stops a listener object, and frees it.

     *Return value:*  none.

 -- Function: lw6srv_oob_t * lw6srv_oob_new (char * REMOTE_IP, int
          REMOTE_PORT, int SOCK, char * FIRST_LINE)
     REMOTE_IP:  remote IP address

     REMOTE_PORT:  remote port

     SOCK:  the socket handler (either TCP or UDP)

     FIRST_LINE:  the first line of data (can be NULL)

     Create a new OOB structure, copying required objects.  We need to
     make copies for this is for usage in a separate thread. The thread
     member is not set here since the right way to do things is first to
     set up data then to fire the thread.

     *Return value:*  new object

 -- Function: void lw6srv_oob_free (lw6srv_oob_t * OOB)
     OOB:  the object to free

     Frees an OOB structure.

     *Return value:*  none

 -- Function: char * lw6srv_default_backends ()
     Returns the list of the default srv backends.

     *Return value:*  comma separated string, must not be freed.

 -- Function: lw6sys_assoc_t * lw6srv_get_backends (int ARGC, const
          char * [] ARGV)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     List available srv backends. The hash contains pairs with id and
     name for each backend. The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface. The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:*  hash containing id/name pairs.

 -- Function: lw6srv_backend_t * lw6srv_create_backend (int ARGC, const
          char * [] ARGV, char * NAME)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     NAME:  string containing srv key, typically got from
     `lw6srv_get_backends'

     Creates a srv backend, this is just about loading the dynamic
     library if needed, and/or check srv engine is available, and
     connect to it. It does not perform initialization.

     *Return value:*  srv backend.

 -- Function: void lw6srv_destroy_backend (lw6srv_backend_t * BACKEND)
     BACKEND:  backend to destroy

     Destroys a srv backend.

     *Return value:*  none.

 -- Function: lw6srv_tcp_accepter_t * lw6srv_tcp_accepter_new (char *
          CLIENT_IP, int CLIENT_PORT, int SOCK)
     CLIENT_IP:  the client ip, will be freed when accepter is freed,
     do not copy it

     CLIENT_PORT:  the client port

     SOCK:  the socket used

     Creates a tcp_accepter object.

     *Return value:*  none

 -- Function: void lw6srv_tcp_accepter_free (lw6srv_tcp_accepter_t *
          TCP_ACCEPTER)
     TCP_ACCEPTER:  the object to free

     Frees a tcp_accepter object.

     *Return value:*  none

 -- Function: int lw6srv_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `srv' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: lw6srv_udp_buffer_t * lw6srv_udp_buffer_new (char *
          CLIENT_IP, int CLIENT_PORT, char * LINE)
     CLIENT_IP:  the client ip, will be freed when object is freed, do
     not free it

     CLIENT_PORT:  the client port

     LINE:  the line received, will be freed when object is freed, do
     not free it

     Creates an udp_buffer object.

     *Return value:*  none

 -- Function: void lw6srv_udp_buffer_free (lw6srv_udp_buffer_t *
          UDP_BUFFER)
     UDP_BUFFER:  the object to free

     Frees a udp_buffer object.

     *Return value:*  none


File: liquidwar6.info,  Node: mod-httpd,  Next: mod-tcpd,  Prev: libsrv,  Up: C API

5.38 mod-httpd
==============

5.38.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/srv/mod-httpd/index.html'.

5.38.2 API
----------


File: liquidwar6.info,  Node: mod-tcpd,  Next: mod-udpd,  Prev: mod-httpd,  Up: C API

5.39 mod-tcpd
=============

5.39.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/srv/mod-tcpd/index.html'.

5.39.2 API
----------


File: liquidwar6.info,  Node: mod-udpd,  Next: libsys,  Prev: mod-tcpd,  Up: C API

5.40 mod-udpd
=============

5.40.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/srv/mod-udpd/index.html'.

5.40.2 API
----------

