This is /home/ufoot/Home/_/liquidwar6/doc/liquidwar6.info, produced by
makeinfo version 4.13 from
/home/ufoot/Home/_/liquidwar6/doc/liquidwar6.texi.

Liquid War 6, a unique multiplayer wargame.

   Copyright (c)  2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
Christian Mauduit <ufoot@ufoot.org>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

START-INFO-DIR-ENTRY
* Liquid War 6: (liquidwar6).   A unique multiplayer wargame.
END-INFO-DIR-ENTRY


File: liquidwar6.info,  Node: libdsp,  Next: libdyn,  Prev: libdef,  Up: C API

5.16 libdsp
===========

5.16.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/dsp/index.html'.

5.16.2 API
----------

 -- Function: lw6dsp_backend_t * lw6dsp_create_backend (int ARGC, const
          char * [] ARGV, const char * GFX_BACKEND_NAME)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     GFX_BACKEND_NAME:  the id/name of the gfx backend to use

     Creates a dsp_backend object. The created object won't be
     displaying things until `lw6dsp_init' is called. No thread is
     created, but the graphics backend is loaded into memory. If video
     mode is not available, it will appear later, when trying to start
     displaying things, this function only allocates memory and checks
     code is available in case of a dynamically loaded gfx backend.

     *Return value:*  a newly allocated object.

 -- Function: void lw6dsp_destroy_backend (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend object to free

     Frees all ressources used by a dsp_backend object. Note that you
     must call this on a inactive 'stopped' dsp_backend object.

     *Return value:*  none.

 -- Function: char * lw6dsp_repr (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the object to represent

     Gives a short human-readable description of the object.

     *Return value:*  a newly allocated string, must be freed.

 -- Function: int lw6dsp_init (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM, lw6gui_resize_callback_func_t
          RESIZE_CALLBACK)
     DSP_BACKEND:  the dsp_backend to start

     PARAM:  parameters to pass to the display funcs

     RESIZE_CALLBACK:  a function which will be called when there's a
     resize event

     Starts a dsp_backend object, that is, fire a separate thread and
     start rendering. This will set up a video mode, so it's very
     likely to fail if for some reason the video context isn't right,
     for instance if you try to set up graphical stuff but only have
     console access.

     *Return value:*  1 if success, 0 if error.

 -- Function: void lw6dsp_quit (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to stop

     Stops a dsp_backend, that is, cancel rendering and unset the video
     mode, hardware shouldn't be used any more after this call.

     *Return value:*  none.

 -- Function: int lw6dsp_update (lw6dsp_backend_t * DSP_BACKEND,
          lw6dsp_param_t * PARAM)
     DSP_BACKEND:  the dsp_backend to update

     PARAM:  parameters to pass to the dsp_backend funcs

     Passes a new set of parameters to the display function.  This is
     in fact the only way to pass informations to the dsp_backend
     object once it's been started. This function will acquire a mutex,
     copy parameters, then give control back to the main thread while
     display keeps on going with new parameters in the background. It
     will get input informations.  You really must call it often
     otherwise the screen won't get updated, or, at least, it will
     always display the same informations.  It should be reasonnable to
     call this 10 or 20 times per second, the display itself can be
     faster, run at 60 or 100 fps to show smooth animation (eye candy).

     *Return value:*  1 if success, 0 if error.

 -- Function: int lw6dsp_get_nb_frames (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the number of frames displayed since the display was
     started.

     *Return value:*  the number of frames displayed.

 -- Function: int lw6dsp_get_last_frame_rendering_time
          (lw6dsp_backend_t * DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the rendering time of the last frame. Gives clues about
     performance.

     *Return value:*  the number of milliseconds it took to draw screen

 -- Function: int lw6dsp_get_instant_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is the
     instant value, it changes very often even if display seems smooth.

     *Return value:*  the current instant display rate.

 -- Function: int lw6dsp_get_average_fps (lw6dsp_backend_t *
          DSP_BACKEND)
     DSP_BACKEND:  the dsp_backend to query

     Returns the current frames per sec display rate. This is not
     absolutely accurate but fits for displaying info to the player,
     it's an average.

     *Return value:*  the current averaged display rate.

 -- Function: int lw6dsp_get_video_mode (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_video_mode_t * VIDEO_MODE)
     DSP_BACKEND:  the dsp_backend to query

     VIDEO_MODE:  a structure which will contain the results

     Returns the current video mode, the one obtained by the driver.
     This function is also a way to know wether display is running
     correcly or not, by testing its return value.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: int lw6dsp_get_fullscreen_modes (lw6dsp_backend_t *
          DSP_BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     DSP_BACKEND:  the dsp_backend to query

     FULLSCREEN_MODES:  a structure which will contain the results

     Returns the current available fullscreen modes. Note that this one
     will only work if display is started, unlike
     `lw6gfx_get_fullscreen_modes' which is used internally. The reason
     is that in this dsp module context, we need the thread to be
     launched, and the thread does start/stop display on its own.

     *Return value:*  1 if ok, 0 if failure (mode not set)

 -- Function: void lw6dsp_param_zero (lw6dsp_param_t * PARAM)
     PARAM:  the structure to initialize

     Fills a display param struct with zeros, this is mandatory before
     any use. Think of it as a raw memset.

     *Return value:*  none.

 -- Function: int lw6dsp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the test suite for the dsp module. In check (0) mode, won't
     test much to avoid failure because of missing graphical
     environment.

     *Return value:*  1 if OK, 0 if error.

 -- struct: lw6dsp_backend_s

 -- member of lw6dsp_backend_s: id
          u_int32_t lw6dsp_backend_s::id


 -- member of lw6dsp_backend_s: thread
          void* lw6dsp_backend_s::thread


 -- member of lw6dsp_backend_s: data
          void* lw6dsp_backend_s::data


 -- member of lw6dsp_backend_s: input
          lw6gui_input_t* lw6dsp_backend_s::input


 -- struct: lw6dsp_misc_s

 -- member of lw6dsp_misc_s: mask
          int lw6dsp_misc_s::mask


 -- member of lw6dsp_misc_s: target_fps
          int lw6dsp_misc_s::target_fps


 -- member of lw6dsp_misc_s: gfx_cpu_usage
          float lw6dsp_misc_s::gfx_cpu_usage


 -- member of lw6dsp_misc_s: dirty_read
          int lw6dsp_misc_s::dirty_read


 -- member of lw6dsp_misc_s: capture
          int lw6dsp_misc_s::capture


 -- member of lw6dsp_misc_s: gfx_debug
          int lw6dsp_misc_s::gfx_debug


 -- member of lw6dsp_misc_s: debug_team_id
          int lw6dsp_misc_s::debug_team_id


 -- member of lw6dsp_misc_s: debug_layer_id
          int lw6dsp_misc_s::debug_layer_id


 -- member of lw6dsp_misc_s: repeat_settings
          lw6gui_repeat_settings_t lw6dsp_misc_s::repeat_settings


 -- member of lw6dsp_misc_s: log_timeout
          int lw6dsp_misc_s::log_timeout


 -- member of lw6dsp_misc_s: progress
          volatile float* lw6dsp_misc_s::progress


 -- struct: lw6dsp_param_s

 -- member of lw6dsp_param_s: misc
          lw6dsp_misc_t lw6dsp_param_s::misc


 -- member of lw6dsp_param_s: video_mode
          lw6gui_video_mode_t lw6dsp_param_s::video_mode


 -- member of lw6dsp_param_s: look
          lw6gui_look_t* lw6dsp_param_s::look


 -- member of lw6dsp_param_s: menu
          lw6gui_menu_t* lw6dsp_param_s::menu


 -- member of lw6dsp_param_s: level
          lw6map_level_t* lw6dsp_param_s::level


 -- member of lw6dsp_param_s: game_struct
          lw6ker_game_struct_t* lw6dsp_param_s::game_struct


 -- member of lw6dsp_param_s: game_state
          lw6ker_game_state_t* lw6dsp_param_s::game_state


 -- member of lw6dsp_param_s: pilot
          lw6pil_pilot_t* lw6dsp_param_s::pilot



File: liquidwar6.info,  Node: libdyn,  Next: libgfx,  Prev: libdsp,  Up: C API

5.17 libdyn
===========

5.17.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/dyn/index.html'.

5.17.2 API
----------

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend_so (const char
          * SO_FILE)
     Opens a .so file directly, using a valid (full) path name.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: lw6dyn_dl_handle_t * lw6dyn_dlopen_backend (int ARGC,
          const char * [] ARGV, const char * TOP_LEVEL_LIB, const char
          * BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     Opens a .so file corresponding to the given backend, it is capable
     to search for system libraries installed after "make install" but
     if not found, it will also search in the current build directory,
     finding the .so files in hidden .libs subdirectories.

     *Return value:*  a handle to the module, once it's opened. You
     might still need to call a module specific `init'() function, but
     it's another story.

 -- Function: int lw6dyn_dlclose_backend (lw6dyn_dl_handle_t * HANDLE)
     HANDLE:  the backend to close.

     Closes an opened backend. Note that you must call any backend
     specific clear, destroy, deinit, exit, function before.

     *Return value:*  1 if success, 0 on error.

 -- Function: void * lw6dyn_dlsym (lw6dyn_dl_handle_t * HANDLE, const
          char * FUNC_NAME)
     HANDLE:  the backend concerned

     FUNC_NAME:  the function name, as a NULL terminated string

     Finds a C function in the given backend.

     *Return value:*  a pointer to the function, NULL if not found.

 -- Function: lw6sys_assoc_t * lw6dyn_list_backends (int ARGC, const
          char * [] ARGV, const char * TOP_LEVEL_LIB)
     ARGC:  the number of command line args, as passed to main

     ARGV:  the commind line args, as passed to main

     TOP_LEVEL_LIB:  the library category to query (gfx, snd, cli, srv
     ...)

     Returns an assoc which lists all the available modules. The key of
     the assoc entries in the module internal name such as 'gl' and the
     value associated is a NULL terminated string describing the
     module, for instance 'OpenGL'.

     *Return value:*  an assoc object containing key/label pairs.

 -- Function: char * lw6dyn_path_find_backend (int ARGC, const char *
          [] ARGV, const char * TOP_LEVEL_LIB, const char *
          BACKEND_NAME)
     ARGC:  the number of command-line arguments as passed to `main'

     TOP_LEVEL_LIB:  the top-level library concerned, this means is it
     "cli", "gfx", "snd" or "srv". This will tell the function to search
     for the .so file in the correct subdirectory. Think of this as a
     category.

     BACKEND_NAME:  the actual name of the backend, this is the name of
     the .so file, between "libmod_" and ".so". For instance, to find
     "libmod_gl.so", the right argument is "gl".

     Get the full path to a .so file corresponding to the given backend,
     it is capable to search for system libraries installed after "make
     install" but if not found, it will also search in the current
     build directory, finding the .so files in hidden .libs
     subdirectories.

     *Return value:*  the full path of the .so file, needs to be freed.

 -- Function: int lw6dyn_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `dyn' module test suite, testing most (if not all...)
     functions. Will try to load libraries and query them for standard
     LW6-expected functions.

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6dyn_dl_handle_s

 -- member of lw6dyn_dl_handle_s: handle
          lt_dlhandle lw6dyn_dl_handle_s::handle


 -- member of lw6dyn_dl_handle_s: library_path
          char* lw6dyn_dl_handle_s::library_path



File: liquidwar6.info,  Node: libgfx,  Next: mod-gl,  Prev: libdyn,  Up: C API

5.18 libgfx
===========

5.18.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gfx/index.html'.

5.18.2 API
----------

 -- Function: int lw6gfx_init (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE,
          lw6gui_resize_callback_func_t RESIZE_CALLBACK)
     BACKEND:  the graphical backend to use

     VIDEO_MODE:  the video mode to use at start up

     RESIZE_CALLBACK:  a callback function which will be called at each
     resize event

     Sets up the graphical backend for good, initializing a video mode
     and allocating ressources. This call can typically fail if there's
     no device available, if the user doesn't have enough rights to
     access the hardware, and so on.

     *Return value:*  1 on success, 0 if not

 -- Function: void lw6gfx_quit (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to quit

     Uninitializes the backend, that is, exits the graphical mode. All
     threads that use graphics must be closed when this is called.

     *Return value:*  none.

 -- Function: char * lw6gfx_repr (lw6gfx_backend_t * BACKEND)
     BACKEND:  the backend to represent

     Returns a readable version of the backend object.

     *Return value:*  a newly allocated pointer.

 -- Function: int lw6gfx_set_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the new video mode

     This function changes the video mode. Note that the first time you
     set up the graphical environment you must call `lw6gfx_init' but
     to change the current mode, use this function. It should reload
     backend data automatically if needed (textures for instance). Note
     that before giving up and failing this function will try alternate
     video modes, and you're not garanteed to have the right mode after
     the call, even if it returns true. To check this, use
     `lw6gfx_get_video_mode'.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_video_mode (lw6gfx_backend_t * BACKEND,
          lw6gui_video_mode_t * VIDEO_MODE)
     BACKEND:  the backend to use

     VIDEO_MODE:  the current video mode (will be overwritten, out
     parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: int lw6gfx_get_fullscreen_modes (lw6gfx_backend_t *
          BACKEND, lw6gui_fullscreen_modes_t * FULLSCREEN_MODES)
     BACKEND:  the backend to use

     FULLSCREEN_MODES:  the available fullscreen modes (will be
     overwritten, out parameter)

     This function returns the current video mode.

     *Return value:*  1 on success, 0 on failure;

 -- Function: lw6gui_input_t * lw6gfx_pump_events (lw6gfx_backend_t *
          BACKEND)
     BACKEND:  the backend to use

     This function "pumps" events, that is gets pending events, puts
     them in queues, maintains internal states up to date. You really
     must call this very often or no input will be processed at all.

     *Return value:*  a pointer on the internal input state, musn't be
     freed.

 -- Function: int lw6gfx_display (lw6gfx_backend_t * BACKEND, int MASK,
          lw6gui_look_t * LOOK, lw6map_level_t * LEVEL,
          lw6ker_game_struct_t * GAME_STRUCT, lw6ker_game_state_t *
          GAME_STATE, lw6pil_local_cursors_t * LOCAL_CURSORS,
          lw6gui_menu_t * MENU, float PROGRESS, float FPS, float MPS,
          char ** LOG_LIST, int CAPTURE, int GFX_DEBUG, int
          DEBUG_TEAM_ID, int DEBUG_LAYER_ID)
     BACKEND:  the graphical backend to use

     MASK:  display flag, tells what to display

     LOOK:  the look, the skin, contains display options

     LEVEL:  the level to display

     GAME_STRUCT:  the game_struct associated with the level

     GAME_STATE:  the game_state associated with the level

     LOCAL_CURSORS:  the cursor to center the focus on

     MENU:  the menu to display

     PROGRESS:  the value of the progress indicator

     FPS:  the number of frames per second to display

     MPS:  the number of moves per second to display

     LOG_LIST:  log messages to display

     CAPTURE:  wether to enable capture mode or not

     GFX_DEBUG:  wether to enable gfx debugging tools

     DEBUG_TEAM_ID:  for debug display, team to display informations
     about

     DEBUG_LAYER_ID:  for debug display, layer to display

     This is the major drawing function, the one that encapsulates all
     others. As the program uses a separate thread to display things,
     we just pass this function many parameters, and let it do its job
     alone. So many parameters might sometimes be useless. It also
     allows the graphics backend decide wether menus and hud and
     background should interact. Or not.

     *Return value:*  1 on success, 0 on failure.

 -- Function: lw6sys_assoc_t * lw6gfx_get_backends (int ARGC, const
          char * [] ARGV)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     List available gfx backends. The hash contains pairs with id and
     name for each backend. The id is the technical key you can use to
     load the backend, the name is something more readable you can
     display in an interface. The backend objects themselves are not
     instanciated by this (in fact, they are, but released on the fly)
     you need to load and initialize them afterwards.

     *Return value:*  hash containing id/name pairs.

 -- Function: lw6gfx_backend_t * lw6gfx_create_backend (int ARGC, const
          char * [] ARGV, char * NAME)
     ARGC:  argc, as passed to `main'

     ARGV:  argv, as passed to `main'

     NAME:  string containing gfx key, typically got from
     `lw6gfx_get_backends'

     Creates a gfx backend, this is just about loading the dynamic
     library if needed, and/or check gfx engine is available, and
     connect to it. It does not perform initialization.

     *Return value:*  gfx backend.

 -- Function: void lw6gfx_destroy_backend (lw6gfx_backend_t * BACKEND)
     BACKEND:  gfx backend to destroy

     Frees the ressources associated to a gfx, which must have been
     properly uninitialized before.

     *Return value:*  none.

 -- Function: int lw6gfx_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `gfx' module test suite. In check-only mode, this
     function won't test many things, for it requires a graphical mode
     to be available to perform the complete test.

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6gfx_backend_s

 -- member of lw6gfx_backend_s: dl_handle
          lw6dyn_dl_handle_t* lw6gfx_backend_s::dl_handle


 -- member of lw6gfx_backend_s: gfx_context
          void* lw6gfx_backend_s::gfx_context


 -- member of lw6gfx_backend_s: argc
          int lw6gfx_backend_s::argc


 -- member of lw6gfx_backend_s: argv
          const char** lw6gfx_backend_s::argv


 -- member of lw6gfx_backend_s: id
          u_int32_t lw6gfx_backend_s::id


 -- member of lw6gfx_backend_s: init
          void*(* lw6gfx_backend_s::init)(int argc, const char *argv[], lw6gui_video_mode_t *video_mode, lw6gui_resize_callback_func_t resize_callback)


 -- member of lw6gfx_backend_s: quit
          void(* lw6gfx_backend_s::quit)(void *gfx_context)


 -- member of lw6gfx_backend_s: repr
          char*(* lw6gfx_backend_s::repr)(void *gfx_context, u_int32_t id)


 -- member of lw6gfx_backend_s: set_video_mode
          int(* lw6gfx_backend_s::set_video_mode)(void *gfx_context, lw6gui_video_mode_t *video_mode)


 -- member of lw6gfx_backend_s: get_video_mode
          int(* lw6gfx_backend_s::get_video_mode)(void *gfx_context, lw6gui_video_mode_t *video_mode)


 -- member of lw6gfx_backend_s: get_fullscreen_modes
          int(* lw6gfx_backend_s::get_fullscreen_modes)(void *gfx_context, lw6gui_fullscreen_modes_t *modes)


 -- member of lw6gfx_backend_s: pump_events
          lw6gui_input_t*(* lw6gfx_backend_s::pump_events)(void *gfx_context)


 -- member of lw6gfx_backend_s: display
          int(* lw6gfx_backend_s::display)(void *gfx_context, int mask, lw6gui_look_t *look, lw6map_level_t *level, lw6ker_game_struct_t *game_struct, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors, lw6gui_menu_t *menu, float progress, float fps, float mps, char **log_list, int capture, int gfx_debug, int debug_team_id, int debug_layer_id)



File: liquidwar6.info,  Node: mod-gl,  Next: libglb,  Prev: libgfx,  Up: C API

5.19 mod-gl
===========

5.19.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gfx/mod-gl/gl-utils/index.html'
(as there are many sub-directories in this module, please refer to the
test coverage directory index
(http://www.gnu.org/software/liquidwar6/coverage/index.html) for
complete information).

5.19.2 API
----------

 -- struct: mod_gl_background_backend_s

 -- member of mod_gl_background_backend_s: background_context
          void* mod_gl_background_backend_s::background_context


 -- member of mod_gl_background_backend_s: backend_name
          char* mod_gl_background_backend_s::backend_name


 -- member of mod_gl_background_backend_s: init
          void*(* mod_gl_background_backend_s::init)(mod_gl_utils_context_t *utils_context)


 -- member of mod_gl_background_backend_s: quit
          void(* mod_gl_background_backend_s::quit)(mod_gl_utils_context_t *utils_context, void *background_context)


 -- member of mod_gl_background_backend_s: display_background
          void(* mod_gl_background_backend_s::display_background)(mod_gl_utils_context_t *utils_context, void *background_context, lw6gui_look_t *look)


 -- struct: mod_gl_hud_backend_s

 -- member of mod_gl_hud_backend_s: hud_context
          void* mod_gl_hud_backend_s::hud_context


 -- member of mod_gl_hud_backend_s: backend_name
          char* mod_gl_hud_backend_s::backend_name


 -- member of mod_gl_hud_backend_s: init
          void*(* mod_gl_hud_backend_s::init)(mod_gl_utils_context_t *utils_context)


 -- member of mod_gl_hud_backend_s: quit
          void(* mod_gl_hud_backend_s::quit)(mod_gl_utils_context_t *utils_context, void *hud_context)


 -- member of mod_gl_hud_backend_s: display_hud
          void(* mod_gl_hud_backend_s::display_hud)(mod_gl_utils_context_t *utils_context, void *hud_context, lw6gui_look_t *look, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors)


 -- member of mod_gl_hud_backend_s: display_score
          void(* mod_gl_hud_backend_s::display_score)(mod_gl_utils_context_t *utils_context, void *hud_context, lw6gui_look_t *look, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors)


 -- struct: mod_gl_menu_backend_s

 -- member of mod_gl_menu_backend_s: menu_context
          void* mod_gl_menu_backend_s::menu_context


 -- member of mod_gl_menu_backend_s: backend_name
          char* mod_gl_menu_backend_s::backend_name


 -- member of mod_gl_menu_backend_s: init
          void*(* mod_gl_menu_backend_s::init)(mod_gl_utils_context_t *utils_context)


 -- member of mod_gl_menu_backend_s: quit
          void(* mod_gl_menu_backend_s::quit)(mod_gl_utils_context_t *utils_context, void *menu_context)


 -- member of mod_gl_menu_backend_s: display_menu
          void(* mod_gl_menu_backend_s::display_menu)(mod_gl_utils_context_t *utils_context, void *menu_context, lw6gui_look_t *look, lw6gui_menu_t *menu)


 -- member of mod_gl_menu_backend_s: display_progress
          void(* mod_gl_menu_backend_s::display_progress)(mod_gl_utils_context_t *utils_context, void *menu_context, lw6gui_look_t *look, float progress)


 -- member of mod_gl_menu_backend_s: display_meta
          void(* mod_gl_menu_backend_s::display_meta)(mod_gl_utils_context_t *utils_context, void *menu_context, lw6gui_look_t *look, lw6gui_menu_t *menu)


 -- struct: mod_gl_utils_bitmap_array_s

 -- member of mod_gl_utils_bitmap_array_s: layout
          lw6gui_rect_array_t mod_gl_utils_bitmap_array_s::layout


 -- member of mod_gl_utils_bitmap_array_s: bitmaps
          mod_gl_utils_bitmap_t** mod_gl_utils_bitmap_array_s::bitmaps


 -- struct: mod_gl_utils_bitmap_s

 -- member of mod_gl_utils_bitmap_s: id
          u_int32_t mod_gl_utils_bitmap_s::id


 -- member of mod_gl_utils_bitmap_s: desc
          char* mod_gl_utils_bitmap_s::desc


 -- member of mod_gl_utils_bitmap_s: surface
          SDL_Surface* mod_gl_utils_bitmap_s::surface


 -- member of mod_gl_utils_bitmap_s: has_alpha
          int mod_gl_utils_bitmap_s::has_alpha


 -- member of mod_gl_utils_bitmap_s: colorized_surface
          SDL_Surface* mod_gl_utils_bitmap_s::colorized_surface


 -- member of mod_gl_utils_bitmap_s: colorize
          int mod_gl_utils_bitmap_s::colorize


 -- member of mod_gl_utils_bitmap_s: colorize_color
          lw6map_color_couple_t mod_gl_utils_bitmap_s::colorize_color


 -- member of mod_gl_utils_bitmap_s: mipmap
          int mod_gl_utils_bitmap_s::mipmap


 -- member of mod_gl_utils_bitmap_s: wrap
          GLint mod_gl_utils_bitmap_s::wrap


 -- member of mod_gl_utils_bitmap_s: filter
          GLint mod_gl_utils_bitmap_s::filter


 -- member of mod_gl_utils_bitmap_s: texture
          GLuint mod_gl_utils_bitmap_s::texture


 -- member of mod_gl_utils_bitmap_s: texture_w
          int mod_gl_utils_bitmap_s::texture_w


 -- member of mod_gl_utils_bitmap_s: texture_h
          int mod_gl_utils_bitmap_s::texture_h


 -- member of mod_gl_utils_bitmap_s: s1
          float mod_gl_utils_bitmap_s::s1


 -- member of mod_gl_utils_bitmap_s: t1
          float mod_gl_utils_bitmap_s::t1


 -- member of mod_gl_utils_bitmap_s: s2
          float mod_gl_utils_bitmap_s::s2


 -- member of mod_gl_utils_bitmap_s: t2
          float mod_gl_utils_bitmap_s::t2


 -- member of mod_gl_utils_bitmap_s: last_refresh
          int64_t mod_gl_utils_bitmap_s::last_refresh


 -- member of mod_gl_utils_bitmap_s: need_another_refresh
          int mod_gl_utils_bitmap_s::need_another_refresh


 -- struct: mod_gl_utils_cache_s

 -- member of mod_gl_utils_cache_s: color_set
          lw6map_color_set_t mod_gl_utils_cache_s::color_set


 -- struct: mod_gl_utils_caps_s

 -- member of mod_gl_utils_caps_s: max_texture_size
          GLint mod_gl_utils_caps_s::max_texture_size


 -- member of mod_gl_utils_caps_s: bpp
          int mod_gl_utils_caps_s::bpp


 -- struct: mod_gl_utils_const_data_s

 -- member of mod_gl_utils_const_data_s: warp_x
          float mod_gl_utils_const_data_s::warp_x


 -- member of mod_gl_utils_const_data_s: warp_y
          float mod_gl_utils_const_data_s::warp_y


 -- member of mod_gl_utils_const_data_s: mode_sleep
          float mod_gl_utils_const_data_s::mode_sleep


 -- member of mod_gl_utils_const_data_s: quit_sleep
          float mod_gl_utils_const_data_s::quit_sleep


 -- member of mod_gl_utils_const_data_s: persp_fovy
          float mod_gl_utils_const_data_s::persp_fovy


 -- member of mod_gl_utils_const_data_s: persp_znear
          float mod_gl_utils_const_data_s::persp_znear


 -- member of mod_gl_utils_const_data_s: persp_zfar
          float mod_gl_utils_const_data_s::persp_zfar


 -- member of mod_gl_utils_const_data_s: menu_font_size
          int mod_gl_utils_const_data_s::menu_font_size


 -- member of mod_gl_utils_const_data_s: hud_font_size
          int mod_gl_utils_const_data_s::hud_font_size


 -- member of mod_gl_utils_const_data_s: cursor_font_size
          int mod_gl_utils_const_data_s::cursor_font_size


 -- member of mod_gl_utils_const_data_s: system_font_size
          int mod_gl_utils_const_data_s::system_font_size


 -- member of mod_gl_utils_const_data_s: system_font_dh
          int mod_gl_utils_const_data_s::system_font_dh


 -- member of mod_gl_utils_const_data_s: system_font_dw
          int mod_gl_utils_const_data_s::system_font_dw


 -- member of mod_gl_utils_const_data_s: system_font_hcoef
          float mod_gl_utils_const_data_s::system_font_hcoef


 -- member of mod_gl_utils_const_data_s: gradient_opacity
          float mod_gl_utils_const_data_s::gradient_opacity


 -- member of mod_gl_utils_const_data_s: zones_opacity
          float mod_gl_utils_const_data_s::zones_opacity


 -- member of mod_gl_utils_const_data_s: mainlight_r
          float mod_gl_utils_const_data_s::mainlight_r


 -- member of mod_gl_utils_const_data_s: mainlight_g
          float mod_gl_utils_const_data_s::mainlight_g


 -- member of mod_gl_utils_const_data_s: mainlight_b
          float mod_gl_utils_const_data_s::mainlight_b


 -- member of mod_gl_utils_const_data_s: mainlight_a
          float mod_gl_utils_const_data_s::mainlight_a


 -- member of mod_gl_utils_const_data_s: mainlight_x
          float mod_gl_utils_const_data_s::mainlight_x


 -- member of mod_gl_utils_const_data_s: mainlight_y
          float mod_gl_utils_const_data_s::mainlight_y


 -- member of mod_gl_utils_const_data_s: mainlight_z
          float mod_gl_utils_const_data_s::mainlight_z


 -- member of mod_gl_utils_const_data_s: keysym1_up
          int mod_gl_utils_const_data_s::keysym1_up


 -- member of mod_gl_utils_const_data_s: keysym2_up
          int mod_gl_utils_const_data_s::keysym2_up


 -- member of mod_gl_utils_const_data_s: keysym3_up
          int mod_gl_utils_const_data_s::keysym3_up


 -- member of mod_gl_utils_const_data_s: keysym4_up
          int mod_gl_utils_const_data_s::keysym4_up


 -- member of mod_gl_utils_const_data_s: keysym1_down
          int mod_gl_utils_const_data_s::keysym1_down


 -- member of mod_gl_utils_const_data_s: keysym2_down
          int mod_gl_utils_const_data_s::keysym2_down


 -- member of mod_gl_utils_const_data_s: keysym3_down
          int mod_gl_utils_const_data_s::keysym3_down


 -- member of mod_gl_utils_const_data_s: keysym4_down
          int mod_gl_utils_const_data_s::keysym4_down


 -- member of mod_gl_utils_const_data_s: keysym1_left
          int mod_gl_utils_const_data_s::keysym1_left


 -- member of mod_gl_utils_const_data_s: keysym2_left
          int mod_gl_utils_const_data_s::keysym2_left


 -- member of mod_gl_utils_const_data_s: keysym3_left
          int mod_gl_utils_const_data_s::keysym3_left


 -- member of mod_gl_utils_const_data_s: keysym4_left
          int mod_gl_utils_const_data_s::keysym4_left


 -- member of mod_gl_utils_const_data_s: keysym1_right
          int mod_gl_utils_const_data_s::keysym1_right


 -- member of mod_gl_utils_const_data_s: keysym2_right
          int mod_gl_utils_const_data_s::keysym2_right


 -- member of mod_gl_utils_const_data_s: keysym3_right
          int mod_gl_utils_const_data_s::keysym3_right


 -- member of mod_gl_utils_const_data_s: keysym4_right
          int mod_gl_utils_const_data_s::keysym4_right


 -- member of mod_gl_utils_const_data_s: keysym1_enter
          int mod_gl_utils_const_data_s::keysym1_enter


 -- member of mod_gl_utils_const_data_s: keysym2_enter
          int mod_gl_utils_const_data_s::keysym2_enter


 -- member of mod_gl_utils_const_data_s: keysym1_esc
          int mod_gl_utils_const_data_s::keysym1_esc


 -- member of mod_gl_utils_const_data_s: keysym2_esc
          int mod_gl_utils_const_data_s::keysym2_esc


 -- member of mod_gl_utils_const_data_s: keysym1_ctrl
          int mod_gl_utils_const_data_s::keysym1_ctrl


 -- member of mod_gl_utils_const_data_s: keysym2_ctrl
          int mod_gl_utils_const_data_s::keysym2_ctrl


 -- member of mod_gl_utils_const_data_s: keysym1_alt
          int mod_gl_utils_const_data_s::keysym1_alt


 -- member of mod_gl_utils_const_data_s: keysym2_alt
          int mod_gl_utils_const_data_s::keysym2_alt


 -- member of mod_gl_utils_const_data_s: keysym1_pgup
          int mod_gl_utils_const_data_s::keysym1_pgup


 -- member of mod_gl_utils_const_data_s: keysym2_pgup
          int mod_gl_utils_const_data_s::keysym2_pgup


 -- member of mod_gl_utils_const_data_s: keysym1_pgdown
          int mod_gl_utils_const_data_s::keysym1_pgdown


 -- member of mod_gl_utils_const_data_s: keysym2_pgdown
          int mod_gl_utils_const_data_s::keysym2_pgdown


 -- member of mod_gl_utils_const_data_s: keysym_quit
          int mod_gl_utils_const_data_s::keysym_quit


 -- member of mod_gl_utils_const_data_s: joystick_limit
          int mod_gl_utils_const_data_s::joystick_limit


 -- member of mod_gl_utils_const_data_s: joystick1_index
          int mod_gl_utils_const_data_s::joystick1_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_a_index
          int mod_gl_utils_const_data_s::joystick1_button_a_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_b_index
          int mod_gl_utils_const_data_s::joystick1_button_b_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_c_index
          int mod_gl_utils_const_data_s::joystick1_button_c_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_d_index
          int mod_gl_utils_const_data_s::joystick1_button_d_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_e_index
          int mod_gl_utils_const_data_s::joystick1_button_e_index


 -- member of mod_gl_utils_const_data_s: joystick1_button_f_index
          int mod_gl_utils_const_data_s::joystick1_button_f_index


 -- member of mod_gl_utils_const_data_s: joystick2_index
          int mod_gl_utils_const_data_s::joystick2_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_a_index
          int mod_gl_utils_const_data_s::joystick2_button_a_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_b_index
          int mod_gl_utils_const_data_s::joystick2_button_b_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_c_index
          int mod_gl_utils_const_data_s::joystick2_button_c_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_d_index
          int mod_gl_utils_const_data_s::joystick2_button_d_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_e_index
          int mod_gl_utils_const_data_s::joystick2_button_e_index


 -- member of mod_gl_utils_const_data_s: joystick2_button_f_index
          int mod_gl_utils_const_data_s::joystick2_button_f_index


 -- member of mod_gl_utils_const_data_s: joystick_all_buttons
          int mod_gl_utils_const_data_s::joystick_all_buttons


 -- member of mod_gl_utils_const_data_s: smoother_global_zoom_duration
          int mod_gl_utils_const_data_s::smoother_global_zoom_duration


 -- member of mod_gl_utils_const_data_s: smoother_center_duration
          int mod_gl_utils_const_data_s::smoother_center_duration


 -- member of mod_gl_utils_const_data_s: smoother_drawable_duration
          int mod_gl_utils_const_data_s::smoother_drawable_duration


 -- struct: mod_gl_utils_context_s

 -- member of mod_gl_utils_context_s: resize_callback
          lw6gui_resize_callback_func_t mod_gl_utils_context_s::resize_callback


 -- member of mod_gl_utils_context_s: path
          mod_gl_utils_path_t mod_gl_utils_context_s::path


 -- member of mod_gl_utils_context_s: surface_counter
          mod_gl_utils_mem_counter_t mod_gl_utils_context_s::surface_counter


 -- member of mod_gl_utils_context_s: texture_counter
          mod_gl_utils_mem_counter_t mod_gl_utils_context_s::texture_counter


 -- member of mod_gl_utils_context_s: caps
          mod_gl_utils_caps_t mod_gl_utils_context_s::caps


 -- member of mod_gl_utils_context_s: video_mode
          lw6gui_video_mode_t mod_gl_utils_context_s::video_mode


 -- member of mod_gl_utils_context_s: viewport
          lw6gui_zone_t mod_gl_utils_context_s::viewport


 -- member of mod_gl_utils_context_s: render_param
          mod_gl_utils_render_param_t mod_gl_utils_context_s::render_param


 -- member of mod_gl_utils_context_s: texture_data
          mod_gl_utils_texture_data_t mod_gl_utils_context_s::texture_data


 -- member of mod_gl_utils_context_s: font_data
          mod_gl_utils_font_data_t mod_gl_utils_context_s::font_data


 -- member of mod_gl_utils_context_s: const_data
          mod_gl_utils_const_data_t mod_gl_utils_context_s::const_data


 -- member of mod_gl_utils_context_s: textures_1x1
          mod_gl_utils_texture_1x1_t mod_gl_utils_context_s::textures_1x1


 -- member of mod_gl_utils_context_s: menucache_array
          mod_gl_utils_menucache_array_t mod_gl_utils_context_s::menucache_array


 -- member of mod_gl_utils_context_s: team_color_map
          mod_gl_utils_team_color_map_t mod_gl_utils_context_s::team_color_map


 -- member of mod_gl_utils_context_s: last_action
          mod_gl_utils_last_action_t mod_gl_utils_context_s::last_action


 -- member of mod_gl_utils_context_s: joysticks_info
          mod_gl_utils_joysticks_info_t mod_gl_utils_context_s::joysticks_info


 -- member of mod_gl_utils_context_s: mouse_state
          mod_gl_utils_mouse_state_t mod_gl_utils_context_s::mouse_state


 -- member of mod_gl_utils_context_s: timer
          mod_gl_utils_timer_t mod_gl_utils_context_s::timer


 -- member of mod_gl_utils_context_s: input
          lw6gui_input_t mod_gl_utils_context_s::input


 -- member of mod_gl_utils_context_s: smoothers
          _mod_gl_utils_smoothers_t mod_gl_utils_context_s::smoothers


 -- member of mod_gl_utils_context_s: smoothed
          _mod_gl_utils_smoothed_t mod_gl_utils_context_s::smoothed


 -- member of mod_gl_utils_context_s: icon
          mod_gl_utils_icon_t mod_gl_utils_context_s::icon


 -- member of mod_gl_utils_context_s: counter
          mod_gl_utils_counter_t mod_gl_utils_context_s::counter


 -- member of mod_gl_utils_context_s: bitmap_hash
          lw6sys_hash_t* mod_gl_utils_context_s::bitmap_hash


 -- member of mod_gl_utils_context_s: cache
          mod_gl_utils_cache_t mod_gl_utils_context_s::cache


 -- struct: mod_gl_utils_counter_s

 -- member of mod_gl_utils_counter_s: nb_frames
          int mod_gl_utils_counter_s::nb_frames


 -- struct: mod_gl_utils_font_data_s

 -- member of mod_gl_utils_font_data_s: menu
          TTF_Font* mod_gl_utils_font_data_s::menu


 -- member of mod_gl_utils_font_data_s: hud
          TTF_Font* mod_gl_utils_font_data_s::hud


 -- member of mod_gl_utils_font_data_s: cursor
          TTF_Font* mod_gl_utils_font_data_s::cursor


 -- member of mod_gl_utils_font_data_s: system
          TTF_Font* mod_gl_utils_font_data_s::system


 -- struct: mod_gl_utils_icon_s

 -- member of mod_gl_utils_icon_s: bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_icon_s::bitmap


 -- struct: mod_gl_utils_joysticks_info_s

 -- member of mod_gl_utils_joysticks_info_s: supported
          int mod_gl_utils_joysticks_info_s::supported


 -- member of mod_gl_utils_joysticks_info_s: driver_nb_joysticks
          int mod_gl_utils_joysticks_info_s::driver_nb_joysticks


 -- member of mod_gl_utils_joysticks_info_s: sdl_joysticks
          SDL_Joystick* mod_gl_utils_joysticks_info_s::sdl_joysticks[LW6GUI_NB_JOYSTICKS]


 -- struct: mod_gl_utils_last_action_s

 -- member of mod_gl_utils_last_action_s: game_bitmap_array_update_id
          int mod_gl_utils_last_action_s::game_bitmap_array_update_id


 -- member of mod_gl_utils_last_action_s:
game_bitmap_array_update_rounds
          int mod_gl_utils_last_action_s::game_bitmap_array_update_rounds


 -- struct: mod_gl_utils_mem_counter_s

 -- member of mod_gl_utils_mem_counter_s: new_counter
          int mod_gl_utils_mem_counter_s::new_counter


 -- member of mod_gl_utils_mem_counter_s: delete_counter
          int mod_gl_utils_mem_counter_s::delete_counter


 -- struct: mod_gl_utils_menucache_array_s

 -- member of mod_gl_utils_menucache_array_s: color_set
          lw6map_color_set_t mod_gl_utils_menucache_array_s::color_set


 -- member of mod_gl_utils_menucache_array_s: last_stored_item
          int mod_gl_utils_menucache_array_s::last_stored_item


 -- member of mod_gl_utils_menucache_array_s: item_array
          mod_gl_utils_menucache_item_t mod_gl_utils_menucache_array_s::item_array[MOD_GL_UTILS_MENUCACHE_ARRAY_SIZE]


 -- member of mod_gl_utils_menucache_array_s: tooltip_str
          char* mod_gl_utils_menucache_array_s::tooltip_str


 -- member of mod_gl_utils_menucache_array_s: tooltip_bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_menucache_array_s::tooltip_bitmap


 -- member of mod_gl_utils_menucache_array_s: help_str
          char* mod_gl_utils_menucache_array_s::help_str


 -- member of mod_gl_utils_menucache_array_s: help_bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_menucache_array_s::help_bitmap


 -- member of mod_gl_utils_menucache_array_s: breadcrumbs_str
          char* mod_gl_utils_menucache_array_s::breadcrumbs_str


 -- member of mod_gl_utils_menucache_array_s: breadcrumbs_bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_menucache_array_s::breadcrumbs_bitmap


 -- member of mod_gl_utils_menucache_array_s: popup_str
          char* mod_gl_utils_menucache_array_s::popup_str


 -- member of mod_gl_utils_menucache_array_s: popup_bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_menucache_array_s::popup_bitmap


 -- struct: mod_gl_utils_menucache_item_s

 -- member of mod_gl_utils_menucache_item_s: key
          char* mod_gl_utils_menucache_item_s::key


 -- member of mod_gl_utils_menucache_item_s: bitmap
          mod_gl_utils_bitmap_t* mod_gl_utils_menucache_item_s::bitmap


 -- struct: mod_gl_utils_mouse_state_s

 -- member of mod_gl_utils_mouse_state_s: shown
          int mod_gl_utils_mouse_state_s::shown


 -- struct: mod_gl_utils_multiline_text_callback_data_s

 -- member of mod_gl_utils_multiline_text_callback_data_s: utils_context
          mod_gl_utils_context_t* mod_gl_utils_multiline_text_callback_data_s::utils_context


 -- member of mod_gl_utils_multiline_text_callback_data_s: font
          TTF_Font* mod_gl_utils_multiline_text_callback_data_s::font


 -- member of mod_gl_utils_multiline_text_callback_data_s: sdl_color_bg
          SDL_Color mod_gl_utils_multiline_text_callback_data_s::sdl_color_bg


 -- member of mod_gl_utils_multiline_text_callback_data_s: sdl_color_fg
          SDL_Color mod_gl_utils_multiline_text_callback_data_s::sdl_color_fg


 -- member of mod_gl_utils_multiline_text_callback_data_s: shape
          lw6sys_whd_t mod_gl_utils_multiline_text_callback_data_s::shape


 -- member of mod_gl_utils_multiline_text_callback_data_s: pos
          lw6sys_xyz_t mod_gl_utils_multiline_text_callback_data_s::pos


 -- member of mod_gl_utils_multiline_text_callback_data_s: target
          SDL_Surface* mod_gl_utils_multiline_text_callback_data_s::target


 -- struct: mod_gl_utils_path_s

 -- member of mod_gl_utils_path_s: data_dir
          char* mod_gl_utils_path_s::data_dir


 -- member of mod_gl_utils_path_s: capture_dir
          char* mod_gl_utils_path_s::capture_dir


 -- member of mod_gl_utils_path_s: bitmap_dir
          char* mod_gl_utils_path_s::bitmap_dir


 -- member of mod_gl_utils_path_s: bitmap_frame_dir
          char* mod_gl_utils_path_s::bitmap_frame_dir


 -- struct: mod_gl_utils_rect_array_s

 -- member of mod_gl_utils_rect_array_s: tile_size
          int mod_gl_utils_rect_array_s::tile_size


 -- member of mod_gl_utils_rect_array_s: border_size
          int mod_gl_utils_rect_array_s::border_size


 -- member of mod_gl_utils_rect_array_s: tile_spacing
          int mod_gl_utils_rect_array_s::tile_spacing


 -- member of mod_gl_utils_rect_array_s: nb_tiles_w
          int mod_gl_utils_rect_array_s::nb_tiles_w


 -- member of mod_gl_utils_rect_array_s: nb_tiles_h
          int mod_gl_utils_rect_array_s::nb_tiles_h


 -- member of mod_gl_utils_rect_array_s: nb_tiles
          int mod_gl_utils_rect_array_s::nb_tiles


 -- member of mod_gl_utils_rect_array_s: source_w
          int mod_gl_utils_rect_array_s::source_w


 -- member of mod_gl_utils_rect_array_s: source_h
          int mod_gl_utils_rect_array_s::source_h


 -- struct: mod_gl_utils_render_param_s

 -- member of mod_gl_utils_render_param_s: mode
          mod_gl_utils_render_mode_t mod_gl_utils_render_param_s::mode


 -- member of mod_gl_utils_render_param_s: gfx_quality
          int mod_gl_utils_render_param_s::gfx_quality


 -- struct: mod_gl_utils_shaded_text_s

 -- member of mod_gl_utils_shaded_text_s: font
          TTF_Font* mod_gl_utils_shaded_text_s::font


 -- member of mod_gl_utils_shaded_text_s: text
          char* mod_gl_utils_shaded_text_s::text


 -- member of mod_gl_utils_shaded_text_s: color
          lw6map_color_couple_t mod_gl_utils_shaded_text_s::color


 -- member of mod_gl_utils_shaded_text_s: bg
          mod_gl_utils_bitmap_t* mod_gl_utils_shaded_text_s::bg


 -- member of mod_gl_utils_shaded_text_s: fg
          mod_gl_utils_bitmap_t* mod_gl_utils_shaded_text_s::fg


 -- member of mod_gl_utils_shaded_text_s: texture_w
          int mod_gl_utils_shaded_text_s::texture_w


 -- member of mod_gl_utils_shaded_text_s: texture_h
          int mod_gl_utils_shaded_text_s::texture_h


 -- struct: mod_gl_utils_team_color_map_s

 -- member of mod_gl_utils_team_color_map_s: team_colors_f
          lw6sys_color_f_t mod_gl_utils_team_color_map_s::team_colors_f[LW6MAP_MAX_NB_TEAMS]


 -- member of mod_gl_utils_team_color_map_s: team_colors
          Uint32 mod_gl_utils_team_color_map_s::team_colors[LW6MAP_MAX_NB_TEAMS][MOD_GL_SHADES_FOR_FIGHTERS_SCALE+1]


 -- struct: mod_gl_utils_texture_1x1_s

 -- member of mod_gl_utils_texture_1x1_s: color_base_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::color_base_fg


 -- member of mod_gl_utils_texture_1x1_s: color_base_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::color_base_bg


 -- member of mod_gl_utils_texture_1x1_s: color_alternate_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::color_alternate_fg


 -- member of mod_gl_utils_texture_1x1_s: color_alternate_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::color_alternate_bg


 -- member of mod_gl_utils_texture_1x1_s: background_color_root_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::background_color_root_fg


 -- member of mod_gl_utils_texture_1x1_s: background_color_root_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::background_color_root_bg


 -- member of mod_gl_utils_texture_1x1_s: background_color_stuff_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::background_color_stuff_fg


 -- member of mod_gl_utils_texture_1x1_s: background_color_stuff_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::background_color_stuff_bg


 -- member of mod_gl_utils_texture_1x1_s: hud_color_frame_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::hud_color_frame_fg


 -- member of mod_gl_utils_texture_1x1_s: hud_color_frame_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::hud_color_frame_bg


 -- member of mod_gl_utils_texture_1x1_s: hud_color_text_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::hud_color_text_fg


 -- member of mod_gl_utils_texture_1x1_s: hud_color_text_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::hud_color_text_bg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_default_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_default_fg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_default_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_default_bg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_selected_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_selected_fg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_selected_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_selected_bg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_disabled_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_disabled_fg


 -- member of mod_gl_utils_texture_1x1_s: menu_color_disabled_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::menu_color_disabled_bg


 -- member of mod_gl_utils_texture_1x1_s: view_color_cursor_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::view_color_cursor_fg


 -- member of mod_gl_utils_texture_1x1_s: view_color_cursor_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::view_color_cursor_bg


 -- member of mod_gl_utils_texture_1x1_s: view_color_map_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::view_color_map_fg


 -- member of mod_gl_utils_texture_1x1_s: view_color_map_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::view_color_map_bg


 -- member of mod_gl_utils_texture_1x1_s: system_color_fg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::system_color_fg


 -- member of mod_gl_utils_texture_1x1_s: system_color_bg
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::system_color_bg


 -- member of mod_gl_utils_texture_1x1_s: team_color_dead
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::team_color_dead


 -- member of mod_gl_utils_texture_1x1_s: team_colors
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::team_colors[LW6MAP_NB_TEAM_COLORS]


 -- member of mod_gl_utils_texture_1x1_s: team_colors_transparency
          mod_gl_utils_bitmap_t* mod_gl_utils_texture_1x1_s::team_colors_transparency[LW6MAP_NB_TEAM_COLORS][MOD_GL_UTILS_TRANSPARENCY_SCALE+1]


 -- struct: mod_gl_utils_texture_data_s

 -- member of mod_gl_utils_texture_data_s: to_delete
          lw6sys_list_t* mod_gl_utils_texture_data_s::to_delete


 -- struct: mod_gl_utils_timer_s

 -- member of mod_gl_utils_timer_s: timestamp
          int64_t mod_gl_utils_timer_s::timestamp


 -- member of mod_gl_utils_timer_s: uptime
          int64_t mod_gl_utils_timer_s::uptime


 -- member of mod_gl_utils_timer_s: cycle
          int32_t mod_gl_utils_timer_s::cycle


 -- member of mod_gl_utils_timer_s: bitmap_refresh
          int64_t mod_gl_utils_timer_s::bitmap_refresh


 -- struct: mod_gl_view_backend_s

 -- member of mod_gl_view_backend_s: view_context
          void* mod_gl_view_backend_s::view_context


 -- member of mod_gl_view_backend_s: backend_name
          char* mod_gl_view_backend_s::backend_name


 -- member of mod_gl_view_backend_s: init
          void*(* mod_gl_view_backend_s::init)(mod_gl_utils_context_t *utils_context)


 -- member of mod_gl_view_backend_s: quit
          void(* mod_gl_view_backend_s::quit)(mod_gl_utils_context_t *utils_context, void *view_context)


 -- member of mod_gl_view_backend_s: display_preview
          void(* mod_gl_view_backend_s::display_preview)(mod_gl_utils_context_t *utils_context, void *view_context, lw6gui_look_t *look, lw6map_level_t *level)


 -- member of mod_gl_view_backend_s: display_map
          void(* mod_gl_view_backend_s::display_map)(mod_gl_utils_context_t *utils_context, void *view_context, lw6gui_look_t *look, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors)


 -- member of mod_gl_view_backend_s: display_fighters
          void(* mod_gl_view_backend_s::display_fighters)(mod_gl_utils_context_t *utils_context, void *view_context, lw6gui_look_t *look, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors)


 -- member of mod_gl_view_backend_s: display_cursors
          void(* mod_gl_view_backend_s::display_cursors)(mod_gl_utils_context_t *utils_context, void *view_context, lw6gui_look_t *look, lw6ker_game_state_t *game_state, lw6pil_local_cursors_t *local_cursors)



File: liquidwar6.info,  Node: libglb,  Next: libgui,  Prev: mod-gl,  Up: C API

5.20 libglb
===========

5.20.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/glb/index.html'.

5.20.2 API
----------

 -- Function: char * lw6glb_base64_encode_bin (char * BUF, int SIZE)
     BUF:  the data to encode

     SIZE:  the size of data to encode

     Encodes data into base64. Memory allocation is done automatically.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin (int * SIZE, char *
          BASE64_STR)
     SIZE:  the size of the decoded data

     BASE64_STR:  the string to decode

     Decodes data from base64. Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.

     *Return value:*  newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str (char * STR)
     STR:  the string to encode

     Encodes a string into base64.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_str (char * STR)
     STR:  the string to decode

     Decodes a string from base64.

     *Return value:*  newly allocated string, NULL on error.

 -- Function: char * lw6glb_base64_encode_bin_prefix (char * BUF, int
          SIZE, char * PREFIX)
     BUF:  the data to encode

     SIZE:  the size of data to encode

     PREFIX:  a prefix string

     Encodes data into base64. Memory allocation is done automatically.
     The encoded string will be prefixed with `prefix'.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_bin_prefix (int * SIZE, char
          * BASE64_STR, char * PREFIX)
     SIZE:  the size of the decoded data

     BASE64_STR:  the string to decode

     PREFIX:  a prefix string

     Decodes data from base64. Memory allocation is done automatically.
     Note that this function only works for strings, other data might
     not be handled correctly.  The encoded is expected to start with
     prefix `prefix' and then contain base64 data.

     *Return value:*  newly allocated pointer, NULL on error.

 -- Function: char * lw6glb_base64_encode_str_prefix (char * STR, char
          * PREFIX)
     STR:  the string to encode

     PREFIX:  a prefix string

     Encodes a string into base64. The encoded string will be prefixed
     with `prefix'.

     *Return value:*  newly allocated string.

 -- Function: char * lw6glb_base64_decode_str_prefix (char * STR, char
          * PREFIX)
     STR:  the string to decode

     PREFIX:  a prefix string

     Decodes a string from base64. The encoded is expected to start
     with prefix `prefix' and then contain base64 data.

     *Return value:*  newly allocated string, NULL on error.

 -- Function: char * lw6glb_sha1_hmac_80_bin (char * KEY, int KEY_SIZE,
          char * BUF, int BUF_SIZE)
     KEY:  the key buffer `key_size'

     BUF:  the data to analyse

     BUF_SIZE:  the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:*  newly allocated string, containing 20 chars
     checksum.

 -- Function: char * lw6glb_sha1_hmac_80_str (char * KEY, char * STR)
     KEY:  a key (string)

     STR:  the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:*  newly allocated string, containing 20 chars
     checksum.

 -- Function: u_int32_t lw6glb_sha1_hmac_32_bin (char * KEY, int
          KEY_SIZE, char * BUF, int BUF_SIZE)
     KEY:  the key buffer `key_size'

     BUF:  the data to analyse

     BUF_SIZE:  the size of data to analyse

     Calculates an SHA-1 sum of buffer, using key to seed calc.

     *Return value:*  a 32-bit unsigned integer

 -- Function: u_int32_t lw6glb_sha1_hmac_32_str (char * KEY, char * STR)
     KEY:  a key (string)

     STR:  the string to calculate the checksum for

     Calculates an SHA-1 sum of a string, using key to seed calc.

     *Return value:*  a 32-bit unsigned integer

 -- Function: int lw6glb_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `glb' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libgui,  Next: libhlp,  Prev: libglb,  Up: C API

5.21 libgui
===========

5.21.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/gui/index.html'.

5.21.2 API
----------

 -- Function: void lw6gui_button_register_down (lw6gui_button_t *
          BUTTON, int64_t TIMESTAMP)
     BUTTON:  the button to update

     TIMESTAMP:  the current ticks (milliseconds)

     Registers a "down" (press) event on a button.

     *Return value:*  none.

 -- Function: void lw6gui_button_register_up (lw6gui_button_t * BUTTON)
     BUTTON:  the button to update

     Registers a "up" (release) event on a button.

     *Return value:*  none.

 -- Function: int lw6gui_button_is_pressed (lw6gui_button_t * BUTTON)
     BUTTON:  the button to query

     Tells wether a button is pressed or not.

     *Return value:*  1 if pressed, 0 if not.

 -- Function: int lw6gui_button_pop_press (lw6gui_button_t * BUTTON)
     BUTTON:  the button to query

     Tells how many times the button has been pressed. Typical usage:
     the button is pressed, released, pressed, released several times.
     Then, after all this, you want to know how many times it has been
     pressed.  Querying its state with `lw6gui_button_is_pressed' won't
     tell you much but this `pop_press' function will return 1 for each
     press there's been.

     *Return value:*  1 if there's a press event in the queue, 0 if
     empty.

 -- Function: int lw6gui_button_pop_simple_click (lw6gui_button_t *
          BUTTON)
     BUTTON:  the button to query

     Tells how many times the button has been simpleclicked. This is
     different from a simple press, in fact, there's a delay, we must
     wait until the double-click delay is elapsed to make sure this is
     a simple click...  Designed for use with mouse to differentiate
     fire and alternate fire.

     *Return value:*  1 if there's a simpleclick event in the queue, 0
     if empty.

 -- Function: int lw6gui_button_pop_double_click (lw6gui_button_t *
          BUTTON)
     BUTTON:  the button to query

     Tells how many times the button has been doubleclicked. Typical
     usage: the button is doubleclicked, released, doubleclicked,
     released several times. Then, after all this, you want to know how
     many times it has been doubleclicked.

     *Return value:*  1 if there's a doubleclick event in the queue, 0
     if empty.

 -- Function: int lw6gui_button_pop_triple_click (lw6gui_button_t *
          BUTTON)
     BUTTON:  the button to query

     Tells how many times the button has been tripleclicked. Typical
     usage: the button is tripleclicked, released, tripleclicked,
     released several times. Then, after all this, you want to know how
     many times it has been tripleclicked.

     *Return value:*  1 if there's a tripleclick event in the queue, 0
     if empty.

 -- Function: void lw6gui_button_update_repeat (lw6gui_button_t *
          BUTTON, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     BUTTON:  the button to update

     REPEAT_SETTINGS:  the repeat settings

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a button, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_button_sync (lw6gui_button_t * DST,
          lw6gui_button_t * SRC)
     DST:  the target button object

     SRC:  the source button object

     Synchronizes two button objects. This is typically used to pass
     data from one thread to another. This is not a simple copy, it
     will handle data such as "when was it pressed last" it an
     intelligent manner, popping src data to put it in dst, and
     clearing src.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_coord_calc_xy (float * DST_X, float * DST_Y,
          float DST_X0, float DST_Y0, float DST_W, float DST_H, float
          SRC_X, float SRC_Y, float SRC_X0, float SRC_Y0, float SRC_W,
          float SRC_H)
     DST_X:  the x coord to return

     DST_Y:  the y coord to return

     DST_X0:  the x coord of point 0 in destination coord system

     DST_Y0:  the y coord of point 0 in destination coord system

     DST_W:  the width of the area in destination coord system

     DST_H:  the width of the area in destination coord system

     SRC_X:  the x coord in source coord system

     SRC_Y:  the y coord in source coord system

     SRC_X0:  the x coord of point 0 in source coord system

     SRC_Y0:  the y coord of point 0 in source coord system

     SRC_W:  the width of the area in source coord system

     SRC_H:  the width of the area in source coord system

     Registers a "down" (press) event on a button.

     *Return value:*  1 if OK, 0 if error (unable to calculate).

 -- Function: void lw6gui_coords_fix_xy_float (float * X, float * Y,
          int * X_FLIP, int * Y_FLIP, float W, float H, int X_POLARITY,
          int Y_POLARITY)
     X:  x coord (in/out param)

     Y:  y coord (in/out param)

     X_FLIP:  flip on x (out param, -1 or +1)

     Y_FLIP:  flip on y (out param, -1 or +1)

     W:  width

     H:  height

     X_POLARITY:  x polarity (-1, 0 or 1)

     Y_POLARITY:  y polarity (-1, 0 or 1)

     Same as `lw6map_fix_coords' except it operates on floats.  Usefull
     for cursor and other rendering operations. Additionnally, will
     keep track of inversions, that is to say if map is flip in one or
     another way. Be carefull, the flip values are -1 or 1 so that it's
     easy to multiply an offset by it, for instance, but this means
     testing if flip is not 0 will always return true, you must test if
     flip is stritly positive or negative.

     *Return value:*  none

 -- Function: int lw6gui_input_init (lw6gui_input_t * INPUT)
     INPUT:  the input struct to initialise

     Initialises an input structure, don't use twice, it won't free a
     previous init.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_input_quit (lw6gui_input_t * INPUT)
     INPUT:  the input struct to uninitialise

     Unitialises an input structure, need to call it to free event
     queue.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: lw6gui_input_t * lw6gui_input_new ()
     Creates an input structure, which can be used to handle input
     state & buffer.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_input_free (lw6gui_input_t * INPUT)
     INPUT:  the input object to free.

     Deletes an input structure.

     *Return value:*  none.

 -- Function: int lw6gui_input_reset (lw6gui_input_t * INPUT)
     INPUT:  the input struct to reset

     Resets an input structure. Must have been initialized before. It
     will empty all queues and mark everything as unpressed.

     *Return value:*  1 on success, 0 if failure.

 -- Function: void lw6gui_input_update_repeat (lw6gui_input_t * INPUT,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     INPUT:  the input to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for an input, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: void lw6gui_input_register_change (lw6gui_input_t * INPUT)
     INPUT:  the input to update

     Tells an input object that one of its descendants has been
     modified. This will affect the return value of
     `lw6gui_input_need_sync'

     *Return value:*  none.

 -- Function: int lw6gui_input_need_sync (lw6gui_input_t * INPUT)
     INPUT:  the input to test

     Tests wether an input object contains was modified and needs
     synchronisation.

     *Return value:*  1 if sync is need, 0 if not.

 -- Function: int lw6gui_input_sync (lw6gui_input_t * DST,
          lw6gui_input_t * SRC)
     DST:  the target input object

     SRC:  the source input object

     Synchronizes two input objects. This is typically used to pass
     data from one thread to another. This is not a copy, it will
     brute-force copy the static data such as mouse position, but
     anything like a queue will be treated in a "empty source and fill
     target with data" scheme. So source will be affected by this, the
     key buffer will be emptied, and so on.  And if there are key in
     the target buffer, they won't be overwritten but kept in front of
     the FIFO list.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_joystick_check_index (int I)
     I:  index to check

     Checks wether the index is correct. Does not mean the joystick
     exists, it's just to avoid out of bounds errors.

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_x (lw6gui_joystick_t *
          JOYSTICK, int X, int LIMIT, int64_t TIMESTAMP)
     JOYSTICK:  joystick to update

     X:  x-axis position, as returned by the driver

     LIMIT:  the limit, under this, buttons are considered unpressed.

     TIMESTAMP:  current ticks (timestamp in ms)

     Updates the x axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like
     information such as "pressed in that direction".

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_axis_y (lw6gui_joystick_t *
          JOYSTICK, int Y, int LIMIT, int64_t TIMESTAMP)
     JOYSTICK:  joystick to update

     LIMIT:  the limit, under this, buttons are considered unpressed.

     TIMESTAMP:  current ticks (timestamp in ms)

     Updates the y axis of a joystick, this will convert an information
     of analog type such as "joystick is here" to a pad-like
     information such as "pressed in that direction".

     *Return value:*  1 if within range, 0 if not.

 -- Function: void lw6gui_joystick_update_repeat (lw6gui_joystick_t *
          JOYSTICK, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     JOYSTICK:  the joystick to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a joystick, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_joystick_sync (lw6gui_joystick_t * DST,
          lw6gui_joystick_t * SRC)
     DST:  the target joystick object

     SRC:  the source joystick object

     Synchronizes two joystick objects. This is typically used to pass
     data from one thread to another.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_joystick_get_move_pad (lw6gui_joystick_t *
          JOYSTICK, lw6gui_move_pad_t * MOVE_PAD)
     JOYSTICK:  the joystick to query

     MOVE_PAD:  the structure which will contain the results

     Returns the state of the joystick in a uniform, non-device
     specific structure containing only the up/down/left/right
     information.

     *Return value:*  none, the value are stored in `move_pad'.

 -- Function: int lw6gui_keyboard_check_keysym (int KEYSYM)
     KEYSYM:  the keysym to check

     Tells wether the keysym is valid or not.

     *Return value:*  1 if valid, 0 if not

 -- Function: lw6gui_keypress_t * lw6gui_keyboard_pop_keypress
          (lw6gui_keyboard_t * KEYBOARD)
     KEYBOARD:  the keyboard structure which stores keyboard state

     Pops (in FIFO mode) a keypress stored in the keyboard buffer. You
     must free the obtained keypress object after you're done with it.

     *Return value:*  a newly allocated pointer, or NULL if no keypress
     pending.

 -- Function: int lw6gui_keyboard_is_pressed (lw6gui_keyboard_t *
          KEYBOARD, int KEYSYM)
     KEYBOARD:  the keyboard structure which stores keyboard state

     Tells wether a key is pressed or not. The function will test out of
     bound values.

     *Return value:*  1 if pressed, 0 if not.

 -- Function: int lw6gui_keyboard_register_key_down (lw6gui_keyboard_t
          * KEYBOARD, int KEYSYM, int UNICODE, char * LABEL, int64_t
          TIMESTAMP)
     KEYBOARD:  the keyboard structure which will store the keypress

     KEYSYM:  the keysym for the keypress

     UNICODE:  the ASCII/unicode code for the keypress

     LABEL:  the label for the keypress

     TIMESTAMP:  the current ticks (timestamp in ms)

     Registers a keypress event, that is, puts it in the event queue.
     This function does not take an `lw6gui_keypress_t' structure but
     separated args, this is because it will construct the object
     internally. You may free `label' after calling this, an internal
     copy will be done.  This function will also maintain the array of
     key states up to date.

     *Return value:*  1 if success, O if failure.

 -- Function: int lw6gui_keyboard_register_key_up (lw6gui_keyboard_t *
          KEYBOARD, int KEYSYM)
     KEYBOARD:  the keyboard structure which will store the keypress

     KEYSYM:  the keysym for the keypress

     Registers a key release event.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_keyboard_update_repeat (lw6gui_keyboard_t *
          KEYBOARD, lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t
          TIMESTAMP)
     KEYBOARD:  the keyboard to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a keyboard, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_keyboard_sync (lw6gui_keyboard_t * DST,
          lw6gui_keyboard_t * SRC)
     DST:  the target keyboard object

     SRC:  the source keyboard object

     Synchronizes two keyboard objects. This is typically used to pass
     data from one thread to another. Will pop the src queue to fill
     the dst queue.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_keyboard_get_move_pad (lw6gui_keyboard_t *
          KEYBOARD, lw6gui_move_pad_t * MOVE_PAD)
     KEYBOARD:  the keyboard to query

     MOVE_PAD:  the structure which will contain the results

     Returns the state of the keyboard in a uniform, non-device
     specific structure containing only the up/down/left/right
     information.

     *Return value:*  none, the value are stored in `move_pad'.

 -- Function: lw6gui_keypress_t * lw6gui_keypress_new (int KEYSYM, int
          UNICODE, char * LABEL)
     KEYSYM:  the keysym to use

     UNICODE:  the unicode value for this keysym

     LABEL:  the label (optional, might be NULL)

     Creates a keypress structure, the only reason for needing a
     contructor is that the label field needs be duplicated.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_keypress_free (lw6gui_keypress_t * KEYPRESS)
     KEYPRESS:  the keypress object to free.

     Deletes a keypress structure.

     *Return value:*  none.

 -- Function: char * lw6gui_keypress_repr (lw6gui_keypress_t * KEYPRESS)
     KEYPRESS:  the keypress to work on

     Returns a human-readable representation of the keypress.

     *Return value:*  a newly allocated string

 -- Function: lw6gui_menu_t * lw6gui_menu_new (char * TITLE, char *
          HELP, char * POPUP, char * ESC, int ENABLE_ESC)
     TITLE:  the string to be displayed, what the user sees. Can be
     freed after the call is done, function will make a copy internally.

     HELP:  a string introducing the menu, describing what it does,
     giving hints on how to use it.

     POPUP:  a string to be displayed in popup mode when menu is
     displayed for the first time.

     ESC:  the label to be displayed in the ESC button

     ENABLE_ESC:  wether to enable the escape button.

     Constructs a new menu object. Note that you can always call other
     functions to modify it afterwards.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_menu_free (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Frees the menu, checking if things are OK before doing so.

     *Return value:*  none.

 -- Function: int lw6gui_menu_memory_footprint (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Gets the memory occupied by the menu. Could be usefull to help a
     garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:*  the number of bytes used.

 -- Function: char * lw6gui_menu_repr (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Constructs a readable description of the object. Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the
     object, but helps knowing what it is.

     *Return value:*  a string describing the object, must be freed.

 -- Function: void lw6gui_menu_set_title (lw6gui_menu_t * MENU, char *
          TITLE)
     MENU:  a pointer to the menu.

     TITLE:  the new title, you can free it after calling the function,
     an internal copy will be made.

     Change the title of the menu.  Use this function to change the
     title, don't try to access the struct directly. The idea is to
     have safe memory management.

     *Return value:*  none

 -- Function: void lw6gui_menu_set_help (lw6gui_menu_t * MENU, char *
          HELP)
     MENU:  a pointer to the menu.

     HELP:  the new help, you can free it after calling the function,
     an internal copy will be made.

     Change the help of the menu.  Use this function to change the
     help, don't try to access the struct directly. The idea is to have
     safe memory management.

     *Return value:*  none

 -- Function: void lw6gui_menu_set_popup (lw6gui_menu_t * MENU, char *
          POPUP)
     MENU:  a pointer to the menu.

     POPUP:  the new popup, you can free it after calling the function,
     an internal copy will be made.

     Change the popup of the menu. That is to say, its popup.  Use this
     function to change the popup, don't try to access the struct
     directly. The idea is to have safe memory management.

     *Return value:*  none

 -- Function: void lw6gui_menu_close_popup (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Closes the popup, in practice, this is equivalent to setting the
     popup string to "" or NULL.

     *Return value:*  none

 -- Function: int lw6gui_menu_has_popup (lw6gui_menu_t * MENU)
     MENU:  a pointer to the menu.

     Tells wether a popup is defined. Behavior is simplistic, at
     creation (when a non-NULL non-empty popup string has been set)
     then the popup is displayed. In this state, popup is considered to
     be defined. Then it can be close, and after this action the popup
     ain't here anymore, program continues the way it started.

     *Return value:*  1 if has popup, 0 if does not

 -- Function: lw6gui_menuitem_t * lw6gui_menu_get_item (lw6gui_menu_t *
          MENU, int POSITION)
     MENU:  the menu we want to query

     POSITION:  the order of the item we want

     Gets the menu item at the given position. First item is 0, last is
     N-1.  Returns a pointer on the real object, not a copy.

     *Return value:*  a pointer to a menu item, NULL if out of range.

 -- Function: int lw6gui_menu_select (lw6gui_menu_t * MENU, int
          POSITION, int ALLOW_SCROLL, int64_t NOW)
     MENU:  the menu we want to modify

     POSITION:  the position of the item we want to select

     ALLOW_SCROLL:  wether scrolling should be allowed when displaying
     it

     NOW:  the current time, as a timestamp.

     Selects the item at the given position. Use this function to be
     sure that only one item is selected, and all other states are
     consistent.  Timestamp is needed for the sake of eye-candy.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_select_esc (lw6gui_menu_t * MENU, int
          STATE, int64_t NOW)
     MENU:  the menu we want to modify

     STATE:  1 to select, 0 to unselect

     NOW:  the current time, as a timestamp.

     Selects the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:*  none.

 -- Function: void lw6gui_menu_enable_esc (lw6gui_menu_t * MENU, int
          STATE, int64_t NOW)
     MENU:  the menu we want to modify

     STATE:  1 to enable, 0 to disable

     NOW:  the current time, as a timestamp.

     Enables the escape item, this does not affect other items, it's
     mostly.  to handle eye candy.

     *Return value:*  none.

 -- Function: int lw6gui_menu_scroll_up (lw6gui_menu_t * MENU)
     MENU:  the menu to scroll

     Scrolls a menu up, used as a callback for mouse wheel up for
     instance.  The idea is just to decrement the first displayed item
     index.

     *Return value:*  1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_scroll_down (lw6gui_menu_t * MENU)
     MENU:  the menu to scroll

     Scrolls a menu down, used as a callback for mouse wheel down for
     instance.  The idea is just to increment the first displayed item
     index.

     *Return value:*  1 if OK, 0 if failed (out of range).

 -- Function: int lw6gui_menu_set_breadcrumbs (lw6gui_menu_t * MENU,
          lw6sys_list_t * BREADCRUMBS)
     MENU:  the menu to scroll

     BREADCRUMBS:  list of strings containing breadcrumbs

     Set the breadcrumbs, that's to say the readable, logical path to
     get to a given menu. This is just eye candy, not linked to any
     logic at this level.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6gui_menu_center (lw6gui_menu_t * MENU, int
          POSITION, int MAX_DISPLAYED_ITEMS)
     MENU:  the menu to center

     POSITION:  the position of the menuitem to be put in the center

     MAX_DISPLAYED_ITEMS:  the maximum number of items displayed

     Centers the menu on a given menuitem. Typically used when pushing
     a menu with a menuitem selected 'anywhere' in the list.

     *Return value:*  none.

 -- Function: int lw6gui_menu_insert (lw6gui_menu_t * MENU,
          lw6gui_menuitem_t * MENUITEM, int POSITION, int64_t NOW)
     MENU:  the menu we want to modify

     MENUITEM:  the item to insert

     POSITION:  the position the new item will occupy ("insert before"
     mode)

     NOW:  the current time, as a timestamp.

     Inserts the given item in the menu. All items starting at the
     insert position will be "pushed" (that is, their position
     incremented by 1).  Once the menuitem is inserted, the menu object
     will take care of memory management and automatically free it when
     needed.

     *Return value:*  1 if success, 0 if failure (memory problem, out
     of range).

 -- Function: int lw6gui_menu_append (lw6gui_menu_t * MENU,
          lw6gui_menuitem_t * MENUITEM, int64_t NOW)
     MENU:  the menu we want to modify

     MENUITEM:  the item to insert

     NOW:  the current time, as a timestamp.

     Appends the given item to the menu.  Once the menuitem is
     appended, the menu object will take care of memory management and
     automatically free it when needed.

     *Return value:*  1 if success, 0 if failure (memory problem).

 -- Function: int lw6gui_menu_remove (lw6gui_menu_t * MENU, int
          POSITION, int64_t NOW)
     MENU:  the menu we want to modify

     POSITION:  the item to insert

     NOW:  the current time, as a timestamp.

     Removes an item from the menu. It will automatically be freed.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_update_display_range (lw6gui_menu_t *
          MENU, int MAX_DISPLAYED_ITEMS)
     MENU:  the menu concerned

     MAX_DISPLAYED_ITEMS:  the maximum number of items to display at
     once

     Updates the display range. The reason for having this is that the
     first item, that is, how far we scroll in a very long menu, depends
     on the previous position. Plus you have to handle limit cases
     (begin/end).  Thus, this function, which will automatically
     pick-up a suitable position. Of course, `first_item_displayed' is
     not necessarly equal to `selected_item'.

     *Return value:*  none.

 -- Function: int lw6gui_menu_insert_for_id_use (lw6gui_menu_t * MENU,
          char * LABEL, char * TOOLTIP, int VALUE, int ENABLED, int
          SELECTED, int COLORED, int POSITION, int64_t NOW)
     MENU:  the menu to work on

     LABEL:  the label of the menuitem to append

     TOOLTIP:  the tooltip of the menuitem to append

     VALUE:  the value of the menuitem to append

     ENABLED:  wether the inserted menuitem should be enabled

     SELECTED:  wether the inserted menuitem should be selected

     COLORED:  wether the inserted menuitem should use value as its
     color

     NOW:  current time (timestamp)

     Inserts a menu item at the given position. The idea is that the
     menu item object is automatically constructed on the fly, and an
     id is returned, which can be passed to '_using_id' menu-related
     functions. This is typically for using in scripts. The idea is
     that the script just keeps a copy of the id returned, and can this
     way operate directly on the menuitem without keeping a pointer, a
     smob or anything internally. From the C point of view, having a
     real C structure enables persistent data from one display to the
     other, and this is nice and conveninent. I acknowledge the
     prototype is scary.

     *Return value:*  0 if error, or else an id which will later be
     used with '_using_id' functions.

 -- Function: int lw6gui_menu_append_for_id_use (lw6gui_menu_t * MENU,
          char * LABEL, char * TOOLTIP, int VALUE, int ENABLED, int
          SELECTED, int COLORED, int64_t NOW)
     MENU:  the menu to work on

     LABEL:  the label of the menuitem to append

     TOOLTIP:  the tooltip of the menuitem to append

     VALUE:  the value of the menuitem to append

     ENABLED:  wether the appended menuitem should be enabled

     SELECTED:  wether the appended menuitem should be selected

     COLORED:  wether the appended menuitem should use value as its
     color

     NOW:  current time (timestamp)

     Appends a menuitem using the same logic as
     `lw6gui_menu_insert_for_id_use' that is to say a parameter is
     returned which can later be used to directly operate on a given
     menuitem, without having its pointer, and even if its position
     changes.

     *Return value:*  0 if error, or else an id which will later be
     used with '_using_id' functions.

 -- Function: int lw6gui_menu_remove_using_id (lw6gui_menu_t * MENU,
          int MENUITEM_ID, int64_t NOW)
     MENU:  the menu to work on

     MENUITEM_ID:  the id of the menuitem to remove

     NOW:  current time (timestamp)

     Deletes the menuitem with the given id. Very important: the id is
     not the position. Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: void lw6gui_menu_sync_using_id (lw6gui_menu_t * MENU, int
          MENUITEM_ID, char * LABEL, char * TOOLTIP, int VALUE, int
          ENABLED, int SELECTED, int COLORED, int64_t NOW)
     MENU:  the menu to work on

     MENUITEM_ID:  the id of the menuitem to synchronize

     LABEL:  menu label

     TOOLTIP:  menu tooltip

     VALUE:  value

     ENABLED:  wether it's usable or not

     SELECTED:  1 if the menuite is current item

     COLORED:  wether to use color

     NOW:  current time (timestamp)

     Updates the menuitem with the given id. Very important: the id is
     not the position. Id are arbitrary numbers that stick to
     menuitems, but they are not directly linked with the position.
     This function is practical to use if, for some reason, you don't
     have the pointer on the menuitem.  In practice, it's heavily used
     in the game to transmit informations from the scripts to the core
     C engine. Additionnaly, this function will automatically
     synchronize the `selected_item' field of the menu struct.

     *Return value:*  1 if success, 0 if failure (out of range).

 -- Function: int lw6gui_menu_is_same (const lw6gui_menu_t * MENU_A,
          const lw6gui_menu_t * MENU_B)
     MENU_A:  first item to compare

     MENU_B:  second item to compare

     Compares two menus.

     *Return value:*  1 if they are the same, 0 if not

 -- Function: lw6gui_menu_t * lw6gui_menu_dup (lw6gui_menu_t * MENU)
     MENU:  the menu to duplicate

     Duplicates a menu structure.

     *Return value:*  a pointer to the new menu.

 -- Function: int lw6gui_menu_sync (lw6gui_menu_t * DST, lw6gui_menu_t
          * SRC)
     DST:  the target menu

     SRC:  the source menu

     Synchronizes two menus, this supposes that they represent the same
     menu, but simply in a different state. This function does not
     really copy src to dst, it has a special behavior, indeed
     everything is copied from src to dst, except the
     `first_item_displayed' and `nb_items_displayed' which are taken
     from dst and copied to src. This is because in practise, those
     values are updated in the display loop/thread, which is the one
     which uses the target. This is not very orthodox, but should work.

     *Return value:*  1 if success, 0 if failure

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_new (char * LABEL,
          char * TOOLTIP, int VALUE, int ENABLED, int SELECTED, int
          COLORED)
     LABEL:  the string to be displayed, what the user sees. Can be
     freed after the call is done, function will make a copy internally.

     TOOLTIP:  the string to be displayed as a tooltip, describing the
     menu item in detail. Can be NULL if you don't want to use this
     feature.

     VALUE:  the value. No GUI function uses this, this is the "real"
     value associated to the item.

     ENABLED:  wether the menu item can be selected, used, and so on

     SELECTED:  wether the menu item is the item selected among all
     menu items.

     COLORED:  wetherr the menu item must, when drawn, be colored
     according to its value.

     Constructs a new menuitem object. Note that you can always call
     other functions to modify these values afterwards, this might
     change rendering since `lw6gui_menuitem_set_value' or
     `lw6gui_menuitem_set_label' will, for instance, modify the "when
     was that item last modified" information.

     *Return value:*  a pointer to the newly allocated object.

 -- Function: void lw6gui_menuitem_free (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Frees the menuitem, checking if things are OK before doing so.

     *Return value:*  none.

 -- Function: int lw6gui_menuitem_memory_footprint (lw6gui_menuitem_t *
          MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Gets the memory occupied by the menuitem. Could be usefull to help
     a garbage collector taking decisions or reporting erros, for
     instance.

     *Return value:*  the number of bytes used.

 -- Function: char * lw6gui_menuitem_repr (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  a pointer to the menuitem.

     Constructs a readable description of the object. Usefull for
     debugging, or to introspect things using scripts, at run-time.
     Does not necessarly describe all the informations about the
     object, but helps knowing what it is.

     *Return value:*  a string describing the object, must be freed.

 -- Function: void lw6gui_menuitem_set_label (lw6gui_menuitem_t *
          MENUITEM, char * LABEL, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     LABEL:  the new label, you can free it after calling the function,
     an internal copy will be made.

     NOW:  the current time, as a timestamp.

     Change the label of the menu item. That is to say, what the user
     sees.  Use this function to change the menuitem value, don't try
     to access the struct directly. The idea is 1) to have safe memory
     management and 2) to keep the `last_change' member up to date.  It
     can be later used for eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_set_tooltip (lw6gui_menuitem_t *
          MENUITEM, char * TOOLTIP, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     TOOLTIP:  the new tooltip, you can free it after calling the
     function, an internal copy will be made.

     NOW:  the current time, as a timestamp.

     Change the tooltip of the menu item (the explanation of what the
     item is about) Use this function to change the menuitem value,
     don't try to access the struct directly. The idea is 1) to have
     safe memory management and 2) to keep the `last_change' member up
     to date.  It can be later used for eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_set_value (lw6gui_menuitem_t *
          MENUITEM, int VALUE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     VALUE:  the new value.

     NOW:  the current time, as a timestamp.

     Changes the value of a menuitem. This is the internal value, not
     what the user sees. Use this function to change the menuitem
     value, don't try to access the struct directly. The idea is to keep
     the `last_change' member up to date.  It can be later used for
     eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_select (lw6gui_menuitem_t *
          MENUITEM, int STATE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     STATE:  1 to select, 0 to unselect

     NOW:  the current time, as a timestamp.

     Switches the menuitem to (un)selected state. Use this function,
     don't try to modify the struct members directly. The idea is to
     have the `last_select' parameter up to date.  It can be later used
     for eye-candy effects.

     *Return value:*  none

 -- Function: void lw6gui_menuitem_enable (lw6gui_menuitem_t *
          MENUITEM, int STATE, int64_t NOW)
     MENUITEM:  a pointer to the menuitem.

     STATE:  1 to enable, 0 to disable

     NOW:  the current time, as a timestamp.

     Switches the menuitem to enabled/disabled state. Use this
     function, don't try to modify the struct members directly. The
     idea is to have the `last_select' parameter up to date.  It can be
     later used for eye-candy effects.

     *Return value:*  none

 -- Function: u_int32_t lw6gui_menuitem_checksum (lw6gui_menuitem_t *
          MENUITEM, lw6gui_look_t * LOOK)
     MENUITEM:  the menuitem we want to identify

     Returns a checksum which can be used to know, for instance, wether
     the menuitem has changed or not, and if we should redraw it.

     *Return value:*  a checksum.

 -- Function: int lw6gui_menuitem_is_same (const lw6gui_menuitem_t *
          MENUITEM_A, const lw6gui_menuitem_t * MENUITEM_B)
     MENUITEM_A:  first item to compare

     MENUITEM_B:  second item to compare

     Compares two menuitems.

     *Return value:*  1 if they are the same, 0 if not

 -- Function: lw6gui_menuitem_t * lw6gui_menuitem_dup
          (lw6gui_menuitem_t * MENUITEM)
     MENUITEM:  the menuitem to duplicate

     The menuitem to duplicate.

     *Return value:*  a pointer to the duplicted menuitem.

 -- Function: int lw6gui_menuitem_sync (lw6gui_menuitem_t * DST,
          lw6gui_menuitem_t * SRC)
     DST:  the target menuitem

     SRC:  the source menuitem

     Synchronizes two menuitems, this supposes that they represent the
     same item, but simply in a different state.

     *Return value:*  1 if success, 0 if failure

 -- Function: void lw6gui_mouse_register_move (lw6gui_mouse_t * MOUSE,
          int SCREEN_POS_X, int SCREEN_POS_Y, int64_t TIMESTAMP)
     MOUSE:  the mouse object to work on

     SCREEN_POS_X:  the x position on screen

     SCREEN_POS_Y:  the y position on screen

     TIMESTAMP:  current timestamp

     Registers a mouse move event.

     *Return value:*  note.

 -- Function: int lw6gui_mouse_poll_move (lw6gui_mouse_t * MOUSE, int *
          SCREEN_POS_X, int * SCREEN_POS_Y)
     MOUSE:  the mouse object to poll

     SCREEN_POS_X:  pointer to the x position (can be NULL), will be
     updated even if no move

     SCREEN_POS_Y:  pointer to the y position (can be NULL), will be
     updated even if no move

     Asks wether the mouse has moved or not.

     *Return value:*  1 if mouse was moved since last call, 0 if not.

 -- Function: void lw6gui_mouse_update_repeat (lw6gui_mouse_t * MOUSE,
          lw6gui_repeat_settings_t * REPEAT_SETTINGS, int64_t TIMESTAMP)
     MOUSE:  the mouse to update

     REPEAT_SETTINGS:  the repeat settings (delay + interval)

     TIMESTAMP:  the current ticks (milliseconds)

     Updates the repeat informations for a mouse, must be called
     regularly, as often as possible.

     *Return value:*  none.

 -- Function: int lw6gui_mouse_sync (lw6gui_mouse_t * DST,
          lw6gui_mouse_t * SRC)
     DST:  the target mouse object

     SRC:  the source mouse object

     Synchronizes two mouse objects. This is typically used to pass
     data from one thread to another. Will handle "mouse move"
     attribute and clear it in src if needed while setting it in dst.

     *Return value:*  1 if success, O if failure.

 -- Function: void lw6gui_mouse_drag_begin (lw6gui_mouse_t * MOUSE)
     MOUSE:  mouse struct to update

     To be called when one wants to start recording a drag session,
     typically when left button is pressed.

     *Return value:*  none.

 -- Function: void lw6gui_mouse_drag_end (lw6gui_mouse_t * MOUSE)
     MOUSE:  mouse struct to update

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:*  none.

 -- Function: int lw6gui_mouse_drag_pop (lw6gui_mouse_t * MOUSE, int *
          DELTA_X, int * DELTA_Y, int * POS_X, int * POS_Y, int *
          SPEED_X, int * SPEED_Y)
     MOUSE:  mouse struct to query

     DELTA_X:  x movement (on screen, out param can be NULL)

     DELTA_Y:  y movement (on screen, out param can be NULL)

     POS_X:  x pos (on screen, out param can be NULL)

     POS_Y:  y pos (on screen, out param can be NULL)

     SPEED_X:  x speed (on screen, out param can be NULL)

     SPEED_Y:  y speed (on screen, out param can be NULL)

     To be called when one wants to stop recording a drag session,
     typically when left button is released.

     *Return value:*  none.

 -- Function: int lw6gui_point_is_inside_rect (lw6gui_point_t POINT,
          lw6gui_rect_t * RECT)
     POINT:  point to test

     RECT:  rectangle in which point is supposed to be

     Tests wether a point is inside a rectangle, this is typically used
     to know if a point is inside the right texture or if we're outside.

     *Return value:*  1 if OK, 0 if outside

 -- Function: int lw6gui_quad_is_inside_rect (lw6gui_quad_t * QUAD,
          lw6gui_rect_t * RECT)
     QUAD:  quad to test

     RECT:  rectangle in which quad is supposed to be

     Tests wether a quad is inside a rectangle, this is typically used
     to know if a quad is inside the right texture or if we're outside.

     *Return value:*  1 if OK, 0 if outside

 -- Function: void lw6gui_rect_init_x1y1x2y2 (lw6gui_rect_t * RECT, int
          X1, int Y1, int X2, int Y2)
     RECT:  the structure to initialize

     X1:  x for top left corner

     Y1:  y for top left corner

     X2:  x for bottom right corner

     Y2:  y for bottom right corner

     Initializes a rect structure, will calculate w & h.

     *Return value:*  none.

 -- Function: void lw6gui_rect_init_xywh (lw6gui_rect_t * RECT, int X,
          int Y, int W, int H)
     RECT:  the structure to initialize

     X:  x for top left corner

     Y:  y for top left corner

     W:  width

     H:  height

     Initializes a rect structure, will calculate x2 & y2.

     *Return value:*  none.

 -- Function: void lw6gui_rect_clip (lw6gui_rect_t * DST, lw6gui_rect_t
          * SRC, lw6gui_rect_t * CLIP)
     DST:  the structure which will contain the result

     SRC:  the source rect

     CLIP:  the clipping rect (boundaries)

     Clips a rect (think of rectangle clips).

     *Return value:*  none.

 -- Function: int lw6gui_segment_is_inside_rect (lw6gui_segment_t *
          SEGMENT, lw6gui_rect_t * RECT)
     SEGMENT:  segment to test

     RECT:  rectangle in which segment is supposed to be

     Tests wether a segment is inside a rectangle, this is typically
     used to know if a segment is inside the right texture or if we're
     outside.

     *Return value:*  1 if OK, 0 if outside

 -- Function: void lw6gui_smoother_init (lw6gui_smoother_t * SMOOTHER,
          float VALUE, int DURATION)
     SMOOTHER:  the structure to initialize

     VALUE:  the value to use for now

     DURATION:  the duration of a standard move, in ticks (msec)

     Initializes a smoother object, with a default value. The important
     point is the duration which will condition all the behavior of the
     object.

     *Return value:*  none.

 -- Function: void lw6gui_smoother_immediate_force (lw6gui_smoother_t *
          SMOOTHER, float VALUE)
     SMOOTHER:  the structure to use

     VALUE:  the target value

     Forces a smoother object to immediately point on a value.

     *Return value:*  none.

 -- Function: void lw6gui_smoother_set_target (lw6gui_smoother_t *
          SMOOTHER, float VALUE, int64_t NOW)
     SMOOTHER:  the structure to use

     VALUE:  the target value

     NOW:  the current timestamp

     Sets a new target, will automatically calculate current speed to
     smooth the next returned values.

     *Return value:*  none.

 -- Function: float lw6gui_smoother_get_value (lw6gui_smoother_t *
          SMOOTHER, int64_t NOW)
     SMOOTHER:  the structure to use

     NOW:  the current timestamp

     Returns the current value of the smoother.

     *Return value:*  a float.

 -- Function: void lw6gui_smoother_fix_overflow (lw6gui_smoother_t *
          SMOOTHER, int STEP)
     SMOOTHER:  object to modify

     STEP:  step size, typically twice the map size

     Companion function of `lw6pil_coords_fix_x10', this one will fix a
     smoother target to avoid crazy scrolls when cursor is on a map
     edge.

     *Return value:*  none.

 -- Function: int lw6gui_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Run tests in the gui module.

     *Return value:*  1 if successfull, 0 if failed.

 -- Function: int lw6gui_triangle_is_inside_rect (lw6gui_triangle_t *
          TRIANGLE, lw6gui_rect_t * RECT)
     TRIANGLE:  triangle to test

     RECT:  rectangle in which triangle is supposed to be

     Tests wether a triangle is inside a rectangle, this is typically
     used to know if a triangle is inside the right texture or if we're
     outside.

     *Return value:*  1 if OK, 0 if outside

 -- Function: int lw6gui_video_mode_find_closest (lw6gui_video_mode_t *
          CLOSEST, lw6gui_video_mode_t * WISHED, lw6sys_list_t *
          AVAILABLE)
     CLOSEST:  the closest video_mode found

     WISHED:  the wished video_mode

     AVAILABLE:  a list of available video_modes (list of
     lw6gui_video_mode_t *)

     Finds the closest video_mode available, this is just a small
     utility to cope with different screen shapes and avoid requesting
     640x480 when it's just not available but there's a 640x400 instead.

     *Return value:*  1 if the wished video_mode exists in available
     list and was found, else 0 if the wished video_mode doesn't exist
     and an approximative match was picked.

 -- Function: int lw6gui_video_mode_is_same (const lw6gui_video_mode_t
          * MODE_A, const lw6gui_video_mode_t * MODE_B)
     MODE_A:  first mode to compare

     MODE_B:  second mode to compare

     Compares two video modes, to know if they're the same.

     *Return value:*  1 if equal, 0 if not.

 -- Function: int lw6gui_video_mode_sync_ratio (lw6gui_video_mode_t *
          DST, lw6gui_video_mode_t * SRC)
     DST:  the target video mode

     SRC:  the source video mode

     Applies the ratio of src to dst, for instance if src is 16/9, then
     dst will be made 16/9 too, trying to keep the same surface.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6gui_viewport_init (lw6gui_viewport_t * VIEWPORT,
          int SCREEN_W, int SCREEN_H, float DRAWABLE_X1, float
          DRAWABLE_Y1, float DRAWABLE_X2, float DRAWABLE_Y2, float
          CENTER_X, float CENTER_Y, int MAP_W, int MAP_H, int
          X_POLARITY, int Y_POLARITY, int X_WRAP, int Y_WRAP, int
          KEEP_RATIO, float GLOBAL_ZOOM, float SCROLL_LIMIT, int
          USE_OLD_CENTER)
     VIEWPORT:  the viewport to initalize

     SCREEN_W:  screen width

     SCREEN_H:  screen height

     DRAWABLE_X1:  viewport min x

     DRAWABLE_Y1:  viewport min y

     DRAWABLE_X2:  viewport max x

     DRAWABLE_Y2:  viewport max y

     CENTER_X:  center of display (in map coordinates)

     CENTER_Y:  center of display (in map coordinates)

     MAP_W:  map width (shape)

     MAP_H:  map height (shape)

     X_POLARITY:  x polarity

     Y_POLARITY:  y polarity

     X_WRAP:  wether to wrap horizontally

     Y_WRAP:  wether to wrap vertically

     KEEP_RATIO:  wether to adapt to viewport shape or keep original

     GLOBAL_ZOOM:  global zoom is style_zoom * dynamic_zoom

     SCROLL_LIMIT:  inside this zone, don't scroll

     USE_OLD_CENTER:  wether to take previous center in account

     Initializes all the (jumbo?) viewport structure which will contain
     valuable informations for a simple "flat" display.  Special
     renderers might not find usefull some fields and handle wrapping
     and zooming their own way, but this offers a basic skeleton.

     *Return value:*  1 if ok, 0 on failure

 -- Function: void lw6gui_viewport_map_to_screen (lw6gui_viewport_t *
          VIEWPORT, float * SCREEN_X, float * SCREEN_Y, float MAP_X,
          float MAP_Y, int CLIP)
     VIEWPORT:  the viewport to use

     SCREEN_X:  the x coord on the screen

     SCREEN_Y:  the y coord on the screen

     MAP_X:  the x coord in map coordinates

     MAP_Y:  the y coord in map coordinates

     CLIP:  wether to clip returned values

     Translates from map coords to screen coords. Returned values might
     be outside screen boundaries if clip is 0. If screen coords are
     outside drawable area anc clip is 1, then they will be clipped.

     *Return value:*  NULL

 -- Function: void lw6gui_viewport_screen_to_map (lw6gui_viewport_t *
          VIEWPORT, float * MAP_X, float * MAP_Y, float SCREEN_X, float
          SCREEN_Y, int WRAP)
     VIEWPORT:  the viewport to use

     MAP_X:  the x coord in map coordinates

     MAP_Y:  the y coord in map coordinates

     SCREEN_X:  the x coord on the screen

     SCREEN_Y:  the y coord on the screen

     WRAP:  wether to use polarity informations to wrap coords.

     Translates from screen coords to map coords. If wrap is set, it
     will interpret coords the way `lw6map_coords_fix_xy' would, only
     it can still be formally outside map boundaries for it can return
     a value exactly equal to w,h while in interger mode it would be
     w-1,h-1.

     *Return value:*  NULL

 -- Function: void lw6gui_viewport_calc_drag (lw6gui_viewport_t *
          VIEWPORT, float * MAP_DST_X, float * MAP_DST_Y, float
          MAP_SRC_X, float MAP_SRC_Y, int SCREEN_DX, int SCREEN_DY)
     VIEWPORT:  viewport to work on

     MAP_DST_X:  map det x coord (out param)

     MAP_DST_Y:  map dst y coord (out param)

     MAP_SRC_X:  map src x coord

     MAP_SRC_Y:  map src y coord

     SCREEN_DX:  drag x (on screen)

     SCREEN_DY:  drag y (on screen)

     Used to calculate the new "center" when in drag mode.

     *Return value:*  none.

 -- Function: void lw6gui_zone_init_x1y1x2y2 (lw6gui_zone_t * ZONE,
          float X1, float Y1, float X2, float Y2)
     ZONE:  the structure to initialize

     X1:  x for top left corner

     Y1:  y for top left corner

     X2:  x for bottom right corner

     Y2:  y for bottom right corner

     Initializes a zone structure, will calculate w & h.

     *Return value:*  none.

 -- Function: void lw6gui_zone_init_xywh (lw6gui_zone_t * ZONE, float
          X, float Y, float W, float H)
     ZONE:  the structure to initialize

     X:  x for top left corner

     Y:  y for top left corner

     W:  width

     H:  height

     Initializes a zone structure, will calculate x2 & y2.

     *Return value:*  none.

 -- Function: void lw6gui_zone_clip (lw6gui_zone_t * DST, lw6gui_zone_t
          * SRC, lw6gui_zone_t * CLIP)
     DST:  the structure which will contain the result

     SRC:  the source zone

     CLIP:  the clipping zone (boundaries)

     Clips a zone (think of rectangle clips).

     *Return value:*  none.

 -- struct: lw6gui_button_s

 -- member of lw6gui_button_s: is_pressed
          int lw6gui_button_s::is_pressed


 -- member of lw6gui_button_s: press_queue
          int lw6gui_button_s::press_queue


 -- member of lw6gui_button_s: simple_click_queue
          int lw6gui_button_s::simple_click_queue


 -- member of lw6gui_button_s: double_click_queue
          int lw6gui_button_s::double_click_queue


 -- member of lw6gui_button_s: triple_click_queue
          int lw6gui_button_s::triple_click_queue


 -- member of lw6gui_button_s: last_press
          int64_t lw6gui_button_s::last_press


 -- member of lw6gui_button_s: last_repeat
          int64_t lw6gui_button_s::last_repeat


 -- member of lw6gui_button_s: double_click_t1
          int64_t lw6gui_button_s::double_click_t1


 -- member of lw6gui_button_s: double_click_t2
          int64_t lw6gui_button_s::double_click_t2


 -- member of lw6gui_button_s: double_click_t3
          int64_t lw6gui_button_s::double_click_t3


 -- struct: lw6gui_fullscreen_modes_s

 -- member of lw6gui_fullscreen_modes_s: low
          lw6gui_video_mode_t lw6gui_fullscreen_modes_s::low


 -- member of lw6gui_fullscreen_modes_s: standard
          lw6gui_video_mode_t lw6gui_fullscreen_modes_s::standard


 -- member of lw6gui_fullscreen_modes_s: high
          lw6gui_video_mode_t lw6gui_fullscreen_modes_s::high


 -- struct: lw6gui_input_s

 -- member of lw6gui_input_s: need_sync
          int lw6gui_input_s::need_sync


 -- member of lw6gui_input_s: keyboard
          lw6gui_keyboard_t lw6gui_input_s::keyboard


 -- member of lw6gui_input_s: mouse
          lw6gui_mouse_t lw6gui_input_s::mouse


 -- member of lw6gui_input_s: joysticks
          lw6gui_joystick_t lw6gui_input_s::joysticks[LW6GUI_NB_JOYSTICKS]


 -- struct: lw6gui_joystick_s

 -- member of lw6gui_joystick_s: pad_up
          lw6gui_button_t lw6gui_joystick_s::pad_up


 -- member of lw6gui_joystick_s: pad_down
          lw6gui_button_t lw6gui_joystick_s::pad_down


 -- member of lw6gui_joystick_s: pad_left
          lw6gui_button_t lw6gui_joystick_s::pad_left


 -- member of lw6gui_joystick_s: pad_right
          lw6gui_button_t lw6gui_joystick_s::pad_right


 -- member of lw6gui_joystick_s: button_a
          lw6gui_button_t lw6gui_joystick_s::button_a


 -- member of lw6gui_joystick_s: button_b
          lw6gui_button_t lw6gui_joystick_s::button_b


 -- member of lw6gui_joystick_s: button_c
          lw6gui_button_t lw6gui_joystick_s::button_c


 -- member of lw6gui_joystick_s: button_d
          lw6gui_button_t lw6gui_joystick_s::button_d


 -- member of lw6gui_joystick_s: button_e
          lw6gui_button_t lw6gui_joystick_s::button_e


 -- member of lw6gui_joystick_s: button_f
          lw6gui_button_t lw6gui_joystick_s::button_f


 -- struct: lw6gui_keyboard_s

 -- member of lw6gui_keyboard_s: arrow_up
          lw6gui_button_t lw6gui_keyboard_s::arrow_up


 -- member of lw6gui_keyboard_s: arrow_down
          lw6gui_button_t lw6gui_keyboard_s::arrow_down


 -- member of lw6gui_keyboard_s: arrow_left
          lw6gui_button_t lw6gui_keyboard_s::arrow_left


 -- member of lw6gui_keyboard_s: arrow_right
          lw6gui_button_t lw6gui_keyboard_s::arrow_right


 -- member of lw6gui_keyboard_s: key_enter
          lw6gui_button_t lw6gui_keyboard_s::key_enter


 -- member of lw6gui_keyboard_s: key_esc
          lw6gui_button_t lw6gui_keyboard_s::key_esc


 -- member of lw6gui_keyboard_s: key_ctrl
          lw6gui_button_t lw6gui_keyboard_s::key_ctrl


 -- member of lw6gui_keyboard_s: key_alt
          lw6gui_button_t lw6gui_keyboard_s::key_alt


 -- member of lw6gui_keyboard_s: key_pgup
          lw6gui_button_t lw6gui_keyboard_s::key_pgup


 -- member of lw6gui_keyboard_s: key_pgdown
          lw6gui_button_t lw6gui_keyboard_s::key_pgdown


 -- member of lw6gui_keyboard_s: queue
          lw6sys_list_t* lw6gui_keyboard_s::queue


 -- member of lw6gui_keyboard_s: keys_state
          lw6gui_button_t lw6gui_keyboard_s::keys_state[LW6GUI_NB_KEYS]


 -- struct: lw6gui_keypress_s

 -- member of lw6gui_keypress_s: keysym
          int lw6gui_keypress_s::keysym


 -- member of lw6gui_keypress_s: unicode
          int lw6gui_keypress_s::unicode


 -- member of lw6gui_keypress_s: label
          char* lw6gui_keypress_s::label


 -- struct: lw6gui_look_s

 -- member of lw6gui_look_s: id
          u_int32_t lw6gui_look_s::id


 -- member of lw6gui_look_s: dynamic_zoom
          float lw6gui_look_s::dynamic_zoom


 -- member of lw6gui_look_s: gfx_quality
          int lw6gui_look_s::gfx_quality


 -- member of lw6gui_look_s: style
          lw6map_style_t lw6gui_look_s::style


 -- struct: lw6gui_menuitem_s

 -- member of lw6gui_menuitem_s: id
          u_int32_t lw6gui_menuitem_s::id


 -- member of lw6gui_menuitem_s: label
          char* lw6gui_menuitem_s::label


 -- member of lw6gui_menuitem_s: tooltip
          char* lw6gui_menuitem_s::tooltip


 -- member of lw6gui_menuitem_s: value
          int lw6gui_menuitem_s::value


 -- member of lw6gui_menuitem_s: enabled
          int lw6gui_menuitem_s::enabled


 -- member of lw6gui_menuitem_s: selected
          int lw6gui_menuitem_s::selected


 -- member of lw6gui_menuitem_s: colored
          int lw6gui_menuitem_s::colored


 -- member of lw6gui_menuitem_s: last_change
          int lw6gui_menuitem_s::last_change


 -- member of lw6gui_menuitem_s: last_select
          int lw6gui_menuitem_s::last_select


 -- member of lw6gui_menuitem_s: last_unselect
          int lw6gui_menuitem_s::last_unselect


 -- struct: lw6gui_menu_s

 -- member of lw6gui_menu_s: id
          u_int32_t lw6gui_menu_s::id


 -- member of lw6gui_menu_s: title
          char* lw6gui_menu_s::title


 -- member of lw6gui_menu_s: help
          char* lw6gui_menu_s::help


 -- member of lw6gui_menu_s: popup
          char* lw6gui_menu_s::popup


 -- member of lw6gui_menu_s: nb_items
          int lw6gui_menu_s::nb_items


 -- member of lw6gui_menu_s: esc_item
          lw6gui_menuitem_t* lw6gui_menu_s::esc_item


 -- member of lw6gui_menu_s: items
          lw6gui_menuitem_t** lw6gui_menu_s::items


 -- member of lw6gui_menu_s: selected_item
          int lw6gui_menu_s::selected_item


 -- member of lw6gui_menu_s: first_item_displayed
          int lw6gui_menu_s::first_item_displayed


 -- member of lw6gui_menu_s: nb_items_displayed
          int lw6gui_menu_s::nb_items_displayed


 -- member of lw6gui_menu_s: order_of_selected_on_display
          int lw6gui_menu_s::order_of_selected_on_display


 -- member of lw6gui_menu_s: allow_scroll
          int lw6gui_menu_s::allow_scroll


 -- member of lw6gui_menu_s: breadcrumbs
          lw6sys_list_t* lw6gui_menu_s::breadcrumbs


 -- struct: lw6gui_mouse_pointer_s

 -- member of lw6gui_mouse_pointer_s: pos_x
          int lw6gui_mouse_pointer_s::pos_x


 -- member of lw6gui_mouse_pointer_s: pos_y
          int lw6gui_mouse_pointer_s::pos_y


 -- member of lw6gui_mouse_pointer_s: speed_x
          int lw6gui_mouse_pointer_s::speed_x


 -- member of lw6gui_mouse_pointer_s: speed_y
          int lw6gui_mouse_pointer_s::speed_y


 -- struct: lw6gui_mouse_s

 -- member of lw6gui_mouse_s: moved
          int lw6gui_mouse_s::moved


 -- member of lw6gui_mouse_s: last_moved
          int64_t lw6gui_mouse_s::last_moved


 -- member of lw6gui_mouse_s: screen_pointer
          lw6gui_mouse_pointer_t lw6gui_mouse_s::screen_pointer


 -- member of lw6gui_mouse_s: map_pointer
          lw6gui_mouse_pointer_t lw6gui_mouse_s::map_pointer


 -- member of lw6gui_mouse_s: screen_drag_start
          lw6gui_mouse_pointer_t lw6gui_mouse_s::screen_drag_start


 -- member of lw6gui_mouse_s: drag_mode
          lw6gui_drag_mode_t lw6gui_mouse_s::drag_mode


 -- member of lw6gui_mouse_s: menu_position
          int lw6gui_mouse_s::menu_position


 -- member of lw6gui_mouse_s: menu_scroll
          int lw6gui_mouse_s::menu_scroll


 -- member of lw6gui_mouse_s: menu_esc
          int lw6gui_mouse_s::menu_esc


 -- member of lw6gui_mouse_s: button_left
          lw6gui_button_t lw6gui_mouse_s::button_left


 -- member of lw6gui_mouse_s: button_right
          lw6gui_button_t lw6gui_mouse_s::button_right


 -- member of lw6gui_mouse_s: button_middle
          lw6gui_button_t lw6gui_mouse_s::button_middle


 -- member of lw6gui_mouse_s: wheel_up
          lw6gui_button_t lw6gui_mouse_s::wheel_up


 -- member of lw6gui_mouse_s: wheel_down
          lw6gui_button_t lw6gui_mouse_s::wheel_down


 -- struct: lw6gui_move_pad_s

 -- member of lw6gui_move_pad_s: up
          int lw6gui_move_pad_s::up


 -- member of lw6gui_move_pad_s: down
          int lw6gui_move_pad_s::down


 -- member of lw6gui_move_pad_s: left
          int lw6gui_move_pad_s::left


 -- member of lw6gui_move_pad_s: right
          int lw6gui_move_pad_s::right


 -- struct: lw6gui_point_s

 -- member of lw6gui_point_s: x
          float lw6gui_point_s::x


 -- member of lw6gui_point_s: y
          float lw6gui_point_s::y


 -- member of lw6gui_point_s: z
          float lw6gui_point_s::z


 -- struct: lw6gui_quad_s

 -- member of lw6gui_quad_s: p1
          lw6gui_point_t lw6gui_quad_s::p1


 -- member of lw6gui_quad_s: p2
          lw6gui_point_t lw6gui_quad_s::p2


 -- member of lw6gui_quad_s: p3
          lw6gui_point_t lw6gui_quad_s::p3


 -- member of lw6gui_quad_s: p4
          lw6gui_point_t lw6gui_quad_s::p4


 -- struct: lw6gui_rect_array_s

 -- member of lw6gui_rect_array_s: source
          lw6sys_whd_t lw6gui_rect_array_s::source


 -- member of lw6gui_rect_array_s: limits
          lw6gui_rect_t lw6gui_rect_array_s::limits


 -- member of lw6gui_rect_array_s: tile_size
          int lw6gui_rect_array_s::tile_size


 -- member of lw6gui_rect_array_s: border_size
          int lw6gui_rect_array_s::border_size


 -- member of lw6gui_rect_array_s: tile_spacing
          int lw6gui_rect_array_s::tile_spacing


 -- member of lw6gui_rect_array_s: nb_tiles_w
          int lw6gui_rect_array_s::nb_tiles_w


 -- member of lw6gui_rect_array_s: nb_tiles_h
          int lw6gui_rect_array_s::nb_tiles_h


 -- member of lw6gui_rect_array_s: nb_tiles
          int lw6gui_rect_array_s::nb_tiles


 -- struct: lw6gui_rect_s

 -- member of lw6gui_rect_s: x1
          int lw6gui_rect_s::x1


 -- member of lw6gui_rect_s: y1
          int lw6gui_rect_s::y1


 -- member of lw6gui_rect_s: x2
          int lw6gui_rect_s::x2


 -- member of lw6gui_rect_s: y2
          int lw6gui_rect_s::y2


 -- member of lw6gui_rect_s: w
          int lw6gui_rect_s::w


 -- member of lw6gui_rect_s: h
          int lw6gui_rect_s::h


 -- struct: lw6gui_repeat_settings_s

 -- member of lw6gui_repeat_settings_s: delay
          int lw6gui_repeat_settings_s::delay


 -- member of lw6gui_repeat_settings_s: interval
          int lw6gui_repeat_settings_s::interval


 -- member of lw6gui_repeat_settings_s: double_click_delay
          int lw6gui_repeat_settings_s::double_click_delay


 -- struct: lw6gui_segment_s

 -- member of lw6gui_segment_s: p1
          lw6gui_point_t lw6gui_segment_s::p1


 -- member of lw6gui_segment_s: p2
          lw6gui_point_t lw6gui_segment_s::p2


 -- struct: lw6gui_smoother_s

 -- member of lw6gui_smoother_s: s1
          float lw6gui_smoother_s::s1


 -- member of lw6gui_smoother_s: y1
          float lw6gui_smoother_s::y1


 -- member of lw6gui_smoother_s: y2
          float lw6gui_smoother_s::y2


 -- member of lw6gui_smoother_s: t1
          int64_t lw6gui_smoother_s::t1


 -- member of lw6gui_smoother_s: duration
          int lw6gui_smoother_s::duration


 -- struct: lw6gui_triangle_s

 -- member of lw6gui_triangle_s: p1
          lw6gui_point_t lw6gui_triangle_s::p1


 -- member of lw6gui_triangle_s: p2
          lw6gui_point_t lw6gui_triangle_s::p2


 -- member of lw6gui_triangle_s: p3
          lw6gui_point_t lw6gui_triangle_s::p3


 -- struct: lw6gui_video_mode_s

 -- member of lw6gui_video_mode_s: width
          int lw6gui_video_mode_s::width


 -- member of lw6gui_video_mode_s: height
          int lw6gui_video_mode_s::height


 -- member of lw6gui_video_mode_s: fullscreen
          int lw6gui_video_mode_s::fullscreen


 -- struct: lw6gui_viewport_s

 -- member of lw6gui_viewport_s: map_shape
          lw6sys_whd_t lw6gui_viewport_s::map_shape


 -- member of lw6gui_viewport_s: screen_shape
          lw6sys_whd_t lw6gui_viewport_s::screen_shape


 -- member of lw6gui_viewport_s: center_x
          float lw6gui_viewport_s::center_x


 -- member of lw6gui_viewport_s: center_y
          float lw6gui_viewport_s::center_y


 -- member of lw6gui_viewport_s: old_center_x
          float lw6gui_viewport_s::old_center_x


 -- member of lw6gui_viewport_s: old_center_y
          float lw6gui_viewport_s::old_center_y


 -- member of lw6gui_viewport_s: speed_x
          float lw6gui_viewport_s::speed_x


 -- member of lw6gui_viewport_s: speed_y
          float lw6gui_viewport_s::speed_y


 -- member of lw6gui_viewport_s: x_polarity
          int lw6gui_viewport_s::x_polarity


 -- member of lw6gui_viewport_s: y_polarity
          int lw6gui_viewport_s::y_polarity


 -- member of lw6gui_viewport_s: x_wrap
          int lw6gui_viewport_s::x_wrap


 -- member of lw6gui_viewport_s: y_wrap
          int lw6gui_viewport_s::y_wrap


 -- member of lw6gui_viewport_s: drawable
          lw6gui_zone_t lw6gui_viewport_s::drawable


 -- member of lw6gui_viewport_s: map_main
          lw6gui_zone_t lw6gui_viewport_s::map_main


 -- member of lw6gui_viewport_s: map_main_clipped
          lw6gui_zone_t lw6gui_viewport_s::map_main_clipped


 -- member of lw6gui_viewport_s: map_visible
          lw6gui_zone_t lw6gui_viewport_s::map_visible


 -- struct: lw6gui_zone_s

 -- member of lw6gui_zone_s: x1
          float lw6gui_zone_s::x1


 -- member of lw6gui_zone_s: y1
          float lw6gui_zone_s::y1


 -- member of lw6gui_zone_s: x2
          float lw6gui_zone_s::x2


 -- member of lw6gui_zone_s: y2
          float lw6gui_zone_s::y2


 -- member of lw6gui_zone_s: w
          float lw6gui_zone_s::w


 -- member of lw6gui_zone_s: h
          float lw6gui_zone_s::h



File: liquidwar6.info,  Node: libhlp,  Next: libimg,  Prev: libgui,  Up: C API

5.22 libhlp
===========

5.22.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/hlp/index.html'.

5.22.2 API
----------

 -- Function: int lw6hlp_is_documented (const char * KEYWORD)
     KEYWORD:  the keyword we want to check out

     Checks wether a given keyword is documented or not.

     *Return value:*  1 if documented, 0 if not.

 -- Function: const char * lw6hlp_about (lw6hlp_type_t * TYPE, const
          char ** DEFAULT_VALUE, int * MIN_VALUE, int * MAX_VALUE,
          const char * KEYWORD)
     TYPE:  the type of the data associated to the keyword, will be
     written

     DEFAULT_VALUE:  the default value for the keyword, will be written

     MIN_VALUE:  the min value for the keyword, will be written

     MAX_VALUE:  the max value for the keyword, will be written

     KEYWORD:  the keyword we want help about

     Returns the documentation string associated to a keyword. The
     keyword might be a command-line option, a Guile function, an XML
     file entry.  Raises a warning if the keyword is undocumented, but
     never returns NULL, you can use the returned value without
     checking it. String is localized if a translation is available.
     It's safe to call this function with type or other parameters
     being NULL.

     *Return value:*  a help string, never NULL, must not be freed.
     Additionnally, type will be updated.

 -- Function: lw6hlp_type_t lw6hlp_get_type (const char * KEYWORD)
     KEYWORD:  the keyword we want the type of

     Returns the type of a keyword. Calls lw6hlp_about internally.

     *Return value:*  the type, might be LW6HLP_TYPE_VOID.

 -- Function: const char * lw6hlp_get_default_value (const char *
          KEYWORD)
     KEYWORD:  the keyword we want the default for

     Returns the default value for a keyword. Note that it can be NULL!
     The returned value is always a string, it's suitable to store in
     the config file, it's the value a user would pass on a command
     line, the one he wants documented.

     *Return value:*  a pointer, which can be NULL, must not be freed.

 -- Function: int lw6hlp_get_min_value (const char * KEYWORD)
     KEYWORD:  the keyword we want the min for

     Returns the min value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: int lw6hlp_get_max_value (const char * KEYWORD)
     KEYWORD:  the keyword we want the max for

     Returns the max value for a keyword. Wether this is relevant for a
     given keyword does not affect the fact that you can call this
     function.  A min and max of zero means min and max make no sense.

     *Return value:*  the value (integer)

 -- Function: char * lw6hlp_get_credits (int ID)
     ID:  the id of the credits line to return

     Returns a "credit line", that is a short sentence, about 30 to 50
     chars, saying who developped the game, created graphics, giving
     important URLs, and so on. One can pass an arbitraty high `id', no
     risk.

     *Return value:*  the string, must be freed.

 -- Function: int lw6hlp_match (const char * KEYWORD1, const char *
          KEYWORD2)
     KEYWORD1:  the 1st keyword

     KEYWORD2:  the 2nd keyword

     Checks wether a keyword matches another. Not only a string
     comparison, will also try and guess if the error is only about
     dash "-" replaced by underscode "_", for instance.

     *Return value:*  1 if matches, 0 if different.

 -- Function: lw6sys_list_t * lw6hlp_list_quick ()
     Returns the list of keywords concerning quick options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_doc ()
     Returns the list of keywords concerning self-documentation system.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_show ()
     Returns the list of keywords concerning the show options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_path ()
     Returns the list of keywords concerning the path options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_players ()
     Returns the list of keywords concerning the players options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_input ()
     Returns the list of keywords concerning the input options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_graphics ()
     Returns the list of keywords concerning the graphics options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_sound ()
     Returns the list of keywords concerning the sound options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_network ()
     Returns the list of keywords concerning the network options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map ()
     Returns the list of keywords concerning the map options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_rules ()
     Returns the list of keywords concerning the rules options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_hints ()
     Returns the list of keywords concerning the hints options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_style ()
     Returns the list of keywords concerning the style options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_map_teams ()
     Returns the list of keywords concerning the teams options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_funcs ()
     Returns the list of C-function exported to Guile.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_hooks ()
     Returns the list of hooks.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_advanced ()
     Returns the list of keywords concerning advanced options.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_aliases ()
     Returns the list of command-line aliases.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_team_colors ()
     Returns the list of team_colors.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list_weapons ()
     Returns the list of weapons.

     *Return value:*  list of static strings (can't modify them)

 -- Function: lw6sys_list_t * lw6hlp_list ()
     Returns the list of all available keywords.

     *Return value:*  list of static strings (can't modify them)

 -- Function: void lw6hlp_print_keyword (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list. One keyword per line.

     *Return value:*  none.

 -- Function: void lw6hlp_print_content (lw6sys_list_t ** LIST, FILE *
          F)
     LIST:  a pointer to a list of keywords

     F:  the file to print the content to

     Prints all the keywords from the list, with the associated keyword
     help, to the given file. Output is formatted to fit on the
     standard terminal/console.

     *Return value:*  none.

 -- Function: void lw6hlp_print_about (const char * KEYWORD, FILE * F)
     KEYWORD:  the keyword to print help about

     F:  the file to print the content to

     Displays the help about a keyword, to a file, directly.  It's
     formatted for the purpose of the -about=<value> option.

     *Return value:*  none

 -- Function: int lw6hlp_reference_init ()
     Initializes the help reference, this must be called before any
     call to lw6hlp_about or such help related functions.

     *Return value:*  1 on success, 0 if failed

 -- Function: void lw6hlp_reference_quit ()
     un-initializes the help reference, this must be called at the end
     of the program.

     *Return value:*  1 on success, 0 if failed

 -- Function: int lw6hlp_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `hlp' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.


File: liquidwar6.info,  Node: libimg,  Next: libker,  Prev: libhlp,  Up: C API

5.23 libimg
===========

5.23.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/img/index.html'.

5.23.2 API
----------

 -- Function: char * lw6img_repr (lw6img_jpeg_t * JPEG)
     JPEG:  the jpeg to describe

     Returns a string describing the jepg. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: lw6img_jpeg_t * lw6img_screenshot_new
          (lw6ker_game_state_t * GAME_STATE, char * USER_DIR, int
          QUALITY)
     GAME_STATE:  game_state to create a screenshot from

     USER_DIR:  user directory

     QUALITY:  quality, from 0 to 100

     Creates a JPEG screenshot from a game state. The `user_dir'
     parameter is used to build a file name and then use it to write
     data on disk, it is then read and kept in memory.  Globally it's
     not that bad to store it for we do not generate screenshots that
     often, and it's nice for debugging to have it so developping a
     RAM-only writer wouldn't make it a blast anyway.

     *Return value:*  dynamically allocated object.

 -- Function: void lw6img_screenshot_free (lw6img_jpeg_t * SCREENSHOT)
     Frees a JPEG screenshot.

     *Return value:*  none.

 -- Function: int lw6img_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `img' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6img_jpeg_s

 -- member of lw6img_jpeg_s: id
          u_int32_t lw6img_jpeg_s::id


 -- member of lw6img_jpeg_s: shape
          lw6sys_whd_t lw6img_jpeg_s::shape


 -- member of lw6img_jpeg_s: jpeg_size
          int lw6img_jpeg_s::jpeg_size


 -- member of lw6img_jpeg_s: jpeg_data
          void* lw6img_jpeg_s::jpeg_data



File: liquidwar6.info,  Node: libker,  Next: libldr,  Prev: libimg,  Up: C API

5.24 libker
===========

5.24.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ker/index.html'.

5.24.2 API
----------

 -- Function: char * lw6ker_capture_str (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  game state to represent

     Gives a string representation, an ASCII capture of the game.  This
     representation is suitable for debugging, typically print it to a
     VT100 console.

     *Return value:*  dynamically allocated string.

 -- Function: void lw6ker_cursor_reset (lw6ker_cursor_t * CURSOR)
     CURSOR:  the cursor to reset

     Sets a cursor to defaults (disabled). This function will not touch
     the node_id and cursor_id fields, so you can call it on an already
     used cursor, it will stay usable.

     *Return value:*  none

 -- Function: lw6ker_game_state_t * lw6ker_game_state_new
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  game_struct use to construct the object

     PROGRESS:  progress indicator

     Creates a game state from a game struct. The game struct must be
     kept (never freed) while game_state is in use.

     *Return value:*  newly created object.

 -- Function: void lw6ker_game_state_free (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the object to free

     Frees a game_state object, releases all required objects. At this
     stage the map_struct must still be available.

     *Return value:*  none

 -- Function: void lw6ker_game_state_point_to (lw6ker_game_state_t *
          GAME_STATE, lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STATE:  the game_state to modify

     GAME_STRUCT:  the game_struct to point to

     This can be used when one makes a copy (dup) of a game struct and
     for some reason want the game_state to point on this new copy. Of
     course you should make the game_state point to a game_struct that
     is identical to the one that was used to construct the object in
     the first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_state_memory_footprint
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_state_repr (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: int lw6ker_game_state_can_sync (lw6ker_game_state_t *
          DST, lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Tells wether src and dst can be synced. This is not a fool proof
     function but in most cases it will raise the error, use it to
     avoid blunders. It just compares `dst' and `src' and tries to
     guess if they correspond to the same logical objects.

     *Return value:*  1 if they are syncable, 0 if not.

 -- Function: int lw6ker_game_state_sync (lw6ker_game_state_t * DST,
          lw6ker_game_state_t * SRC)
     DST:  the destination game_state

     SRC:  the source game_state

     Fundamental function, used to carbon copy a game state to another,
     this is intensively used to keep too tracks of the game state, one
     most-up-to-date but probably wrong, the one we use to display on
     the screen, and one slightly outdated (or very outdated if network
     is slow) but that we're sure of, something 100% bullet proof we can
     rely on.

     *Return value:*  1 on success, 0 on error

 -- Function: lw6ker_game_state_t * lw6ker_game_state_dup
          (lw6ker_game_state_t * GAME_STATE, lw6sys_progress_t *
          PROGRESS)
     GAME_STATE:  the game_state to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_state object. The newly created object points to
     the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_state objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_state_checksum (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to query

     Calculates the checksum of a game_state, this can be very usefull
     to make sure two states are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_state_get_shape (lw6ker_game_state_t *
          GAME_STATE, lw6sys_whd_t * SHAPE)
     GAME_STATE:  the game_state to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_state.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_get_w (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the width (shape.w) of the game_state.

     *Return value:*  the width.

 -- Function: int lw6ker_game_state_get_h (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the height (shape.h) of the game_state.

     *Return value:*  the height.

 -- Function: int lw6ker_game_state_get_d (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_state.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_state_register_node (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Registers a node in the game, this must be done, else no action
     will be allowed (such as adding a cursor or moving it). There's a
     limited number of nodes allowed, and ids must be unique.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_unregister_node
          (lw6ker_game_state_t * GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to act on

     NODE_ID:  the id of the node to register

     Unregisters a node in the game, this must be done when a node
     leaves the game, it will free ressources and allow others to
     connect.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_node_exists (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID)
     GAME_STATE:  the game_state to query

     NODE_ID:  the node to test

     Tells wether a node is present in a game.

     *Return value:*  1 if node is in game, 0 if not

 -- Function: int lw6ker_game_state_get_node_info (lw6ker_game_state_t
          * GAME_STATE, u_int16_t NODE_ID, u_int32_t *
          LAST_COMMAND_ROUND)
     GAME_STATE:  game_state to query

     NODE_ID:  the node to get info about

     LAST_COMMAND_ROUND:  the last round for which a command was issued
     (out parameter)

     Queries information about a given node, mostly, what was the last
     round we got a command.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_add_cursor (lw6ker_game_state_t *
          GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID, int
          TEAM_COLOR)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to add

     TEAM_COLOR:  the color we wish

     Adds a cursor in a game. Note that if there's already a cursor with
     that id, it will fail, and the color is only the color we wish, we
     might indeed be attributed another color on a successfull call.

     *Return value:*  1 on success, 0 on error.

 -- Function: int lw6ker_game_state_remove_cursor (lw6ker_game_state_t
          * GAME_STATE, u_int64_t NODE_ID, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to act upon

     NODE_ID:  the node issuing the command

     CURSOR_ID:  the id of the cursor to remove

     Removes a cursor from the game, corresponding teams will be removed
     if needed.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_cursor_exists (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor is present in the game.

     *Return value:*  1 if cursor exists, 0 if not.

 -- Function: int lw6ker_game_state_get_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR, u_int16_t CURSOR_ID)
     GAME_STATE:  the game_state to query

     CURSOR:  the cursor data (out param)

     CURSOR_ID:  the cursor to query

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_game_state_get_cursor_by_index
          (lw6ker_game_state_t * GAME_STATE, lw6ker_cursor_t * CURSOR,
          int I)
     GAME_STATE:  the game state to query

     CURSOR:  the cursor (out param)

     I:  the index

     Gets the cursor information, using its index. This is usefull to
     walk the whole cursor without knowing their ids.

     *Return value:*  none.

 -- Function: int lw6ker_game_state_set_cursor (lw6ker_game_state_t *
          GAME_STATE, lw6ker_cursor_t * CURSOR)
     GAME_STATE:  the game_state to act upon

     CURSOR:  the cursor

     Sets a cursor, that is, changes its position, this is pretty much
     anything we can do about a cursor except adding or removing it,
     just because of Liquid War very simple rules. The passed pointer
     may be freed after the call, only the `cursor_id', `node_id', `x',
     `y' and `fire' fields are used, others are ignored. More
     precisely, the `enabled' will be ignored, it's not a valid way to
     add/remove teams.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ker_game_state_team_exists (lw6ker_game_state_t *
          GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the team color to test

     Tells wether a team color is present in the game. Note that this is
     different from cursor ids.

     *Return value:*  1 if team exists, 0 if not.

 -- Function: int lw6ker_game_state_get_team_info (lw6ker_game_state_t
          * GAME_STATE, int TEAM_COLOR, int32_t * NB_CURSORS, int32_t *
          NB_FIGHTERS)
     GAME_STATE:  the game_state to query

     TEAM_COLOR:  the color to get informations about

     NB_CURSORS:  number of cursors with this color (out param)

     NB_FIGHTERS:  number of fighters with this color (out param)

     Gets informations about a given color. Indeed, a color can have
     several cursors, and knowing how many fighters there are with a
     given color is probably the most important things about a color.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ker_game_state_get_nb_teams (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells how many teams there are in a game. This is different from
     the cursors number, there can be more cursors than teams, because
     a team can have several cursors.

     *Return value:*  the number of teams.

 -- Function: void lw6ker_game_state_do_spread (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which gradients (teams) must be
     spreaded

     Spreads the gradient, that is, calculates the potential of each
     point on the map, ie the distance to the closest cursor. The
     binary mask allows gradient to be spread for only some teams, this
     is usefull in a multithreaded context, as gradients can be
     calculated separately.

     *Return value:*  none

 -- Function: void lw6ker_game_state_do_move (lw6ker_game_state_t *
          GAME_STATE, u_int32_t TEAM_MASK)
     GAME_STATE:  the game_state to act upon

     TEAM_MASK:  a binary mask of which teams must be moved

     Moves the fighters, note that you must calculate the gradient from
     time to time else they go to the wrong places. The `team_mask'
     allows the moving of only some given teams, but moving (for
     instance) even teams then odd teams isn't the same as moving odd
     teams then even teams.  Whereas as far as gradient calculation is
     concerned, this could have been true, you could have multithreaded
     that.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_finish_round (lw6ker_game_state_t
          * GAME_STATE)
     GAME_STATE:  the game_state to act upon

     Finishes a round, that is, vaccums various stuff, checks if some
     team has lost, and so on. This is complementary to the spread and
     move steps, it should be called at each round.

     *Return value:*  none.

 -- Function: void lw6ker_game_state_do_round (lw6ker_game_state_t *
          GAME_STATE)
     game_state: the game_state to act upon

     This is a fundamental function, it's called at each round, it
     fires all the complex calculations in the game, the real core
     algorithm. Every time this function is called, the round is "over"
     and the game state is ready for the next... round. It's equivalent
     to calling the spread, move and finish functions.

     *Return value:*  none.

 -- Function: u_int32_t lw6ker_game_state_get_moves
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of moves done on this game.

     *Return value:*  number of moves.

 -- Function: u_int32_t lw6ker_game_state_get_spreads
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of spreads done on this game.

     *Return value:*  number of spreads.

 -- Function: u_int32_t lw6ker_game_state_get_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of rounds done on this game.

     *Return value:*  number of rounds.

 -- Function: u_int32_t lw6ker_game_state_get_total_rounds
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the number of playable rounds in the game, that is the
     number of rounds to be played if game goes up to the time limit.
     This is a fixed number, if game slows down then time is stretched,
     but the the exact maximum number of rounds is known at game start,
     and it is the number returned by this function.

     *Return value:*  number of rounds in the game

 -- Function: int lw6ker_game_state_is_over (lw6ker_game_state_t *
          GAME_STATE)
     GAME_STATE:  the game_state to query

     Tells wether the game is over or not. The answer depends on time
     limit, game rules, and of course what happened on the battlefield.

     *Return value:*  1 if over, 0 if not.

 -- Function: int lw6ker_game_state_did_cursor_win (lw6ker_game_state_t
          * GAME_STATE, u_int16_t CURSOR_ID)
     GAME_STATE:  game_state to query

     CURSOR_ID:  the cursor to test

     Tells wether a cursor was the winner after a game is over.

     *Return value:*  1 if cursor is in winning team, 0 if not.

 -- Function: int lw6ker_game_state_get_winner (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the winner, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the best positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the winner team number, note that it can be
     invalid (-1) if there's no winner (for example, there are no teams
     on the map).

 -- Function: int lw6ker_game_state_get_looser (lw6ker_game_state_t *
          GAME_STATE, int EXCLUDED_TEAM)
     GAME_STATE:  the game_state to query

     EXCLUDED_TEAM:  a team to exclude

     Returns the looser, if you set excluded_team to something else
     than a valid team number (for instance -1, but 0 is a valid team)
     then this team will be excluded from search. This is usefull if
     you want to find out who's the worst positionned player while
     excluding yourself, for instance if you're a bot.

     *Return value:*  the looser team number, note that it can be
     invalid (-1) if there's no looser (for example, there are no teams
     on the map).

 -- Function: int32_t lw6ker_game_state_get_nb_active_fighters
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Gets the number of active fighters, this is relatively constant
     within the game, it does not change when someone looses, but it
     can vary when a new team arrives or disappears.

     *Return value:*  number of fighters.

 -- Function: int32_t lw6ker_game_state_get_time_elapsed
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time elapsed, this is not the real time you'd time
     with an atomic clock, rather the time that would have elapsed if
     game had been run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.

     *Return value:*  time elapsed, in seconds.

 -- Function: int32_t lw6ker_game_state_get_time_left
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  the game_state to query

     Returns the time left, this is not the real time you'd time with
     an atomic clock, rather the time that would theorically be left is
     game was to be run at its nominal speed. There can be a difference
     if your computer is too slow, among other things.  You shouldn't
     rely on this to know wether a game is over or not, there's another
     dedicated function for that.

     *Return value:*  time left, in seconds.

 -- Function: int32_t lw6ker_game_state_get_global_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the global,
     long term history, reflects the whole game and could be used for
     an end-game score screen.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_latest_history
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     I:  the index of the history point

     TEAM_ID:  the team to query

     Returns the number of fighters at some point in the past (the
     lower i, the oldest). The history scrolls automatically and erases
     itself at some point, it's of constant length. This is the latest,
     short term history, reflects the recent game evolutions and could
     be used to display an in-game monitor.

     *Return value:*  number of fighters at that time.

 -- Function: int32_t lw6ker_game_state_get_global_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the global long term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_latest_history_max
          (lw6ker_game_state_t * GAME_STATE)
     GAME_STATE:  game_state to query

     Returns the maximum value, that is, the maximum number of
     fighters, all teams combined, for this history. This can be used
     to scale charts.  This function for the latest short term history.

     *Return value:*  max number of fighters.

 -- Function: int32_t lw6ker_game_state_get_fighter_id
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets the id of a fighter in a given position. Previous versions of
     the game used to have this declared inline static for speed, but
     the price to pay in terms of maintainability was too high: too
     much stuff from the ker module had to be kept public. This
     functions is very likely to be called often when one wants to know
     what's happening on the battlefield, to draw it, for instance. If
     there's no fighter, the id is negative, any id equal or greater
     than 0 (returned by this function) is valid.

     *Return value:*  the id of the fighter at that position.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_by_id
          (lw6ker_game_state_t * GAME_STATE, int32_t FIGHTER_ID)
     GAME_STATE:  game_state to query

     FIGHTER_ID:  the id of the fighter

     Gets a fighter by its id. Internally, all fighters are stored in
     an array so it could be "safe" to get fighter with id 0 then walk
     the array.  Previous versions of the game used to have this public
     (the array), it has been hidden since.

     *Return value:*  pointer to the fighter with the given id.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_safe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will check for
     boundaries, if there's no fighter in this place, it will return
     NULL, but nothing worse can happen. More precisely, if the place
     is in a wall, it won't bug, unlike the non-bullet-proof equivalent
     of this function.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: lw6ker_fighter_t * lw6ker_game_state_get_fighter_unsafe
          (lw6ker_game_state_t * GAME_STATE, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STATE:  game_state to query

     X:  x position

     Y:  y position

     Z:  z position

     Gets a fighter by its position. This function will not check for
     boundaries, if there's no fighter in this place, not only will it
     probably not return a valid value, but it will also even segfault
     before that, trying to access non-existing structures in menory.
     So only call this if you're sure there's a fighter here.

     *Return value:*  pointer to the fighter at this position, or NULL
     if none.

 -- Function: int lw6ker_game_state_get_zone_potential
          (lw6ker_game_state_t * GAME_STATE, int I, int TEAM_ID)
     GAME_STATE:  the game_state to query

     TEAM_ID:  the team id (color)

     Gets the potential of a zone. In practice this is not needed to
     make the game function, you need not call this to know how to move
     fighters, however the information can be interesting for debugging.

     *Return value:*  the potential

 -- Function: int lw6ker_game_state_get_charge_per1000
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns the charge ratio for a given team/color. A value of 100
     means fire is enabled, more than 1000 means super-charge, under 100
     means you have to wait.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_weapon_per1000_left
          (lw6ker_game_state_t * GAME_STATE, int TEAM_COLOR)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color to query

     Returns how much of the weapon is yet to be consumed for a given
     team. More than 1000 means extra time, 1000 is standard time to be
     elapsed, 0 means it's over.

     *Return value:*  integer value.

 -- Function: int lw6ker_game_state_get_latest_weapon
          (lw6ker_game_state_t * GAME_STATE, int * TEAM_COLOR, int *
          WEAPON_ID, int * PER1000_LEFT)
     GAME_STATE:  game_state to query

     TEAM_COLOR:  the team color corresponding to last weapon (out
     param)

     WEAPON_ID:  the corresponding weapon_id (out param)

     PER1000_LEFT:  how much of the weapon is yet to be spent (out
     param)

     Returns informations about the latest weapon, this is typically
     for drawing purposes, just query this and you know if you need to
     paint everything in red, green, whatever, as far as the default
     backend is concerned. In case there's no weapon, well, parameters
     are untouched. Pointers can be passed as NULL.

     *Return value:*  1 if found, 0 if not.

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_new
          (lw6map_level_t * LEVEL, lw6sys_progress_t * PROGRESS)
     LEVEL:  the level on which the game_struct is based

     PROGRESS:  progress indicator

     Creates a new game_struct from a level. The game_struct is
     different from the level in the sense that the game_struct does
     contain algorithmic specific optimizations, it's a ready-to-use
     struct desgined for execution speed, while the plain level just
     stores information.

     *Return value:*  newly allocated object

 -- Function: void lw6ker_game_struct_free (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to free

     Frees a game_struct object, releasing all required stuff. The
     source level must still be available when freeing this.

     *Return value:*  none

 -- Function: void lw6ker_game_struct_point_to (lw6ker_game_struct_t *
          GAME_STRUCT, lw6map_level_t * LEVEL)
     GAME_STRUCT:  the game_struct to modify

     LEVEL:  the level to point to

     This can be used when one makes a copy (dup) of a level and for
     some reason want the game_struct to point on this new copy. Of
     course you should make the game_struct point to a level that is
     identical to the one that was used to construct the object in the
     first place. Use at your own risk.

     *Return value:*  none

 -- Function: int lw6ker_game_struct_memory_footprint
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Returns the approximative amount of memory taken by the object.

     *Return value:*  number of bytes (approximation)

 -- Function: char * lw6ker_game_struct_repr (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Gives a readable representation of the object.

     *Return value:*  newly allocated string, must be freed

 -- Function: lw6ker_game_struct_t * lw6ker_game_struct_dup
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_progress_t *
          PROGRESS)
     GAME_STRUCT:  the game_struct to copy

     PROGRESS:  progress indicator

     Dups (copy) a game_struct object. The newly created object points
     to the same game_struct but is an independant copy, you can play a
     whole different game on it. In practice this is often used to
     create the game_struct objects for anticipation in network games.

     *Return value:*  newly created object

 -- Function: u_int32_t lw6ker_game_struct_checksum
          (lw6ker_game_struct_t * GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Calculates the checksum of a game_struct, this can be very usefull
     to make sure two structs are identicall (prevent network errors
     and/or cheating).

     *Return value:*  32-bit checksum

 -- Function: void lw6ker_game_struct_get_shape (lw6ker_game_struct_t *
          GAME_STRUCT, lw6sys_whd_t * SHAPE)
     GAME_STRUCT:  the game_struct to query

     SHAPE:  the shape (out param)

     Retrieves the shape (w*h*d)of the game_struct.

     *Return value:*  none.

 -- Function: int lw6ker_game_struct_get_w (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the width (shape.w) of the game_struct.

     *Return value:*  the width.

 -- Function: int lw6ker_game_struct_get_h (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the height (shape.h) of the game_struct.

     *Return value:*  the height.

 -- Function: int lw6ker_game_struct_get_d (lw6ker_game_struct_t *
          GAME_STRUCT)
     GAME_STRUCT:  the game_struct to query

     Retrieves the depth (shape.d, AKA number of layers) of the
     game_struct.

     *Return value:*  the depth.

 -- Function: int lw6ker_game_struct_is_fg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is foreground, that is, occupied by
     a wall.

     *Return value:*  1 if foreground (wall, fighters can't move), 0 if
     not

 -- Function: int lw6ker_game_struct_is_bg (lw6ker_game_struct_t *
          GAME_STRUCT, int32_t X, int32_t Y, int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x position

     Y:  y position

     Z:  z position

     Tests wether a given position is background, that is, there's no
     wall.

     *Return value:*  1 if background (wall, fighters can move), 0 if
     not

 -- Function: void lw6ker_game_struct_get_zones_info
          (lw6ker_game_struct_t * GAME_STRUCT, int * NB_ZONES, int *
          MAX_ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     NB_ZONES:  the maximum zone size (out param, can be NULL)

     MAX_ZONE_SIZE:  the maximum zone size (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none.

 -- Function: void lw6ker_game_struct_get_zone_info
          (lw6ker_game_struct_t * GAME_STRUCT, int I, lw6sys_xyz_t *
          ZONE_POS, int * ZONE_SIZE)
     GAME_STRUCT:  game_struct to query

     I:  index of the zone to query

     ZONE_POS:  coord of the zone, top-left corner (out param, can be
     NULL)

     ZONE_SIZE:  size of the zone (out param, can be NULL)

     This function gets information about the internal zoning system,
     can be used for debugging.

     *Return value:*  none

 -- Function: int32_t lw6ker_game_struct_get_zone_id
          (lw6ker_game_struct_t * GAME_STRUCT, int32_t X, int32_t Y,
          int32_t Z)
     GAME_STRUCT:  the game_struct to query

     X:  x pos

     Y:  y pos

     Z:  z pos

     Gets the zone id for a given position. The id returned can then be
     used to query for a potential, for instance.

     *Return value:*  the zone id

 -- Function: void lw6ker_game_struct_find_free_slot_near
          (lw6ker_game_struct_t * GAME_STRUCT, lw6sys_xyz_t * THERE,
          lw6sys_xyz_t HERE)
     GAME_STRUCT:  the game_struct to query

     THERE:  the closest free slot (out param)

     HERE:  where we'd like to be

     Tries to find the closest free slot (there) near a given position
     (here).  This is typically used internally to find out where to
     apply the cursor when it's flying over walls.

     *Return value:*  none

 -- Function: int lw6ker_move_get_best_next_pos (lw6ker_game_state_t *
          GAME_STATE, lw6sys_xyz_t * NEXT_POS, lw6sys_xyz_t *
          CURRENT_POS, int TEAM_COLOR)
     GAME_STATE:  the game_state to work on

     NEXT_POS:  the next position (out param)

     CURRENT_POS:  the current position

     TEAM_COLOR:  the team color

     Tries to find the best move given a position and a team. Note that
     this function does not check for the presence of another fighter,
     it will only check walls and can even (sometimes) fail when there's
     a path. The reason is that it uses the game_state at a given round
     and does not recalculate gradient while a real fighter has an
     ever-changing gradient. Whatsoever, this can be used to move
     cursors like they were fighters, it's not perfect but gives a good
     illusion.

     *Return value:*  1 if best place found, 0 if not.

 -- Function: int lw6ker_score_array_update (lw6ker_score_array_t *
          SCORE_ARRAY, lw6ker_game_state_t * GAME_STATE)
     SCORE_ARRAY:  the score array to modify

     GAME_STATE:  the game_state to get the information from

     Updates a score array, that is, calculates all scores, so that they
     can be displayed, for instance.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ker_team_mask_get (u_int32_t * EVEN, u_int32_t *
          ODD, int32_t ROUND)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     ROUND:  round concerned

     Returns a default team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance).

     *Return value:*  none.

 -- Function: void lw6ker_team_mask_best (u_int32_t * EVEN, u_int32_t *
          ODD, lw6ker_game_state_t * GAME_STATE)
     EVEN:  even team mask (out param)

     ODD:  odd team mask (out param)

     GAME_STATE:  the game_state concerned

     Returns an optimal team mask for a given round, even and odd will
     contain ready to use masks (for spread and move functions for
     instance). The difference with the default team mask is that this
     one will test for which teams are present and try and manage to
     find an equilibrated set of odd/even teams.

     *Return value:*  none.

 -- Function: int lw6ker_team_mask_is_concerned (int TEAM_COLOR,
          u_int32_t TEAM_MASK)
     TEAM_COLOR:  color index

     TEAM_MASK:  team mask

     Tells wether a given team is concerned by a team mask.

     *Return value:*  1 if concerned, 0 if not.

 -- Function: int lw6ker_team_mask_color2mask (int TEAM_COLOR)
     TEAM_COLOR:  color index

     Gives the mask corresponding to a given color.

     *Return value:*  bitwise mask.

 -- Function: int lw6ker_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ker' module test suite. Will perform deep checksums and
     *really* check many things. If this passes, the algorithm is fine.
     What could make it fail is a serious bug and/or some weird
     combination of endianess, byte alignment...

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6ker_cursor_control_s

 -- member of lw6ker_cursor_control_s: pos
          lw6sys_xyz_t lw6ker_cursor_control_s::pos


 -- member of lw6ker_cursor_control_s: fire
          int lw6ker_cursor_control_s::fire


 -- member of lw6ker_cursor_control_s: fire2
          int lw6ker_cursor_control_s::fire2


 -- struct: lw6ker_cursor_s

 -- member of lw6ker_cursor_s: node_id
          u_int64_t lw6ker_cursor_s::node_id


 -- member of lw6ker_cursor_s: cursor_id
          u_int16_t lw6ker_cursor_s::cursor_id


 -- member of lw6ker_cursor_s: letter
          char lw6ker_cursor_s::letter


 -- member of lw6ker_cursor_s: enabled
          int lw6ker_cursor_s::enabled


 -- member of lw6ker_cursor_s: team_color
          int lw6ker_cursor_s::team_color


 -- member of lw6ker_cursor_s: pos
          lw6sys_xyz_t lw6ker_cursor_s::pos


 -- member of lw6ker_cursor_s: fire
          int lw6ker_cursor_s::fire


 -- member of lw6ker_cursor_s: fire2
          int lw6ker_cursor_s::fire2


 -- member of lw6ker_cursor_s: apply_pos
          lw6sys_xyz_t lw6ker_cursor_s::apply_pos


 -- member of lw6ker_cursor_s: pot_offset
          int32_t lw6ker_cursor_s::pot_offset


 -- struct: lw6ker_fighter_s

 -- member of lw6ker_fighter_s: team_color
          u_int32_t lw6ker_fighter_s::team_color


 -- member of lw6ker_fighter_s: last_direction
          int32_t lw6ker_fighter_s::last_direction


 -- member of lw6ker_fighter_s: health
          int32_t lw6ker_fighter_s::health


 -- member of lw6ker_fighter_s: act_counter
          int32_t lw6ker_fighter_s::act_counter


 -- member of lw6ker_fighter_s: pad
          int32_t lw6ker_fighter_s::pad


 -- member of lw6ker_fighter_s: pos
          lw6sys_xyz_t lw6ker_fighter_s::pos


 -- struct: lw6ker_game_state_s
     Game structure containing all changeable data state, this will
     hold the fighter positions, their health, the cursors position,
     the gradient, anything that is dynamic. Note that this structure
     is a wrapper over the internal structure which contains the real
     members, the first two members need be the same as it is casted
     internally.

 -- member of lw6ker_game_state_s: id
          u_int32_t lw6ker_game_state_s::id

     The id of the object, this is non-zero and unique within one run
     session, incremented at each object creation

 -- member of lw6ker_game_state_s: game_struct
          lw6ker_game_struct_t* lw6ker_game_state_s::game_struct

     Pointer on the game non-mutable structure, which holds the data
     that is never changed within a game.

 -- struct: lw6ker_game_struct_s

 -- member of lw6ker_game_struct_s: id
          u_int32_t lw6ker_game_struct_s::id


 -- member of lw6ker_game_struct_s: level
          lw6map_level_t* lw6ker_game_struct_s::level


 -- member of lw6ker_game_struct_s: rules
          lw6map_rules_t lw6ker_game_struct_s::rules


 -- struct: lw6ker_score_array_s

 -- member of lw6ker_score_array_s: active_fighters
          int lw6ker_score_array_s::active_fighters


 -- member of lw6ker_score_array_s: nb_scores
          int lw6ker_score_array_s::nb_scores


 -- member of lw6ker_score_array_s: scores
          lw6ker_score_t lw6ker_score_array_s::scores[LW6MAP_NB_TEAM_COLORS]


 -- struct: lw6ker_score_s

 -- member of lw6ker_score_s: has_been_active
          int lw6ker_score_s::has_been_active


 -- member of lw6ker_score_s: team_color
          int lw6ker_score_s::team_color


 -- member of lw6ker_score_s: fighters_percent
          int lw6ker_score_s::fighters_percent


 -- member of lw6ker_score_s: fighters_absolute
          int lw6ker_score_s::fighters_absolute


 -- member of lw6ker_score_s: fighters_ratio
          float lw6ker_score_s::fighters_ratio


 -- member of lw6ker_score_s: frags
          int lw6ker_score_s::frags


 -- member of lw6ker_score_s: consolidated_percent
          int lw6ker_score_s::consolidated_percent



File: liquidwar6.info,  Node: libldr,  Next: libmap,  Prev: libker,  Up: C API

5.25 libldr
===========

5.25.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/ldr/index.html'.

5.25.2 API
----------

 -- Function: int lw6ldr_body_read (lw6map_body_t * BODY, const char *
          DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS, int
          DISPLAY_W, int DISPLAY_H, float RATIO, int BENCH_VALUE, int
          MAGIC_NUMBER, lw6sys_progress_t * PROGRESS)
     BODY:  the body to read, must point to allocated memory

     DIRNAME:  the directory of the map

     PARAM:  map parameters

     HINTS:  map hints

     DISPLAY_W:  the display width

     DISPLAY_H:  the display height

     RATIO:  wished map ratio

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_auto_colors (lw6map_style_t * STYLE,
          lw6ldr_hints_t * HINTS)
     STYLE:  the style structure to process.

     HINTS:  additionnal hints to know what to set automatically

     Deduces all colors from background color, if needed. The function
     will check color_auto parameters and replace all other colors by
     base and alternate colors if needed. Note that the background
     color itself is not changed by this function. Background can only
     be guessed from texture.

     *Return value:*  none.

 -- Function: int lw6ldr_cursor_texture_read (lw6map_cursor_texture_t *
          CURSOR_TEXTURE, const char * DIRNAME)
     CURSOR_TEXTURE:  the cursor texture (out param)

     DIRNAME:  the directory we load the data form (map dir)

     Reads the cursor texture information, if not available, will use
     defaults

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ldr_free_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to free

     Frees a map entry.

     *Return value:*  none.

 -- Function: lw6ldr_entry_t * lw6ldr_dup_entry (lw6ldr_entry_t * ENTRY)
     ENTRY:  the entry to dup

     Dup a map entry.

     *Return value:*  newly allocated object.

 -- Function: lw6sys_list_t * lw6ldr_get_entries (const char *
          MAP_PATH, const char * RELATIVE_PATH, const char * USER_DIR)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     Lists all maps in a given directory. Returns a list of
     lw6ldr_entry_t which can contain both directories with subdirs and
     actual maps. Maps are sorted before being returned, first
     directories, then maps, sorted in alphabetical order.

     *Return value:*  a list of dynamically allocated lw6ldr_entry_t.

 -- Function: void lw6ldr_for_all_entries (const char * MAP_PATH, const
          char * RELATIVE_PATH, const char * USER_DIR, int RECURSIVE,
          lw6sys_list_callback_func_t CALLBACK_FUNC, void * FUNC_DATA)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     RECURSIVE:  if non-zero, map search will recurse in subdirs

     CALLBACK_FUNC:  the function which will be called on each entry

     FUNC_DATA:  an extra pointer to pass data to callback_func

     Executes a given function on all maps in a given place, typically
     used in test programs.

     *Return value:*  none.

 -- Function: lw6ldr_entry_t * lw6ldr_chain_entry (const char *
          MAP_PATH, const char * RELATIVE_PATH, const char * USER_DIR)
     MAP_PATH:  the map_path environment config variable, delimited
     path list

     RELATIVE_PATH:  the relative path to use to find the map directory

     USER_DIR:  the user directory

     Gets the next entry used in test programs.

     *Return value:*  none.

 -- Function: int lw6ldr_exp_validate (lw6map_level_t * LEVEL, const
          char * USER_DIR)
     LEVEL:  the level to validate

     USER_DIR:  user directory

     Validates a level, acknowledges you've won it. Upgrades exp.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_grease_apply (lw6map_layer_t * LAYER,
          lw6map_rules_t * RULES, lw6ldr_hints_t * HINTS,
          lw6sys_progress_t * PROGRESS)
     LAYER:  the layer on which to apply the grease

     RULES:  map rules

     HINTS:  map hints

     PROGRESS:  structure to transmit loading progress

     Reads the map body, that is, all the layers.

     *Return value:*  1 if OK, 0 if failed.

 -- Function: void lw6ldr_hints_defaults (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Set the hints struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_zero (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Zeros the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6ldr_hints_clear (lw6ldr_hints_t * HINTS)
     HINTS:  data to initialize

     Clears the hints struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: int lw6ldr_hints_read (lw6ldr_hints_t * HINTS, const char
          * DIRNAME)
     DIRNAME:  the directory of the map

     Read the hints (hints.xml) of a map. Pointer to hints must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_hints_set (lw6ldr_hints_t * HINTS, const char
          * KEY, const char * VALUE)
     HINTS:  the hints to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a hints structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6ldr_hints_get (lw6ldr_hints_t * HINTS, const
          char * KEY)
     HINTS:  the hints to modify

     KEY:  the key to modify

     Gets one single parameter in a hints structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6ldr_hints_get_default (const char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given hints key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6ldr_hints_update (lw6ldr_hints_t * HINTS,
          lw6sys_assoc_t * VALUES)
     HINTS:  the hints struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides hints with values. Pointer to hints must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing hints.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_layer_read_first (lw6map_layer_t * LAYER,
          const char * FILENAME, lw6map_param_t * PARAM, lw6ldr_hints_t
          * HINTS, int DISPLAY_W, int DISPLAY_H, float TARGET_RATIO,
          int BENCH_VALUE, int MAGIC_NUMBER, int EXPECTED_DEPTH,
          lw6sys_progress_t * PROGRESS)
     LAYER:  layer to update (out param)

     FILENAME:  name of PNG file

     PARAM:  parameters of the map

     HINTS:  hints of the map

     DISPLAY_W:  width of display

     DISPLAY_H:  height of display

     TARGET_RATIO:  width/height ratio we want

     BENCH_VALUE:  bench for this computer

     MAGIC_NUMBER:  arbitrary constant

     EXPECTED_DEPTH:  depth of map according to files available

     PROGRESS:  progress object to provide feedback (in/out)

     Reads the first layer, that is map.png. This function has many
     parameters since it will try and guess the final (real) resolution
     of the map.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_layer_read_next (lw6map_layer_t * LAYER, const
          char * FILENAME, int TARGET_W, int TARGET_H)
     LAYER:  layer to update (out param)

     FILENAME:  name of PNG file

     TARGET_W:  width we want

     TARGET_H:  height we want

     Reads a layer, knowing the exact size we want. This is typically
     to load layer2-7.png once map.png has been loaded.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_metadata_read (lw6map_metadata_t * METADATA,
          const char * DIRNAME)
     METADATA:  structure containting read data (out param)

     DIRNAME:  map dirname (absolute path)

     Reads the metadata, will first parse metadata.xml, and if not
     available read README and guess a title from map path. When
     function returns, all fields in structure are non-NULL.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6ldr_meta_layer_read (lw6map_meta_layer_t *
          META_LAYER, const char * FILENAME, int TARGET_W, int
          TARGET_H, int ANALOG)
     META_LAYER:  the meta layer to read

     FILENAME:  the file to open

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_meta_layer_read_if_exists (lw6map_meta_layer_t
          * META_LAYER, const char * DIRNAME, const char * FILE_ONLY,
          int TARGET_W, int TARGET_H, int ANALOG)
     META_LAYER:  the meta layer to read

     DIRNAME:  the map directory

     FILE_ONLY:  the meta-layer file name only (without the path)

     TARGET_W:  the wanted width

     TARGET_H:  the wanted height

     ANALOG:  wether to use analog info (0-255) or boolean (0-1)

     Reads a meta-layer from the disj, resampling is done according to
     the given parameters. This function is different from
     `lw6ldr_meta_layer_read' for it will 1) concatenate `dirname' and
     `file_only' and 2) return OK (1) if file does not exist.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6ldr_param_read (lw6map_param_t * PARAM, const char
          * DIRNAME)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     DIRNAME:  the directory of the map

     Read the parameters associated to a map. Pointer to param must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_param_update (lw6map_param_t * PARAM,
          lw6sys_assoc_t * VALUES)
     PARAM:  the parameter struct to fill with values (read/write
     parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides param with values. Pointer to param must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing param.

     *Return value:*  1 if success, 0 if failed.

 -- Function: void lw6ldr_print_example_rules_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map rules.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_hints_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map hints.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_style_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map style.xml file.

     *Return value:*  none.

 -- Function: void lw6ldr_print_example_teams_xml (FILE * F)
     F:  file to output content to

     Print to a file a typical map teams.xml file.

     *Return value:*  none.

 -- Function: int lw6ldr_print_examples (char * USER_DIR)
     USER_DIR:  the user directory or at least, a writable one

     Writes all example XML files in 'user_dir/example/', will create
     the directory if needed.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read (const char * DIRNAME,
          lw6sys_assoc_t * DEFAULT_PARAM, lw6sys_assoc_t *
          FORCED_PARAM, int DISPLAY_W, int DISPLAY_H, int BENCH_VALUE,
          int MAGIC_NUMBER, const char * USER_DIR, lw6sys_progress_t *
          PROGRESS)
     DIRNAME:  the directory containing the map

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Loads a map from dist. The default_param and forced_param can
     contain values corresponding to rules.xml and style.xml entries.
     Parameters are read in 4 steps. 1st, a default value is picked by
     the program.  2nd, any value in `default_param' replaces previous
     values. 3rd, any value in rules.xml or style.xml replaces previous
     values.  4th, any value in `forced_param' replaces previous
     values. In practice, the `default_param' allows the user to set
     defaults which can still be overwritten by the map, while
     `forced_param' is a definitive 'ignore what is is defined in the
     map' way of doing things.  See also `lw6ldr_read_relative'.

     *Return value:*  1 if success, 0 if failed.

 -- Function: lw6map_level_t * lw6ldr_read_relative (const char *
          MAP_PATH, const char * RELATIVE_PATH, lw6sys_assoc_t *
          DEFAULT_PARAM, lw6sys_assoc_t * FORCED_PARAM, int DISPLAY_W,
          int DISPLAY_H, int BENCH_VALUE, int MAGIC_NUMBER, const char
          * USER_DIR, lw6sys_progress_t * PROGRESS)
     MAP_PATH:  a collection of paths where to find maps

     RELATIVE_PATH:  something which will be appended to a `map_path'
     member

     DEFAULT_PARAM:  default parameters, as strings

     FORCED_PARAM:  forced parameters, as strings

     DISPLAY_W:  the width of the display output (resolution)

     DISPLAY_H:  the height of the display output (resolution)

     BENCH_VALUE:  the bench value (depends on computer capacity)

     MAGIC_NUMBER:  arbitrary constant

     USER_DIR:  the user directory

     PROGRESS:  information used to handle the progress bar

     Reads a map from disk, using the map-path value, which is a
     collection of paths defined by the command-line, the environment
     variables, and the config file. `default_param' and `forced_param'
     work as in the function `lw6ldr_read'.

     *Return value:*  1 if success, 0 if failure.

 -- Function: void lw6ldr_resampler_init (lw6ldr_resampler_t *
          RESAMPLER, lw6map_param_t * PARAM, lw6ldr_hints_t * HINTS,
          int SOURCE_W, int SOURCE_H, int DISPLAY_W, int DISPLAY_H,
          float TARGET_RATIO, int BENCH_VALUE, int MAGIC_NUMBER, int
          EXPECTED_DEPTH, float GRAY_LEVEL)
     RESAMPLER:  resampler object to init

     PARAM:  map parameters to use

     HINTS:  loading hints

     SOURCE_W:  width of source map

     SOURCE_H:  height of source map

     DISPLAY_W:  width of source display

     DISPLAY_H:  height of source display

     TARGET_RATIO:  ratio, that is width/height of the target

     BENCH_VALUE:  rough estimation of this computer power

     MAGIC_NUMBER:  arbitrary constant, needed to calibrate speed

     EXPECTED_DEPTH:  how thick the map could be (in practice, looks
     like d in whd)

     GRAY_LEVEL:  used to estimate capacity, 1.0f is white and means
     many slots

     Initializes a resampler. There is wizardry based on the bench,
     magic number map size, gray level. This is bot bullet proof, but
     has been experience driven and is the result of many tries /
     failures and hopefully successes.  Might need tuning as the
     algorithm evolves. This is the very function that chooses the
     actual logical map size.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_force (lw6ldr_resampler_t *
          RESAMPLER, int SOURCE_W, int SOURCE_H, int TARGET_W, int
          TARGET_H)
     RESAMPLER:  resampler to set

     SOURCE_W:  source map width

     SOURCE_H:  source map height

     TARGET_W:  target map width

     TARGET_H:  target map height

     Initializes a resampler with hardcoded values, does not calibrate
     according to context, simply set it to rescale the size you want.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_source2target (lw6ldr_resampler_t *
          RESAMPLER, int * TARGET_X, int * TARGET_Y, int SOURCE_X, int
          SOURCE_Y)
     TARGET_X:  target x coordinate (out param)

     TARGET_Y:  target y coordinate (out param)

     SOURCE_X:  source x coordinate (in param)

     SOURCE_Y:  source y coordinate (in param)

     Transforms from source coordinate to target coordinates.  Does
     rounding fine-tuning, it's not a simple integer division.

     *Return value:*  none.

 -- Function: void lw6ldr_resampler_target2source (lw6ldr_resampler_t *
          RESAMPLER, int * SOURCE_X, int * SOURCE_Y, int TARGET_X, int
          TARGET_Y)
     SOURCE_X:  source x coordinate (out param)

     SOURCE_Y:  source y coordinate (out param)

     TARGET_X:  target x coordinate (in param)

     TARGET_Y:  target y coordinate (in param)

     Transforms from target coordinate to source coordinates.  Yes,
     target to source. Target is our final logical map, source is what
     we loaded from disk, here we want to know, given a point in the
     target, where to fetch its data from source.  Does rounding
     fine-tuning, it's not a simple integer division.

     *Return value:*  none.

 -- Function: int lw6ldr_rules_read (lw6map_rules_t * RULES, const char
          * DIRNAME)
     DIRNAME:  the directory of the map

     Read the rules (rules.xml) of a map. Pointer to rules must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_rules_update (lw6map_rules_t * RULES,
          lw6sys_assoc_t * VALUES)
     RULES:  the rules struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides rules with values. Pointer to rules must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing rules.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_read (lw6map_style_t * STYLE, const char
          * DIRNAME)
     DIRNAME:  the directory of the map

     Read the style (style.xml) of a map. Pointer to style must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_style_set (lw6map_style_t * STYLE, const char
          * KEY, const char * VALUE)
     STYLE:  the style to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a style structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: int lw6ldr_style_update (lw6map_style_t * STYLE,
          lw6sys_assoc_t * VALUES)
     STYLE:  the style struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides style with values. Pointer to style must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing style.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_read (lw6map_teams_t * TEAMS, const char
          * DIRNAME)
     DIRNAME:  the directory of the map

     Read the teams (teams.xml) of a map. Pointer to teams must be
     valid, and values already initialized, either zeroed or filled in
     with defaults or custom values.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_teams_update (lw6map_teams_t * TEAMS,
          lw6sys_assoc_t * VALUES)
     TEAMS:  the teams struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides teams with values. Pointer to teams must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing teams.

     *Return value:*  1 if success, 0 if failed.

 -- Function: int lw6ldr_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `ldr' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6ldr_texture_read (lw6map_texture_t * TEXTURE,
          const char * DIRNAME, lw6map_param_t * PARAM, lw6ldr_hints_t
          * HINTS, int USE_TEXTURE, int DISPLAY_W, int DISPLAY_H, float
          * RATIO, int * TEXTURE_EXISTS, lw6sys_progress_t * PROGRESS)
     TEXTURE:  structure to hold read data

     DIRNAME:  map dirname (absolute path)

     PARAM:  parameters to use

     HINTS:  loading hints to use

     USE_TEXTURE:  wether to use texture.png

     DISPLAY_W:  display width

     DISPLAY_H:  display height

     RATIO:  target width/height factor (out param)

     TEXTURE_EXISTS:  true if texture.png is here (out param)

     PROGRESS:  progress indicator (in/out param)

     Read the texture associated to a map. Pointer to texture must be
     valid, it's modified in-place. The function will automatically
     figure out if texture.png exists or if we must use
     foreground.png/background.png.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6ldr_use_defaults (lw6ldr_use_t * USE)
     USE:  struct to initialize

     Sets the use structure to its defaults, this structure being used
     to now wether we should use texture, cursor textures, rules,
     hints, style, teams and music.

     *Return value:*  none.

 -- Function: void lw6ldr_use_clear (lw6ldr_use_t * USE)
     USE:  struct to clear

     Clears the use structure, set it to the use nothing mode.

     *Return value:*  none.

 -- Function: int lw6ldr_use_set (lw6ldr_use_t * USE, const char * KEY,
          const char * VALUE)
     USE:  struct to modify

     KEY:  key to change (as a string)

     VALUE:  value to set (as a string)

     Sets a key to the given value, OK all fields are integer, this is
     just a convenient function to be called in more general functions
     which are fed with those string pointers, typically coming from an
     XML file.

     *Return value:*  1 on success, 0 on failure (key not found).

 -- Function: int lw6ldr_use_update (lw6ldr_use_t * USE, lw6sys_assoc_t
          * VALUES)
     USE:  the use struct to fill with values (read/write parameter)

     VALUES:  an assoc containing strings with the new values

     Overrides use with values. Pointer to use must be valid, and
     values already initialized, either zeroed or filled in with
     defaults or custom values. Not all parameters need be defined in
     values. It can even be NULL. The idea is just that if something is
     defined in values, it will override the existing use.

     *Return value:*  1 if success, 0 if failed.

 -- struct: lw6ldr_entry_s

 -- member of lw6ldr_entry_s: metadata
          lw6map_metadata_t lw6ldr_entry_s::metadata


 -- member of lw6ldr_entry_s: absolute_path
          char* lw6ldr_entry_s::absolute_path


 -- member of lw6ldr_entry_s: relative_path
          char* lw6ldr_entry_s::relative_path


 -- member of lw6ldr_entry_s: has_subdirs
          int lw6ldr_entry_s::has_subdirs


 -- member of lw6ldr_entry_s: nb_submaps
          int lw6ldr_entry_s::nb_submaps


 -- member of lw6ldr_entry_s: forbidden
          int lw6ldr_entry_s::forbidden


 -- struct: lw6ldr_hints_s

 -- member of lw6ldr_hints_s: resample
          int lw6ldr_hints_s::resample


 -- member of lw6ldr_hints_s: min_map_width
          int lw6ldr_hints_s::min_map_width


 -- member of lw6ldr_hints_s: max_map_width
          int lw6ldr_hints_s::max_map_width


 -- member of lw6ldr_hints_s: min_map_height
          int lw6ldr_hints_s::min_map_height


 -- member of lw6ldr_hints_s: max_map_height
          int lw6ldr_hints_s::max_map_height


 -- member of lw6ldr_hints_s: min_map_surface
          int lw6ldr_hints_s::min_map_surface


 -- member of lw6ldr_hints_s: max_map_surface
          int lw6ldr_hints_s::max_map_surface


 -- member of lw6ldr_hints_s: fighter_scale
          float lw6ldr_hints_s::fighter_scale


 -- member of lw6ldr_hints_s: downsize_using_fighter_scale
          int lw6ldr_hints_s::downsize_using_fighter_scale


 -- member of lw6ldr_hints_s: upsize_using_fighter_scale
          int lw6ldr_hints_s::upsize_using_fighter_scale


 -- member of lw6ldr_hints_s: downsize_using_bench_value
          int lw6ldr_hints_s::downsize_using_bench_value


 -- member of lw6ldr_hints_s: upsize_using_bench_value
          int lw6ldr_hints_s::upsize_using_bench_value


 -- member of lw6ldr_hints_s: guess_colors
          int lw6ldr_hints_s::guess_colors


 -- member of lw6ldr_hints_s: background_color_auto
          int lw6ldr_hints_s::background_color_auto


 -- member of lw6ldr_hints_s: hud_color_auto
          int lw6ldr_hints_s::hud_color_auto


 -- member of lw6ldr_hints_s: menu_color_auto
          int lw6ldr_hints_s::menu_color_auto


 -- member of lw6ldr_hints_s: view_color_auto
          int lw6ldr_hints_s::view_color_auto


 -- member of lw6ldr_hints_s: system_color_auto
          int lw6ldr_hints_s::system_color_auto


 -- member of lw6ldr_hints_s: wall_grease
          int lw6ldr_hints_s::wall_grease


 -- member of lw6ldr_hints_s: guess_moves_per_sec
          int lw6ldr_hints_s::guess_moves_per_sec


 -- member of lw6ldr_hints_s: speed
          float lw6ldr_hints_s::speed


 -- struct: lw6ldr_resampler_s

 -- member of lw6ldr_resampler_s: target_w
          int lw6ldr_resampler_s::target_w


 -- member of lw6ldr_resampler_s: target_h
          int lw6ldr_resampler_s::target_h


 -- member of lw6ldr_resampler_s: source_w
          int lw6ldr_resampler_s::source_w


 -- member of lw6ldr_resampler_s: source_h
          int lw6ldr_resampler_s::source_h


 -- member of lw6ldr_resampler_s: scale_x
          float lw6ldr_resampler_s::scale_x


 -- member of lw6ldr_resampler_s: scale_y
          float lw6ldr_resampler_s::scale_y


 -- struct: lw6ldr_use_s

 -- member of lw6ldr_use_s: use_texture
          int lw6ldr_use_s::use_texture


 -- member of lw6ldr_use_s: use_cursor_texture
          int lw6ldr_use_s::use_cursor_texture


 -- member of lw6ldr_use_s: use_rules_xml
          int lw6ldr_use_s::use_rules_xml


 -- member of lw6ldr_use_s: use_hints_xml
          int lw6ldr_use_s::use_hints_xml


 -- member of lw6ldr_use_s: use_style_xml
          int lw6ldr_use_s::use_style_xml


 -- member of lw6ldr_use_s: use_teams_xml
          int lw6ldr_use_s::use_teams_xml


 -- member of lw6ldr_use_s: use_music_file
          int lw6ldr_use_s::use_music_file



File: liquidwar6.info,  Node: libmap,  Next: libmsg,  Prev: libldr,  Up: C API

5.26 libmap
===========

5.26.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/map/index.html'.

5.26.2 API
----------

 -- Function: void lw6map_body_builtin_custom (lw6map_body_t * BODY,
          int W, int H, int D, int NOISE_PERCENT, const lw6map_rules_t
          * RULES)
     BODY:  the body to initialize

     W:  the width

     H:  the height

     D:  the depth

     NOISE_PERCENT:  the noise level to fill meta layers with

     RULES:  the map rules

     Sets up a default body structure.

     *Return value:*  none

 -- Function: void lw6map_body_clear (lw6map_body_t * BODY)
     BODY:  the structure to clear

     Clears a body structure.

     *Return value:*  none.

 -- Function: void lw6map_body_fix_checksum (lw6map_body_t * BODY)
     BODY:  the structure to update

     Updates (calculates) the checksum of a map body structure.

     *Return value:*  none.

 -- Function: int lw6map_body_check_and_fix_holes (lw6map_body_t *
          BODY, const lw6map_rules_t * RULES)
     BODY:  the structure to update

     RULES:  the game rules

     This (fundamental) function ensures that all playable areas in a
     map are connected. If isolated zones are found out, then they are
     marked as walls and not used any more.

     *Return value:*  none.

 -- Function: int lw6map_body_coord_from_texture (lw6map_level_t *
          LEVEL, int * BODY_X, int * BODY_Y, int TEXTURE_X, int
          TEXTURE_Y)
     LEVEL:  the level to work on

     BODY_X:  the body (logical) x coord

     BODY_Y:  the body (logical) y coord

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Gets body (logical) coords from texture position.

     *Return value:*  1 on success, 0 on failure (out of bounds)

 -- Function: u_int8_t lw6map_body_get_with_texture_coord
          (lw6map_level_t * LEVEL, int TEXTURE_X, int TEXTURE_Y, int Z)
     LEVEL:  the level to work on

     TEXTURE_X:  the texture x coord

     TEXTURE_Y:  the texture y coord

     Z:  the z position (depth related)

     Tells wether a given map position is free or not, but using
     texture coords.

     *Return value:*  1 if position is playable, 0 if not (wall)

 -- Function: void lw6map_color_invert (lw6map_color_couple_t * COLOR)
     COLOR:  the color to invert

     Inverts a color couple, that is, replace fg by bg and vice-versa.

     *Return value:*  none.

 -- Function: int lw6map_color_is_same (const lw6map_color_couple_t *
          COLOR1, const lw6map_color_couple_t * COLOR2)
     COLOR1:  1st color to compare

     COLOR2:  2nd color to compare

     Compares two colors.

     *Return value:*  1 if equal, 0 if not.

 -- Function: char * lw6map_team_color_index_to_key (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_team_color_key_to_index (const char * KEY)
     KEY:  key of the color, for instance "red"

     The index of the color, between 0 & 9

     *Return value:*  an integer.

 -- Function: char * lw6map_team_color_index_to_label (int INDEX)
     INDEX:  index of the color between 0 & 9

     Transforms a team color index into its readable string form, which
     can be used to display information to players.

     *Return value:*  a string, must *not* be freed.

 -- Function: void lw6map_coords_fix_xy (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * X, int * Y)
     RULES:  set of rules to use

     SHAPE:  shape of the map

     X:  x coord (in/out param)

     Y:  y coord (in/out param)

     Fixes the x and y values so that it's always inside the map. This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too much on the
     right might reapper on the left side of the map.

     *Return value:*  none.

 -- Function: void lw6map_coords_fix_z (const lw6map_rules_t * RULES,
          const lw6sys_whd_t * SHAPE, int * Z)
     RULES:  set of rules to use

     SHAPE:  shape of the map

     Z:  z coord (in/out param)

     Fixes the z value so that it's always inside the map. This
     function will read the rules and if there's some polarity enable,
     will do the right thing, for instance, a fighter too low it might
     reapper on top.

     *Return value:*  none.

 -- Function: void lw6map_cursor_texture_clear (lw6map_cursor_texture_t
          * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Clears a cursor texture (set it all transparent).

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_builtin
          (lw6map_cursor_texture_t * CURSOR_TEXTURE)
     CURSOR_TEXTURE:  the cursor texture to clear

     Sets a cursor texture to the builtin defauts, that is a circle
     that is black on the outside and gets white/transparent in the
     middle.

     *Return value:*  none

 -- Function: void lw6map_cursor_texture_layer_set
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y, lw6sys_color_8_t COLOR)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to change

     X:  x coord

     Y:  y coord

     COLOR:  the color

     Sets a pixel in the cursor texture_layer.

     *Return value:*  none

 -- Function: lw6sys_color_8_t lw6map_cursor_texture_layer_get
          (lw6map_cursor_texture_layer_t * CURSOR_TEXTURE_LAYER, int X,
          int Y)
     CURSOR_TEXTURE_LAYER:  the cursor texture_layer to query

     X:  x coord

     Y:  y coord

     Gets a pixel in the cursor texture_layer.

     *Return value:*  the color

 -- Function: lw6map_level_t * lw6map_dup (lw6map_level_t * SOURCE,
          lw6sys_progress_t * PROGRESS)
     SOURCE:  the map to copy

     PROGRESS:  to show advancement

     Performs a deep copy of the map, all elements are newly allocated
     and source can safely be destroyed after it's been duplicated.

     *Return value:*  a newly allocated map, may be NULL.

 -- Function: int lw6map_exp_get_highest_team_color_allowed (int EXP)
     EXP:  the player experience

     Gets the highest color available for a given exp.

     *Return value:*  a color id

 -- Function: int lw6map_exp_get_highest_weapon_allowed (int EXP)
     EXP:  the player experience

     Gets the highest weapon available for a given exp.

     *Return value:*  a weapon id

 -- Function: int lw6map_exp_is_team_color_allowed (const
          lw6map_rules_t * RULES, int TEAM_COLOR_ID)
     RULES:  set of rules to use

     TEAM_COLOR_ID:  color id to test

     Tests wether a team color is allowed for a given set of rules.

     *Return value:*  1 if allowed, 0 if not.

 -- Function: int lw6map_exp_is_weapon_allowed (const lw6map_rules_t *
          RULES, int WEAPON_ID)
     RULES:  set of rules to use

     WEAPON_ID:  weapon id to test

     Tests wether a weapon is allowed for a given set of rules.

     *Return value:*  1 if allowed, 0 if not.

 -- Function: int lw6map_exp_get_unlocked_team_color (int EXP)
     EXP:  exp to test

     Get the unlocked team color for a given exp, if applyable.

     *Return value:*  -1 if nothing unlocked, else the team color

 -- Function: int lw6map_exp_get_unlocked_weapon (int EXP)
     EXP:  exp to test

     Get the unlocked primary weapon for a given exp, if applyable.

     *Return value:*  -1 if nothing unlocked, else the weapon id

 -- Function: char * lw6map_to_hexa (lw6map_level_t * LEVEL)
     Converts a map to something that is later readable by
     `lw6map_from_hexa' to reproduce the exact same map. Just a
     serializer.

     *Return value:*  a newly allocated pointer, NULL if conversion
     failed.

 -- Function: lw6map_level_t * lw6map_from_hexa (const char * HEXA)
     HEXA:  an hexadecimal ASCII string, created by `lw6map_to_hexa'

     Constructs a map from an hexadecimal string generated by
     `lw6map_to_hexa'. Just an un-serializer.

     *Return value:*  a new map, might be NULL if string isn't correct.

 -- Function: void lw6map_layer_builtin_custom (lw6map_layer_t * LAYER,
          int W, int H)
     LAYER:  the layer to init

     W:  width

     H:  height

     Creates a default layer. This is mostly for testing purposes, the
     default layer is not empty, it contains a simplified map of the
     world.

     *Return value:*  none

 -- Function: void lw6map_layer_clear (lw6map_layer_t * LAYER)
     LAYER:  the layer to init

     Clears a layer struct. This means freeing the pointer if it's non
     NULL and setting everything to 0.

     *Return value:*  none

 -- Function: lw6map_level_t * lw6map_new ()
     Creates a new empty map. This object is perfectly unusable as is,
     since it has a 0x0 size, and many things set to "NULL". Still, it's
     used internally and is the canonical way to create the object, it
     ensures later calls that set up default parameters, for instance,
     will succeed.

     *Return value:*  a newly allocated pointer.

 -- Function: lw6map_level_t * lw6map_builtin_defaults ()
     Creates a map, set to defaults. This is usefull mostly for testing.
     This builtin map has walls, paths, it's playable.

     *Return value:*  a newly allocated map.

 -- Function: lw6map_level_t * lw6map_builtin_custom (int W, int H, int
          D, int NOISE_PERCENT)
     W:  the width of the map

     H:  the height of the map

     D:  the depth (number of layers) of the map

     NOISE_PERCENT:  percentage of noise to use for metalayers

     Creates a map, set to defaults. This is usefull mostly for testing.
     This one, unlike `lw6map_builtin_defaults'  will let you give a
     width, height and a depth.

     *Return value:*  a newly allocated map.

 -- Function: void lw6map_free (lw6map_level_t * LEVEL)
     Frees a map and releases all its internal ressources.

     *Return value:*  none.

 -- Function: int lw6map_memory_footprint (lw6map_level_t * LEVEL)
     Reports how many bytes the map needs, in memory. Note that this is
     not contiguous memory, it involves a bunch of pointers, and
     possibly much more...

 -- Function: char * lw6map_repr (lw6map_level_t * LEVEL)
     Returns a string describing the map. This is a very short
     description, use it for logs, and to debug stuff. By no means it's
     a complete exhaustive description. Still, the string returned
     should be unique.

     *Return value:*  a dynamically allocated string.

 -- Function: int lw6map_is_same (const lw6map_level_t * LEVEL_A, const
          lw6map_level_t * LEVEL_B)
     LEVEL_A:  the first level to compare

     LEVEL_B:  the other level to compare

     Compares two level structs, the idea is to compare the content, not
     only the pointers and level ids.

     *Return value:*  1 if they're the same, 0 if not.

 -- Function: int lw6map_local_info_set_music_dir (lw6map_local_info_t
          * LOCAL_INFO, const char * MUSIC_DIR)
     LOCAL_INFO:  the structure to modify

     MUSIC_DIR:  the new music_dir value

     Sets the music_dir value, in a 'safe' manner, freeing any previous
     value and performing a string duplication.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_local_info_clear (lw6map_local_info_t *
          LOCAL_INFO)
     LOCAL_INFO:  the structure to clear

     Clears the local_info structure, before destroying a level for
     instance.

     *Return value:*  none

 -- Function: void lw6map_metadata_defaults (lw6map_metadata_t *
          METADATA)
     METADATA:  struct to set to defaults

     Sets the metadata struct to defaults, this does not set fields to
     NULL/empty values, but rather fills it with data claiming, for
     instance, that this is a default map.

     *Return value:*  none.

 -- Function: void lw6map_metadata_clear (lw6map_metadata_t * METADATA)
     METADATA:  struct to clear

     Clears a metadata, will expect it to be in a consistent state,
     that is either filled with proper values or completely zeroed.

     *Return value:*  none.

 -- Function: int lw6map_metadata_is_same (const lw6map_metadata_t *
          METADATA_A, const lw6map_metadata_t * METADATA_B)
     METADATA_A:  first item to compare

     METADATA_B:  second item to compare

     Tells wether both metadata items contain the same values.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_meta_layer_set (lw6map_meta_layer_t *
          META_LAYER, int X, int Y, u_int8_t VALUE)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     VALUE:  the value to set at this place

     Simple setter for the meta_layer struct.

     *Return value:*  none

 -- Function: u_int8_t lw6map_meta_layer_get (lw6map_meta_layer_t *
          META_LAYER, int X, int Y)
     META_LAYER:  the meta_layer structure

     X:  x coord

     Y:  y coord

     Simple getter for the meta_layer struct.

     *Return value:*  the value at this place

 -- Function: void lw6map_meta_layer_clear (lw6map_meta_layer_t *
          META_LAYER)
     META_LAYER:  the meta_layer to clear

     Clears a meta_layer struct. This means freeing the pointer if it's
     non NULL and setting everything to 0.

     *Return value:*  none

 -- Function: int lw6map_meta_layer_builtin_custom (lw6map_meta_layer_t
          * META_LAYER, int W, int H, int ANALOG, int NOISE_PERCENT,
          int SEED)
     META_LAYER:  the object to init

     W:  width

     H:  height

     ANALOG:  wether to use analog mode (0-255) or boolean (0-1)

     NOISE_PERCENT:  the quantity of noise to initialise the layer with

     SEED:  a pseudo-random seed to feed the pseudo-random generator

     Builds a custom metalyer, suitable for tests or demo, letting the
     choice of its size and the noise to fill it with. If noise is 100
     then metalayer is "full". If noise is 0, then meta layer is empty.

     *Return value:*  1 if OK, 0 on failure.

 -- Function: void lw6map_param_defaults (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Sets a param structure to its default value, note that current
     structured must be zeroed or correctly initialized.

     *Return value:*  none

 -- Function: void lw6map_param_clear (lw6map_param_t * PARAM)
     PARAM:  the param struct to modify

     Resets a param structure to nothing. Note that current structured
     must be zeroed or correctly initialized.  The idea is just to free
     member pointers before calling free.

     *Return value:*  none

 -- Function: void lw6map_param_copy (lw6map_param_t * DST,
          lw6map_param_t * SRC)
     DST:  the destination param struct

     SRC:  the source param struct

     Copies parameters. Both structures must be zeroed or correctly
     initialized.

     *Return value:*  none

 -- Function: int lw6map_param_set (lw6map_param_t * PARAM, const char
          * KEY, const char * VALUE)
     PARAM:  the param struct to modify

     KEY:  the name of the parameter to modify

     VALUE:  the value of the parameter to modify

     Sets an entry in a param struct. All values must be submitted as
     strings, internally, the function will call atoi to convert to
     integers if needed, for instance. It will also dispatch
     automatically between rules, style and teams.

     *Return value:*  1 if parameter successfully set, 0 on error.

 -- Function: char * lw6map_param_get (lw6map_param_t * PARAM, const
          char * KEY)
     PARAM:  the param struct to query

     KEY:  the name of the parameter to get

     Gets an entry from a param struct. All values returned as strings,
     do not use this in performance bottlenecks, this is just to export
     values to scripts, for instance.

     *Return value:*  dynamically allocated string, NULL on error,
     might return a string containing 0 on bad keys.

 -- Function: int lw6map_param_is_same (const lw6map_param_t * PARAM_A,
          const lw6map_param_t * PARAM_B)
     PARAM_A:  one struct to compare

     PARAM_B:  another struct to compare

     Compares the contents of two param structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: void lw6map_rules_defaults (lw6map_rules_t * RULES)
     RULES:  struct to set to defaults

     Set rules to default values, as these are all integers, you can
     call this on any rules object.

     *Return value:*  none.

 -- Function: void lw6map_rules_copy (lw6map_rules_t * DST, const
          lw6map_rules_t * SRC)
     DST:  destination (out param)

     SRC:  source (in param)

     Copies the data from source to destination, simple wrapper on
     memcpy.

     *Return value:*  none.

 -- Function: void lw6map_rules_update_checksum (const lw6map_rules_t *
          RULES, u_int32_t * CHECKSUM)
     RULES:  rules struct to check

     CHECKSUM:  checksum to update (in/out param)

     Updates a checksum with the rules data.

     *Return value:*  none.

 -- Function: int32_t lw6map_rules_get_default (const char * KEY)
     KEY:  key to query

     Get the default value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_min (const char * KEY)
     KEY:  key to query

     Get the min value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_max (const char * KEY)
     KEY:  key to query

     Get the min value for a given string key. Of course you could
     access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int32_t lw6map_rules_get_int (const lw6map_rules_t *
          RULES, const char * KEY)
     RULES:  struct to use

     KEY:  key to query

     Get the value for a given string key, as an integer. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  integer.

 -- Function: int lw6map_rules_set_int (lw6map_rules_t * RULES, const
          char * KEY, int32_t VALUE)
     RULES:  struct to use

     KEY:  key to set

     VALUE:  new integer value for key

     Set the value for a given string key, as an integer. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  1 on success, 0 on failure (eg key not found)

 -- Function: int lw6map_rules_get_bool (const lw6map_rules_t * RULES,
          const char * KEY)
     RULES:  struct to use

     KEY:  key to query

     Get the value for a given string key, as a boolean. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  boolean.

 -- Function: int lw6map_rules_set_bool (lw6map_rules_t * RULES, const
          char * KEY, int VALUE)
     RULES:  struct to use

     KEY:  key to set

     VALUE:  new boolean value for key

     Set the value for a given string key, as a boolean. Of course you
     could access the member, but this function internally does the
     conversion between readable string and actual struct offset.

     *Return value:*  1 on success, 0 on failure (eg key not found)

 -- Function: void lw6map_rules_clear (lw6map_rules_t * RULES)
     RULES:  struct to init

     Set rules to 0, this is not defaults, this is 0 (probably unusable
     as a real-world setting).

     *Return value:*  none.

 -- Function: int lw6map_rules_is_same (const lw6map_rules_t * RULES_A,
          const lw6map_rules_t * RULES_B)
     RULES_A:  first item to compare

     RULES_B:  second item to compare

     Compares two rules items. Will tell if they contain the same data.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_style_zero (lw6map_style_t * STYLE)
     STYLE:  struct to initialize

     Sets a style struct to zero, simply puts zero everywhere without
     checking what was here before

     *Return value:*  none.

 -- Function: void lw6map_style_defaults (lw6map_style_t * STYLE)
     STYLE:  struct to modify

     Sets a style struct to defaults values, expects the object to be
     in a consistent style, that's to say either containing real data
     or being zeroed.

     *Return value:*  none.

 -- Function: void lw6map_style_clear (lw6map_style_t * STYLE)
     STYLE:  struct to clear

     Clears a style struct. This function won't work on an unitialized
     structure, structure must be zeroed by some CALLOC or something,
     else automatic freeing of pointers will fail.

     *Return value:*  none.

 -- Function: void lw6map_style_copy (lw6map_style_t * DST,
          lw6map_style_t * SRC)
     DST:  destination

     SRC:  source

     Copies style data from source to destination.  Like with clear,
     `dst' must be either initialized or totally zeroed, else function
     will fail (core dump)

     *Return value:*  none.

 -- Function: int lw6map_style_set (lw6map_style_t * STYLE, const char
          * KEY, const char * VALUE)
     STYLE:  style struct to modify (out param)

     KEY:  key to use

     VALUE:  value to use

     Sets a style entry, takes string values and will identify the
     struct offset and convert the value to whatever C type is needed.

     *Return value:*  1 on success, 0 on failure (key not found)

 -- Function: char * lw6map_style_get (lw6map_style_t * STYLE, const
          char * KEY)
     STYLE:  style struct to query

     KEY:  key to use

     Get a style entry, takes a string key and will identify the struct
     offset. The return value is converted to string, typically the
     cannonical representation suitable to write in an XML config file.

     *Return value:*  dynamically allocated string.

 -- Function: char * lw6map_style_get_default (const char * KEY)
     KEY:  key to query

     Get the default value for a style entry. This is quite a
     cost-expensive function given what it does, indeed it will convert
     anything to a string, and also perform key lookup to fetch the
     value.

     *Return value:*  dynamically allocated string.

 -- Function: int lw6map_color_set_is_same (const lw6map_color_set_t *
          COLOR_SET_A, const lw6map_color_set_t * COLOR_SET_B)
     COLOR_SET_A:  first item to compare

     COLOR_SET_B:  second item to compare

     Compares two color sets, telling if they contain the same data.

     *Return value:*  1 if same, 0 if different.

 -- Function: int lw6map_style_is_same (const lw6map_style_t * STYLE_A,
          const lw6map_style_t * STYLE_B)
     STYLE_A:  first item to compare

     STYLE_B:  second item to compare

     Compares two style structures, telling if they contain the same
     data.

     *Return value:*  1 if same, 0 if different.

 -- Function: void lw6map_teams_zero (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Zeros the teams struct, this is not the same as setting to
     defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_defaults (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Set the teams struct to its defaults.

     *Return value:*  none.

 -- Function: void lw6map_teams_clear (lw6map_teams_t * TEAMS)
     TEAMS:  data to initialize

     Clears the teams struct, this is not the same as setting to
     defaults.  This one supposes the struct has been properly
     initialized, at least zeroed before usage, it might contain
     pointers which should be freed.

     *Return value:*  none.

 -- Function: void lw6map_teams_copy (lw6map_teams_t * DST,
          lw6map_teams_t * SRC)
     DST:  destination

     SRC:  source

     Copies the contents of the teams struct. It's a real duplicate,
     any string is reallocated.

     *Return value:*  none.

 -- Function: int lw6map_teams_set (lw6map_teams_t * TEAMS, const char
          * KEY, const char * VALUE)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     VALUE:  the value to affect to the key, as a string

     Sets one single parameter in a teams structure. Value must always
     be passed as a string, will be converted to the right type
     automatically when storing it in the structure.

     *Return value:*  1 if success, 0 if failed. Note that while 0
     really means there's a problem, some affectations can fail and
     return 1, needs to be worked on.

 -- Function: char * lw6map_teams_get (lw6map_teams_t * TEAMS, const
          char * KEY)
     TEAMS:  the teams to modify

     KEY:  the key to modify

     Gets one single parameter in a teams structure. Value is converted
     as a string.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: char * lw6map_teams_get_default (const char * KEY)
     KEY:  the key we want informations about.

     Gets the default value for a given teams key.

     *Return value:*  dynamically allocated string, NULL on error.

 -- Function: int lw6map_teams_is_same (const lw6map_teams_t * TEAMS_A,
          const lw6map_teams_t * TEAMS_B)
     TEAMS_A:  one struct to compare

     TEAMS_B:  another struct to compare

     Compares the contents of two teams structs.

     *Return value:*  1 if they contain the same thing, 0 if not

 -- Function: int lw6map_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `map' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6map_texture_from_body (lw6map_texture_t * TEXTURE,
          lw6map_body_t * BODY, lw6map_color_couple_t * COLOR)
     TEXTURE:  texture to load (out param)

     BODY:  body to pick data from

     COLOR:  colors to use

     Will create a default bicolor texture from the body data, this is
     in case we don't want to use the texture or there is none. Result
     is not beautifull but might be very comfortable to play.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6map_texture_clear (lw6map_texture_t * TEXTURE)
     TEXTURE:  data to clear

     Clears a texture object, expects it to be in a consitent state,
     either filled with real data of zeroed.

     *Return value:*  none.

 -- Function: int lw6map_texture_coord_from_body (lw6map_level_t *
          LEVEL, int * TEXTURE_X, int * TEXTURE_Y, int BODY_X, int
          BODY_Y)
     LEVEL:  map to work on

     TEXTURE_X:  texture x coordinate (out param)

     TEXTURE_Y:  texture y coordinate (out param)

     BODY_X:  body x coordinate (in param)

     BODY_Y:  body y coordinate (in param)

     Translates from body coordinate space to texture coordinate space.

     *Return value:*  1 on success, 0 if failure.

 -- Function: lw6sys_color_8_t lw6map_texture_get_with_body_coord
          (lw6map_level_t * LEVEL, int BODY_X, int BODY_Y)
     LEVEL:  map to use

     BODY_X:  x coordinate in body space

     BODY_Y:  y coordinate in body space

     Get the color of a given point in the texture, using the body
     coordinate space.

     *Return value:*  RGBA 8-bit color.

 -- Function: int lw6map_texture_has_alpha (lw6map_texture_t * TEXTURE)
     TEXTURE:  texture object to test

     Finds out if the texture is fully opaque or not. If it has an
     alpha layer (typically, PNG file) but this one is filled at 100%
     everywhere, then it will consider opaque. This is a slow function
     but the result is cached in the has_alpha member, so as the
     function is called at map loading, use the cached value instead.

     *Return value:*  1 if has used alpha layer, 0 if opaque.

 -- Function: char * lw6map_weapon_index_to_key (int INDEX)
     INDEX:  index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form,
     which can be used in config files for instance.

     *Return value:*  a string, must *not* be freed.

 -- Function: int lw6map_weapon_key_to_index (const char * KEY)
     KEY:  key of the weapon, for instance "red"

     The index of the weapon, between 0 & 19

     *Return value:*  an integer.

 -- Function: char * lw6map_weapon_index_to_label (int INDEX)
     INDEX:  index of the weapon between 0 & 19

     Transforms a team weapon index into its readable string form,
     which can be used to display information to players.

     *Return value:*  a string, must *not* be freed.

 -- struct: lw6map_body_s

 -- member of lw6map_body_s: checksum
          int lw6map_body_s::checksum


 -- member of lw6map_body_s: shape
          lw6sys_whd_t lw6map_body_s::shape


 -- member of lw6map_body_s: layers
          lw6map_layer_t lw6map_body_s::layers[LW6MAP_MAX_BODY_DEPTH]


 -- member of lw6map_body_s: glue
          lw6map_meta_layer_t lw6map_body_s::glue


 -- member of lw6map_body_s: boost
          lw6map_meta_layer_t lw6map_body_s::boost


 -- member of lw6map_body_s: danger
          lw6map_meta_layer_t lw6map_body_s::danger


 -- member of lw6map_body_s: medicine
          lw6map_meta_layer_t lw6map_body_s::medicine


 -- member of lw6map_body_s: one_way_north
          lw6map_meta_layer_t lw6map_body_s::one_way_north


 -- member of lw6map_body_s: one_way_east
          lw6map_meta_layer_t lw6map_body_s::one_way_east


 -- member of lw6map_body_s: one_way_south
          lw6map_meta_layer_t lw6map_body_s::one_way_south


 -- member of lw6map_body_s: one_way_west
          lw6map_meta_layer_t lw6map_body_s::one_way_west


 -- struct: lw6map_bot_info_s

 -- member of lw6map_bot_info_s: color
          int lw6map_bot_info_s::color


 -- member of lw6map_bot_info_s: ai
          char* lw6map_bot_info_s::ai


 -- struct: lw6map_color_couple_s

 -- member of lw6map_color_couple_s: fg
          lw6sys_color_8_t lw6map_color_couple_s::fg


 -- member of lw6map_color_couple_s: bg
          lw6sys_color_8_t lw6map_color_couple_s::bg


 -- struct: lw6map_color_set_s

 -- member of lw6map_color_set_s: color_base
          lw6map_color_couple_t lw6map_color_set_s::color_base


 -- member of lw6map_color_set_s: color_alternate
          lw6map_color_couple_t lw6map_color_set_s::color_alternate


 -- member of lw6map_color_set_s: background_color_root
          lw6map_color_couple_t lw6map_color_set_s::background_color_root


 -- member of lw6map_color_set_s: background_color_stuff
          lw6map_color_couple_t lw6map_color_set_s::background_color_stuff


 -- member of lw6map_color_set_s: hud_color_frame
          lw6map_color_couple_t lw6map_color_set_s::hud_color_frame


 -- member of lw6map_color_set_s: hud_color_text
          lw6map_color_couple_t lw6map_color_set_s::hud_color_text


 -- member of lw6map_color_set_s: menu_color_default
          lw6map_color_couple_t lw6map_color_set_s::menu_color_default


 -- member of lw6map_color_set_s: menu_color_selected
          lw6map_color_couple_t lw6map_color_set_s::menu_color_selected


 -- member of lw6map_color_set_s: menu_color_disabled
          lw6map_color_couple_t lw6map_color_set_s::menu_color_disabled


 -- member of lw6map_color_set_s: view_color_cursor
          lw6map_color_couple_t lw6map_color_set_s::view_color_cursor


 -- member of lw6map_color_set_s: view_color_map
          lw6map_color_couple_t lw6map_color_set_s::view_color_map


 -- member of lw6map_color_set_s: system_color
          lw6map_color_couple_t lw6map_color_set_s::system_color


 -- member of lw6map_color_set_s: team_color_dead
          lw6sys_color_8_t lw6map_color_set_s::team_color_dead


 -- member of lw6map_color_set_s: team_colors
          lw6sys_color_8_t lw6map_color_set_s::team_colors[LW6MAP_NB_TEAM_COLORS]


 -- struct: lw6map_cursor_texture_layer_s

 -- member of lw6map_cursor_texture_layer_s: data
          lw6sys_color_8_t lw6map_cursor_texture_layer_s::data[LW6MAP_CURSOR_TEXTURE_SIZE][LW6MAP_CURSOR_TEXTURE_SIZE]


 -- struct: lw6map_cursor_texture_s

 -- member of lw6map_cursor_texture_s: fg_bg_layer
          lw6map_cursor_texture_layer_t lw6map_cursor_texture_s::fg_bg_layer


 -- member of lw6map_cursor_texture_s: color_layer
          lw6map_cursor_texture_layer_t lw6map_cursor_texture_s::color_layer


 -- struct: lw6map_layer_s

 -- member of lw6map_layer_s: shape
          lw6sys_whd_t lw6map_layer_s::shape


 -- member of lw6map_layer_s: data
          u_int8_t* lw6map_layer_s::data


 -- struct: lw6map_level_s

 -- member of lw6map_level_s: id
          u_int32_t lw6map_level_s::id


 -- member of lw6map_level_s: metadata
          lw6map_metadata_t lw6map_level_s::metadata


 -- member of lw6map_level_s: local_info
          lw6map_local_info_t lw6map_level_s::local_info


 -- member of lw6map_level_s: body
          lw6map_body_t lw6map_level_s::body


 -- member of lw6map_level_s: texture
          lw6map_texture_t lw6map_level_s::texture


 -- member of lw6map_level_s: cursor_texture
          lw6map_cursor_texture_t lw6map_level_s::cursor_texture


 -- member of lw6map_level_s: param
          lw6map_param_t lw6map_level_s::param


 -- struct: lw6map_local_info_s

 -- member of lw6map_local_info_s: music_dir
          char* lw6map_local_info_s::music_dir


 -- struct: lw6map_metadata_s

 -- member of lw6map_metadata_s: title
          char* lw6map_metadata_s::title


 -- member of lw6map_metadata_s: author
          char* lw6map_metadata_s::author


 -- member of lw6map_metadata_s: description
          char* lw6map_metadata_s::description


 -- member of lw6map_metadata_s: license
          char* lw6map_metadata_s::license


 -- member of lw6map_metadata_s: vanilla_exp
          int lw6map_metadata_s::vanilla_exp


 -- struct: lw6map_meta_layer_s

 -- member of lw6map_meta_layer_s: shape
          lw6sys_whd_t lw6map_meta_layer_s::shape


 -- member of lw6map_meta_layer_s: data
          u_int8_t* lw6map_meta_layer_s::data


 -- struct: lw6map_param_s

 -- member of lw6map_param_s: rules
          lw6map_rules_t lw6map_param_s::rules


 -- member of lw6map_param_s: style
          lw6map_style_t lw6map_param_s::style


 -- member of lw6map_param_s: teams
          lw6map_teams_t lw6map_param_s::teams


 -- struct: lw6map_rules_s

 -- member of lw6map_rules_s: total_time
          int32_t lw6map_rules_s::total_time


 -- member of lw6map_rules_s: respawn_team
          int32_t lw6map_rules_s::respawn_team


 -- member of lw6map_rules_s: respawn_position_mode
          int32_t lw6map_rules_s::respawn_position_mode


 -- member of lw6map_rules_s: respawn_delay
          int32_t lw6map_rules_s::respawn_delay


 -- member of lw6map_rules_s: moves_per_round
          int32_t lw6map_rules_s::moves_per_round


 -- member of lw6map_rules_s: spreads_per_round
          int32_t lw6map_rules_s::spreads_per_round


 -- member of lw6map_rules_s: rounds_per_sec
          int32_t lw6map_rules_s::rounds_per_sec


 -- member of lw6map_rules_s: fighter_attack
          int32_t lw6map_rules_s::fighter_attack


 -- member of lw6map_rules_s: fighter_defense
          int32_t lw6map_rules_s::fighter_defense


 -- member of lw6map_rules_s: fighter_new_health
          int32_t lw6map_rules_s::fighter_new_health


 -- member of lw6map_rules_s: fighter_regenerate
          int32_t lw6map_rules_s::fighter_regenerate


 -- member of lw6map_rules_s: side_attack_factor
          int32_t lw6map_rules_s::side_attack_factor


 -- member of lw6map_rules_s: side_defense_factor
          int32_t lw6map_rules_s::side_defense_factor


 -- member of lw6map_rules_s: nb_move_tries
          int32_t lw6map_rules_s::nb_move_tries


 -- member of lw6map_rules_s: nb_attack_tries
          int32_t lw6map_rules_s::nb_attack_tries


 -- member of lw6map_rules_s: nb_defense_tries
          int32_t lw6map_rules_s::nb_defense_tries


 -- member of lw6map_rules_s: vertical_move
          int32_t lw6map_rules_s::vertical_move


 -- member of lw6map_rules_s: spread_mode
          int32_t lw6map_rules_s::spread_mode


 -- member of lw6map_rules_s: single_army_size
          int32_t lw6map_rules_s::single_army_size


 -- member of lw6map_rules_s: total_armies_size
          int32_t lw6map_rules_s::total_armies_size


 -- member of lw6map_rules_s: max_nb_teams
          int32_t lw6map_rules_s::max_nb_teams


 -- member of lw6map_rules_s: max_nb_cursors
          int32_t lw6map_rules_s::max_nb_cursors


 -- member of lw6map_rules_s: max_nb_nodes
          int32_t lw6map_rules_s::max_nb_nodes


 -- member of lw6map_rules_s: exp
          int32_t lw6map_rules_s::exp


 -- member of lw6map_rules_s: highest_team_color_allowed
          int32_t lw6map_rules_s::highest_team_color_allowed


 -- member of lw6map_rules_s: highest_weapon_allowed
          int32_t lw6map_rules_s::highest_weapon_allowed


 -- member of lw6map_rules_s: x_polarity
          int32_t lw6map_rules_s::x_polarity


 -- member of lw6map_rules_s: y_polarity
          int32_t lw6map_rules_s::y_polarity


 -- member of lw6map_rules_s: z_polarity
          int32_t lw6map_rules_s::z_polarity


 -- member of lw6map_rules_s: max_zone_size
          int32_t lw6map_rules_s::max_zone_size


 -- member of lw6map_rules_s: round_delta
          int32_t lw6map_rules_s::round_delta


 -- member of lw6map_rules_s: max_round_delta
          int32_t lw6map_rules_s::max_round_delta


 -- member of lw6map_rules_s: max_cursor_pot
          int32_t lw6map_rules_s::max_cursor_pot


 -- member of lw6map_rules_s: cursor_pot_init
          int32_t lw6map_rules_s::cursor_pot_init


 -- member of lw6map_rules_s: max_cursor_pot_offset
          int32_t lw6map_rules_s::max_cursor_pot_offset


 -- member of lw6map_rules_s: start_x
          int32_t lw6map_rules_s::start_x[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: start_y
          int32_t lw6map_rules_s::start_y[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: start_position_mode
          int32_t lw6map_rules_s::start_position_mode


 -- member of lw6map_rules_s: color_conflict_mode
          int32_t lw6map_rules_s::color_conflict_mode


 -- member of lw6map_rules_s: spread_thread
          int32_t lw6map_rules_s::spread_thread


 -- member of lw6map_rules_s: glue_power
          int32_t lw6map_rules_s::glue_power


 -- member of lw6map_rules_s: boost_power
          int32_t lw6map_rules_s::boost_power


 -- member of lw6map_rules_s: danger_power
          int32_t lw6map_rules_s::danger_power


 -- member of lw6map_rules_s: medicine_power
          int32_t lw6map_rules_s::medicine_power


 -- member of lw6map_rules_s: frags_mode
          int32_t lw6map_rules_s::frags_mode


 -- member of lw6map_rules_s: frags_to_distribute
          int32_t lw6map_rules_s::frags_to_distribute


 -- member of lw6map_rules_s: frags_fade_out
          int32_t lw6map_rules_s::frags_fade_out


 -- member of lw6map_rules_s: use_team_profiles
          int32_t lw6map_rules_s::use_team_profiles


 -- member of lw6map_rules_s: team_profile_aggressive
          int32_t lw6map_rules_s::team_profile_aggressive[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_vulnerable
          int32_t lw6map_rules_s::team_profile_vulnerable[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_mobile
          int32_t lw6map_rules_s::team_profile_mobile[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_fast
          int32_t lw6map_rules_s::team_profile_fast[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_weapon_id
          int32_t lw6map_rules_s::team_profile_weapon_id[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_weapon_alternate_id
          int32_t lw6map_rules_s::team_profile_weapon_alternate_id[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: team_profile_weapon_mode
          int32_t lw6map_rules_s::team_profile_weapon_mode[LW6MAP_MAX_NB_TEAMS]


 -- member of lw6map_rules_s: weapon_duration
          int32_t lw6map_rules_s::weapon_duration


 -- member of lw6map_rules_s: weapon_charge_delay
          int32_t lw6map_rules_s::weapon_charge_delay


 -- member of lw6map_rules_s: weapon_charge_max
          int32_t lw6map_rules_s::weapon_charge_max


 -- member of lw6map_rules_s: weapon_tune_berzerk_power
          int32_t lw6map_rules_s::weapon_tune_berzerk_power


 -- member of lw6map_rules_s: weapon_tune_turbo_power
          int32_t lw6map_rules_s::weapon_tune_turbo_power


 -- struct: lw6map_style_s

 -- member of lw6map_style_s: keep_ratio
          int lw6map_style_s::keep_ratio


 -- member of lw6map_style_s: zoom
          float lw6map_style_s::zoom


 -- member of lw6map_style_s: zoom_min
          float lw6map_style_s::zoom_min


 -- member of lw6map_style_s: zoom_max
          float lw6map_style_s::zoom_max


 -- member of lw6map_style_s: x_wrap
          int lw6map_style_s::x_wrap


 -- member of lw6map_style_s: y_wrap
          int lw6map_style_s::y_wrap


 -- member of lw6map_style_s: background_style
          char* lw6map_style_s::background_style


 -- member of lw6map_style_s: hud_style
          char* lw6map_style_s::hud_style


 -- member of lw6map_style_s: menu_style
          char* lw6map_style_s::menu_style


 -- member of lw6map_style_s: view_style
          char* lw6map_style_s::view_style


 -- member of lw6map_style_s: animation_density
          float lw6map_style_s::animation_density


 -- member of lw6map_style_s: animation_speed
          float lw6map_style_s::animation_speed


 -- member of lw6map_style_s: cursor_size
          float lw6map_style_s::cursor_size


 -- member of lw6map_style_s: colorize_cursor
          int lw6map_style_s::colorize_cursor


 -- member of lw6map_style_s: blink_cursor
          int lw6map_style_s::blink_cursor


 -- member of lw6map_style_s: hidden_layer_alpha
          float lw6map_style_s::hidden_layer_alpha


 -- member of lw6map_style_s: colorize
          int lw6map_style_s::colorize


 -- member of lw6map_style_s: pixelize
          int lw6map_style_s::pixelize


 -- member of lw6map_style_s: color_set
          lw6map_color_set_t lw6map_style_s::color_set


 -- member of lw6map_style_s: music_file
          char* lw6map_style_s::music_file


 -- member of lw6map_style_s: music_filter
          char* lw6map_style_s::music_filter


 -- member of lw6map_style_s: music_exclude
          char* lw6map_style_s::music_exclude


 -- member of lw6map_style_s: waves
          int lw6map_style_s::waves


 -- struct: lw6map_teams_s

 -- member of lw6map_teams_s: player_color
          int lw6map_teams_s::player_color[LW6MAP_TEAMS_NB_PLAYERS]


 -- member of lw6map_teams_s: nb_bots
          int lw6map_teams_s::nb_bots


 -- member of lw6map_teams_s: bot_speed
          float lw6map_teams_s::bot_speed


 -- member of lw6map_teams_s: bot_iq
          int lw6map_teams_s::bot_iq


 -- member of lw6map_teams_s: bot
          lw6map_bot_info_t lw6map_teams_s::bot[LW6MAP_TEAMS_MAX_NB_BOTS]


 -- struct: lw6map_texture_s

 -- member of lw6map_texture_s: w
          int lw6map_texture_s::w


 -- member of lw6map_texture_s: h
          int lw6map_texture_s::h


 -- member of lw6map_texture_s: has_alpha
          int lw6map_texture_s::has_alpha


 -- member of lw6map_texture_s: data
          lw6sys_color_8_t* lw6map_texture_s::data


 -- member of lw6map_texture_s: guessed_color_base
          lw6map_color_couple_t lw6map_texture_s::guessed_color_base


 -- member of lw6map_texture_s: guessed_color_alternate
          lw6map_color_couple_t lw6map_texture_s::guessed_color_alternate



File: liquidwar6.info,  Node: libmsg,  Next: libnet,  Prev: libmap,  Up: C API

5.27 libmsg
===========

5.27.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/msg/index.html'.

5.27.2 API
----------

 -- Function: char * lw6msg_cmd_generate_hello (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a HELLO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_ticket (lw6nod_info_t * INFO,
          u_int64_t TICKET)
     INFO:  the node info to use

     TICKET:  the ticket to send

     Generate a TICKET command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_foo (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a FOO command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_bar (lw6nod_info_t * INFO,
          u_int32_t KEY)
     INFO:  the node info to use

     KEY:  the key to identify the message

     Generate a BAR command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_goodbye (lw6nod_info_t * INFO)
     INFO:  the node info to use

     Generate a GOODBYE command.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_cmd_generate_data (int SERIAL, int I, int
          N, int ROUND, char * KER_MSG)
     SERIAL:  the message serial number

     I:  the message index in the group

     N:  the number of messages in the group

     ROUND:  the message round (can have an offset with real round)

     KER_MSG:  the actual content of the message (passed to core algo)

     Generate a DATA command. Serial is an ever increasing number, i
     and n are most of the time 1 and 1, they are usefull only in long
     multipart messages.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_cmd_analyse_hello (lw6nod_info_t ** INFO, char
          * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a HELLO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_ticket (lw6nod_info_t ** INFO,
          u_int64_t * TICKET, char * MSG)
     INFO:  will contain (remote) node info on success

     TICKET:  if not NULL, will contain the ticket value on success

     MSG:  the message to analyse

     Analyzes a TICKET message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_foo (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a FOO message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_bar (lw6nod_info_t ** INFO,
          u_int32_t * KEY, char * MSG)
     INFO:  will contain (remote) node info on success

     KEY:  if not NULL, will contain the foo/bar key on success

     MSG:  the message to analyse

     Analyzes a BAR message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_goodbye (lw6nod_info_t ** INFO,
          char * MSG)
     INFO:  will contain (remote) node info on success

     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6msg_cmd_analyse_data (int * SERIAL, int * I, int *
          N, int * ROUND, char ** KER_MSG, char * MSG)
     SERIAL:  will contain serial number on success

     I:  will contain group index on success

     N:  will contain group size on success

     ROUND:  will contain round on success (can have an offset with
     real round)

     KER_MSG:  will contain actual message on success

     Analyzes a DATA message.

     *Return value:*  1 on success, 0 on failure

 -- Function: char * lw6msg_cmd_guess_from_url (char * MSG)
     MSG:  the message to analyse

     Analyzes a GOODBYE message.

     *Return value:*  the from url, if found (dynamically allocated)

 -- Function: char * lw6msg_envelope_generate (lw6msg_envelope_mode_t
          MODE, char * VERSION, char * PASSWORD_CHECKSUM, u_int32_t
          PHYSICAL_TICKET_SIG, u_int32_t LOGICAL_TICKET_SIG, u_int64_t
          PHYSICAL_FROM_ID, u_int64_t PHYSICAL_TO_ID, u_int64_t
          LOGICAL_FROM_ID, u_int64_t LOGICAL_TO_ID, char * MSG)
     MODE:  mode to use (a la TELNET or URL compatible)

     VERSION:  the program version to use (note: can be changed when
     testing)

     PASSWORD_CHECKSUM:  the password string to send

     PHYSICAL_TICKET_SIG:  the signature of the message, calculated
     with ticket + physical from/to

     LOGICAL_TICKET_SIG:  the signature of the message, calculated with
     ticket + logical from/to

     PHYSICAL_FROM_ID:  the sender id

     PHYSICAL_TO_ID:  the receiver id

     LOGICAL_FROM_ID:  the message creator id

     LOGICAL_TO_ID:  the message final destination id

     MSG:  the body of the message

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: int lw6msg_envelope_analyse (char * ENVELOPE,
          lw6msg_envelope_mode_t MODE, char * LOCAL_URL, char *
          PASSWORD, u_int64_t EXPECTED_PHYSICAL_FROM_ID, u_int64_t
          EXPECTED_PHYSICAL_TO_ID, char ** MSG, u_int32_t *
          PHYSICAL_TICKET_SIG, u_int32_t * LOGICAL_TICKET_SIG,
          u_int64_t * PHYSICAL_FROM_ID, u_int64_t * PHYSICAL_TO_ID,
          u_int64_t * LOGICAL_FROM_ID, u_int64_t * LOGICAL_TO_ID, char
          ** PHYSICAL_FROM_URL)
     ENVELOPE:  the envelope to analyse

     MODE:  mode to use (a la TELNET or URL compatible)

     LOCAL_URL:  the url of local server (usefull for password)

     PASSWORD:  the password to check against

     EXPECTED_PHYSICAL_FROM_ID:  the sender id, if NULL, no check
     performed

     EXPECTED_PHYSICAL_TO_ID:  the receiver id, if NULL, no check
     performed

     MSG:  if not NULL, will contain body of the message

     PHYSICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     LOGICAL_TICKET_SIG:  if not NULL, will contain signature of
     message, calculated with ticket

     PHYSICAL_FROM_ID:  if not NULL, will contain sender id

     PHYSICAL_TO_ID:  if not NULL, will contain receiver id

     LOGICAL_FROM_ID:  if not NULL, will contain message creator id

     LOGICAL_TO_ID:  if not NULL, will contain message final
     destination id

     PHYSICAL_FROM_URL:  if not NULL and if message allows, will
     contain sender public URL

     Generate an envelope, that is, the complete message sendable on the
     network.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_info (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the INFO question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_list (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the LIST question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed. There's a max length because we don't want the udp
     buffer to be saturated + too long lists do not really mean
     anything anyway.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_pong (lw6nod_info_t * INFO)
     INFO:  the node to generate info about

     Generates a standard response to the PING question for OOB (out of
     band) messages. The same message is sent, be it on http or tcp or
     udp, so it's factorized here. Function will lock the info object
     when needed.

     *Return value:*  newly allocated string.

 -- Function: char * lw6msg_oob_generate_request (char * COMMAND, char
          * REMOTE_URL, char * PASSWORD, char * LOCAL_URL)
     COMMAND:  the command to send (PING, INFO, LIST)

     REMOTE_URL:  the remote URL (used to seed password)

     PASSWORD:  the password, can be NULL or ""

     LOCAL_URL:  the public URL to send along with the message, can be
     NULL or ""

     Generates a simple clear text OOB request, with a password if
     needed.

     *Return value:*  a newly allocated string

 -- Function: int lw6msg_oob_analyse_request (int * SYNTAX_OK, char **
          COMMAND, int * PASSWORD_OK, char ** REMOTE_URL, char *
          REQUEST, char * LOCAL_URL, char * PASSWORD)
     SYNTAX_OK:  will contain 1 if syntax is OK, 0 if not

     COMMAND:  the command (out param, needs *not* to be freed)

     PASSWORD_OK:  will contain 1 if password is OK, 0 if not

     REMOTE_URL:  the URL detected, if provided (out param, does needs
     to be freed)

     REQUEST:  the request to analyse

     LOCAL_URL:  the local url (used to seed password)

     PASSWORD:  the password to check against

     Analyses a simple OOB message of the form COMMAND <passwd> <url>.

     *Return value:*  1 if OK, 0 if not. If 0, check the value of
     password_ok.

 -- Function: char * lw6msg_oob_analyse_pong (char * TEXT)
     TEXT:  the text of the message to parse

     Analyses a PONG message and gets the public_url from it, if it
     exists.

     *Return value:*  newly allocated string containing public_url if
     OK, NULL on error.

 -- Function: int lw6msg_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: u_int32_t lw6msg_ticket_calc_sig (u_int64_t TICKET,
          u_int64_t FROM_ID, u_int64_t TO_ID, char * MSG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     Produces a little signature, which is clearly vulnerable to
     brute-force attacks but makes it possible to be 100% sure if it's
     wrong, someone is trying to do something nasty (or there's a
     serious bug!).

     *Return value:*  the sig, always non-zero

 -- Function: int lw6msg_ticket_check_sig (u_int64_t TICKET, u_int64_t
          FROM_ID, u_int64_t TO_ID, char * MSG, u_int32_t TICKET_SIG)
     TICKET:  the (private) ticket to use

     FROM_ID:  the sender/creator

     TO_ID:  the receiver/target

     MSG:  the message to sign

     TICKET_SIG:  the signature to check against

     Checks a sig is OK.

     *Return value:*  1 if they are the same, 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_ptr (char ** KEY,
          char ** VALUE, char * LINE)
     KEY:  will contain the key detected

     VALUE:  will contain the value detected

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and returns the key and the
     value in the passed pointers.

     *Return value:*  1 if line OK (and in this case `key' and `value'
     are set), 0 if not.

 -- Function: int lw6msg_utils_parse_key_value_to_assoc (lw6sys_assoc_t
          ** ASSOC, char * LINE)
     ASSOC:  an assoc object which will contain the result

     LINE:  the line to analyse

     Analyses a trivial "KEY value" line and sets the `assoc' parameter
     according to detected values. Note that `assoc' must be set to
     contain string, and free them automatically with
     `lw6sys_free_callback' for instance.

     *Return value:*  1 if line OK (and in this case `assoc' is
     updated), 0 if not.

 -- Function: char * lw6msg_utils_get_assoc_str_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, char * DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_utils_get_assoc_int_with_default
          (lw6sys_assoc_t * ASSOC, char * KEY, int DEFAULT_VALUE)
     ASSOC:  the string assoc to query

     KEY:  the key to find in the assoc

     DEFAULT_VALUE:  the default value to return

     Queries a string assoc for a given value, and if not available,
     returns default value. Not that default value (nor the assoc
     value) is copied, so you must take care all remain valid until
     usage of returned value is over. This one will returned an int
     converted with `lw6sys_atoi'.

     *Return value:*  a string, must not be freed.

 -- Function: int lw6msg_word_first (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_x (lw6msg_word_t * WORD, char **
          NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     This special `x' function will consider slash ("/") as valid
     separator. It can't be used all the time but for almost every
     field but URLs, it's fine. Internally, this one is used to parse
     integers, IDs, etc.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_base64 (lw6msg_word_t * WORD, char
          ** NEXT, char * MSG)
     WORD:  will contain the parsed word

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message and gets the first word. This word is put in
     `buf' member with its length. `next' is usefull if you want to
     parse the rest of the message, it points at the beginning of it.
     The word is expected to be base64 encoded and is decoded
     on-the-fly.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int (int * PARSED_VALUE, char **
          NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_ge0 (int * PARSED_VALUE, char
          ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_int_gt0 (int * PARSED_VALUE, char
          ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an int.
     The value must be strictly greater than 0.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_16 (u_int16_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     16-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_32 (u_int32_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     32-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6msg_word_first_id_64 (u_int64_t * PARSED_VALUE,
          char ** NEXT, char * MSG)
     PARSED_VALUE:  will contain the parsed value

     NEXT:  if NOT NULL, will contain a (non freeable) pointer on
     remaining message

     MSG:  the message to parse

     Analyses a message, gets the first word and interpret it as an
     64-bit id.

     *Return value:*  1 on success, 0 on failure.

 -- Function: char * lw6msg_z_encode (char * MSG, int LIMIT)
     MSG:  message to encode

     LIMIT:  if under this limit (length in bytes), do not encode,
     return as is

     Z-encode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     There's an optional limit *not* to encode anything, just when we
     know there are no special characters to escape and string is
     small, it's useless to fire this big artillery.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.

 -- Function: char * lw6msg_z_decode (char * MSG)
     MSG:  message to decode

     Z-decode a message, by "Z-encoding" we mean pass the string through
     1) zlib then 2) base64 encoding, this way we get a string without
     any blank and/or special character, and of reasonnable length.
     This decode string does it the reverse way, un64-encode the string
     then uncompress it back to a readable string.

     *Return value:*  newly allocated string, 0 terminated, NULL on
     error.

 -- struct: lw6msg_word_s

 -- member of lw6msg_word_s: len
          int lw6msg_word_s::len


 -- member of lw6msg_word_s: buf
          char lw6msg_word_s::buf[LW6MSG_MAX_WORD_SIZE+1]



File: liquidwar6.info,  Node: libnet,  Next: libnod,  Prev: libmsg,  Up: C API

5.28 libnet
===========

5.28.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/net/index.html'.

5.28.2 API
----------

 -- Function: int lw6net_dns_is_ip (char * IP)
     IP:  the string to check

     Tests if a given string is a valid IP (IPV4). Test is only
     syntaxic, it's just to know if we're likely to need to query the
     DNS, it does not mean the IP is *really* valid.

     *Return value:*  1 if it's an IP, O if not.

 -- Function: char * lw6net_dns_gethostbyname (char * NAME)
     NAME:  name of the host

     A wrapper over the standard gethostbyname function, will even
     accept an IP as an input (in this case, will copy it...) and
     allocate a new string for the result.

     *Return value:*  an IP if success, NULL on error.

 -- Function: int lw6net_dns_lock ()
     Locks access to dns function `lw6net_dns_gethostbyname'.  This is
     because `gethostbyname' isn't reentrant plus, even if we didn't
     use it but its multithreadable equivalent (which is however not
     standard and always available) other libs (such as `libcurl' not
     to name it) might use this function too so in a general manner
     it's a good idea to use a mutex to protect multiple accesses to
     this.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_dns_unlock ()
     Unlocks access to dns function `lw6net_dns_gethostbyname'.

     *Return value:*  an IP if success, 0 on error.

 -- Function: int lw6net_last_error ()
     Reports the last network error. This is basically a debug function,
     designed mostly for Microsoft Winsock API, but can be safely called
     on any platform.

     *Return value:*  the last error code, has no universal meaning,
     depends on the platform you're working on.

 -- Function: char * lw6net_if_guess_local ()
     Guess the local IP address. This is not fool-proof, and it
     probably cannot be as we can't handle all user-specific configs
     involving multiple IP addresses, virtual private networks, and so
     on. But this is just to provide a default public IP address when
     starting a network game, saavy users can always specify the right
     interface/address if needed. Will return NULL if interface can't
     be guessed.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_if_guess_public_url (char * BIND_IP, int
          BIND_PORT)
     BIND_IP:  the IP address used to bind on

     BIND_PORT:  the IP port used to bind on

     Guess the server public url, based on `lw6net_if_guess_local'
     which tries to find a valid local IP address which is not
     loopback. This is only in case `bind_ip' is 0.0.0.0 (listen on all
     addresses) else it will just use `bind_ip' as you would expect.
     Function isn't foolproof, that's why one can override its default
     with a user settings.

     *Return value:*  the IP as a string, dynamically allocated

 -- Function: char * lw6net_recv_line_tcp (int SOCK)
     SOCK:  the socket descriptor

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a TCP socket, that is, stream oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: int lw6net_send_line_tcp (int SOCK, char * LINE)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     Sends a line terminated by LF ("\n", chr(10)) on a TCP socket,
     that is, stream oriented. The "\n" is automatically added, do not
     bother sending it.

     *Return value:*  non-zero if success

 -- Function: char * lw6net_recv_line_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives a line terminated by LF ("\n", chr(10)) or CR/LF ("\r\n",
     chr(10)chr(13)) on a UDP socket, that is, datagram oriented. If
     there's no complete line available, function returns immediately
     with NULL. Same if socket is closed, broken, whatever. Only if
     there's something consistent will the function return non-NULL.
     By-value parameters allow the caller to know where the data come
     from.

     *Return value:*  a dynamically allocated string with the content
     received. The tailing (CR)/LF is stripped.

 -- Function: lw6sys_list_t * lw6net_recv_lines_udp (int SOCK, char **
          INCOMING_IP, int * INCOMING_PORT)
     SOCK:  the socket descriptor

     INCOMING_IP:  the IP address of the sender (returned)

     INCOMING_PORT:  the IP port of the sender (returned)

     Receives several lines terminated by LF ("\n", chr(10)) or CR/LF
     ("\r\n", chr(10)chr(13)) on a UDP socket, that is, datagram
     oriented. If there's no complete line available, function returns
     immediately with NULL. Same if socket is closed, broken, whatever.
     Only if there's something consistent will the function return
     non-NULL.  By-value parameters allow the caller to know where the
     data come from. This variant of `lw6net_recv_line_tcp' will return
     a list of lines, this is mandatory since in UDP we can't call recv
     several times.

     *Return value:*  a list of dynamically allocated strings.  The
     tailing (CR)/LF is stripped from strings.

 -- Function: int lw6net_send_line_udp (int SOCK, char * LINE, char *
          IP, int PORT)
     SOCK:  the socket descriptor

     LINE:  the line to be sent, without the "\n" at the end

     IP:  the IP address of the target

     PORT:  the IP port of the target

     Sends a line terminated by LF ("\n", chr(10)) on a UDP socket,
     that is, datagram oriented. The "\n" is automatically added, do
     not bother sending it.

     *Return value:*  the number of bytes sent, 0 if failure

 -- Function: int lw6net_init (int ARGC, const char * [] ARGV, int
          NET_LOG)
     ARGC:  argc as passed to `main'

     ARGV:  argv as passed to `main'

     NET_LOG:  1 if you want to enable net log, 0 if not

     Initializes the low-level network API, you must call this before
     calling any other network related function, for it allocates a
     dynamic context which is in turn used by every function.

     *Return value:*  non-zero if success

 -- Function: void lw6net_quit ()
     Frees memory, joins active threads, and releases everything set up
     by network code.

     *Return value:*  void

 -- Function: int lw6net_socket_set_blocking_mode (int SOCK, int MODE)
     SOCK:  the socket to modify

     MODE:  the mode to use (1 -> blocking mode, 0 -> non-blocking)

     Sets the blocking mode of a socket, the reason we use this is that
     `ioctl' isn't portable (`ioctlsocket' on MS-Windows).

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6net_socket_is_valid (int SOCK)
     SOCK:  the socket to test

     Tells if a socket is valid or not. This does not mean the socket
     is opened/connected and/or the peer is reachable, it just checks
     the socket is a valid descriptor. In practice it's just to avoid
     copy/pasting if (sock>=0)" everywhere.

     *Return value:*  1 if valid, 0 if not

 -- Function: void lw6net_socket_close (int SOCK)
     SOCK:  the socket to close

     Closes a socket, that is, stop activity and free its descriptor.

     *Return value:*  none.

 -- Function: int lw6net_tcp_listen (char * IP, int PORT)
     IP:  IP address to bind to

     PORT:  IP port to listen on

     Listens in TCP on a given port.

     *Return value:*  >=0 on success, -1 on failure.

 -- Function: int lw6net_tcp_accept (char ** INCOMING_IP, int *
          INCOMING_PORT, int LISTENING_SOCK, int DELAY_MSEC)
     INCOMING_IP:  address of remote peer (out param, dynamically
     allocated)

     INCOMING_PORT:  port of remote peer (out param)

     LISTENING_SOCK:  socket to listen on

     DELAY_MSEC:  delay, in msec, after which we stop accepting

     Accepts for a connexion on the given socket.

     *Return value:*  the new socket (>=0) if accepted, else -1

 -- Function: int lw6net_tcp_connect (char * IP, int PORT, int
          DELAY_MSEC)
     IP:  address to connect to

     PORT:  port to connect to

     DELAY_MSEC:  delay before we consider it's too late

     Tries to connect on a given socket.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_tcp_send (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC, int LOOP)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  delay after which we give up

     LOOP:  accept to do several calls if needed

     Will send data, possibly looping until all is send, and waiting for
     a maximum time of delay_msec.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6net_tcp_peek (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  maximum time to wait

     Tells wether data is available. Will actually fill the buffer with
     the data, but not remove it from the fifo list.

     *Return value:*  number of bytes available, 0 when nothing

 -- Function: int lw6net_tcp_recv (int SOCK, char * BUF, int LEN, int
          DELAY_MSEC, int LOOP)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     DELAY_MSEC:  maximum time to wait

     LOOP:  wether to loop or not

     If data is available, put it in buffer. If needed, will loop until
     `delay_msec' is elapsed. Data is removed from queue.

     *Return value:*  number of bytes received, 0 when nothing

 -- Function: int lw6net_tcp_is_alive (int SOCK)
     SOCK:  socket to test

     Tells wether a socket is alive and able to send data. This function
     will attempt a write to test if it's really usable.

     *Return value:*  1 if alive, 0 if not.

 -- Function: int lw6net_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `net' module test suite. This one could fail if some
     sockets are already bound, for instance. It's still run even in
     check-only (mode=0) mode.

     *Return value:*  1 if test is successfull, 0 on error.

 -- Function: int lw6net_udp_client ()
     Creates an UDP client socket, that is, creates it and does not
     bind it to any address.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_udp_server (char * IP, int PORT)
     IP:  IP address to bind to

     PORT:  IP port to listen on

     Creates an UDP listening socket, that is, creates it and binds it
     on a given address.

     *Return value:*  socket (>=0) on success, else -1

 -- Function: int lw6net_udp_send (int SOCK, char * BUF, int LEN, char
          * IP, int PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     IP:  IP address to send data to

     PORT:  IP port to send data to

     Sends an UDP datagram. Size can't be longer than about 1400 bytes,
     see problems about MTU, in practice all values arround 1000 are
     quite safe, 500 is pretty much garanteed to work everywhere, and
     for various reasons 1452 is a good maximum bet.

     *Return value:*  number of bytes sent

 -- Function: int lw6net_udp_peek (int SOCK, char * BUF, int LEN, char
          ** INCOMING_IP, int * INCOMING_PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     Peeks for a UDP datagram. Will not remove the data from queue.

     *Return value:*  number of bytes received

 -- Function: int lw6net_udp_recv (int SOCK, char * BUF, int LEN, char
          ** INCOMING_IP, int * INCOMING_PORT)
     SOCK:  socket to use

     BUF:  data buffer

     LEN:  data buffer length

     Receives a UDP datagram. Will remove the data from queue.

     *Return value:*  number of bytes received


File: liquidwar6.info,  Node: libnod,  Next: libp2p,  Prev: libnet,  Up: C API

5.29 libnod
===========

5.29.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/nod/index.html'.

5.29.2 API
----------

 -- Function: void lw6nod_dyn_info_free (lw6nod_dyn_info_t * DYN_INFO)
     DYN_INFO:  the dyn info struct to free

     Frees a dyn info object, to be used after a call to
     `lw6nod_info_dup_dyn' for instance.

     *Return value:*  none

 -- Function: lw6nod_info_t * lw6nod_info_new (char * PROGRAM, char *
          VERSION, char * CODENAME, int STAMP, u_int64_t ID, char *
          URL, char * TITLE, char * DESCRIPTION, char * PASSWORD, int
          BENCH, int OPEN_RELAY, int UPTIME, int IDLE_SCREENSHOT_SIZE,
          void * IDLE_SCREENSHOT_DATA)
     PROGRAM:  the program (normally it's liquidwar6)

     VERSION:  the version

     CODENAME:  the codename

     STAMP:  the stamp

     ID:  the node id

     URL:  the node public url

     TITLE:  the node title

     DESCRIPTION:  the node description

     PASSWORD:  the node password

     BENCH:  the node bench

     OPEN_RELAY:  open relay or not

     UPTIME:  uptime in seconds

     IDLE_SCREENSHOT_SIZE:  the size (bytes) of the image to display
     when game is idle

     IDLE_SCREENSHOT_DATA:  the data (jpeg) of the image to display
     when game is idle

     Creates a node info object. The arguments correspond to the
     immutable node attributes, other properties such as how many
     players are connected or set in other functions like
     `lw6nod_info_update' which can be called later.

     *Return value:*  newly allocated object, NULL on error.

 -- Function: void lw6nod_info_free (lw6nod_info_t * INFO)
     INFO:  the node info to free

     Frees a node info object.

     *Return value:*  none

 -- Function: int lw6nod_info_lock (lw6nod_info_t * INFO)
     INFO:  the node info to lock

     Locks a node info object, this is usefull for some members,
     typically list of servers, can be accessed by separated threads,
     one reading, many writing, and these objects (chained lists)
     certainly do not want to be modified while being read.

     *Return value:*  1 if ok, 0 if not.

 -- Function: int lw6nod_info_unlock (lw6nod_info_t * INFO)
     INFO:  the node info to unlock

     Unlocks a node info object, this is the compation of the
     `lw6nod_info_lock' function.

     *Return value:*  1 if ok, 0 if not.

 -- Function: void lw6nod_info_idle (lw6nod_info_t * INFO)
     INFO:  the node info to modify

     Clears a node info object and sets all its variable attributes to
     NULL/default values. This is what we want when the node is idle,
     not playing.

     *Return value:*  none.

 -- Function: int lw6nod_info_update (lw6nod_info_t * INFO, u_int64_t
          COMMUNITY_ID, int ROUND, char * LEVEL, int REQUIRED_BENCH,
          int NB_COLORS, int MAX_NB_COLORS, int NB_CURSORS, int
          MAX_NB_CURSORS, int NB_NODES, int MAX_NB_NODES, int
          GAME_SCREENSHOT_SIZE, void * GAME_SCREENSHOT_DATA)
     INFO:  the node info to update

     COMMUNITY_ID:  the id of the community the node belongs to

     ROUND:  the current round (can have an offset with real round
     number)

     LEVEL:  the name of the current level (map)

     REQUIRED_BENCH:  the bench required to connect

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  max number of colors allowed

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  max number of cursors allowed

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  max number of nodes allowed

     GAME_SCREENSHOT_SIZE:  size of screenshot (bytes)

     GAME_SCREENSHOT_DATA:  screenshot data (byte buffer, contains JPEG)

     Set a node info object variable attributes. Call this whenever the
     node has changed some parameter. Not too often for it's not needed
     and some operations such as modying the screenshot, can be time
     consuming.

     *Return value:*  1 if OK, 0 if error.

 -- Function: lw6nod_dyn_info_t * lw6nod_info_dup_dyn (lw6nod_info_t *
          INFO)
     INFO:  the node info containing the dyn info to duplicate

     Extracts the dynamic part of an info struct and duplicates it,
     this is to avoid protection fault error when concurrent threads
     access this info.

     *Return value:*  newly allocated object, must be freed.

 -- Function: lw6sys_hash_t * lw6nod_info_new_discovered_nodes ()
     Creates a new hash, to be used as a discovered nodes list.  Using
     this function has the advantage of setting the hash options to
     their defaults.  We use a hash to avoid having uselessly long
     lists containing always the same node due to multiple detections.

     *Return value:*  an empty hash

 -- Function: int lw6nod_info_add_discovered_node (lw6nod_info_t *
          INFO, char * PUBLIC_URL)
     INFO:  the node info to update

     PUBLIC_URL:  the address of the discovered node

     Registers a new server, and queues it as something that should be
     checked later because it's interesting. We can't insert in the
     database all the servers we suspect to exist so network threads
     should use this, then main thread will process discovered servers
     afterwards. This is also a good way to avoid trivial DOS attacks.

     *Return value:*  1 if OK, O if error.

 -- Function: lw6sys_list_t * lw6nod_info_pop_discovered_nodes
          (lw6nod_info_t * INFO)
     INFO:  the node info to query

     Returns a list of all discovered nodes (their public URL) and
     empties the current queue as well.

     *Return value:*  a list of dynamically allocated strings.

 -- Function: lw6sys_list_t * lw6nod_info_new_verified_nodes ()
     Creates a new list, to be filled with nodes and typically passed
     to `lw6nod_info_set_verified_nodes'. Using this function has the
     advantage of setting the listh options to their defaults.

     *Return value:*  an empty list

 -- Function: int lw6nod_info_set_verified_nodes (lw6nod_info_t * INFO,
          lw6sys_list_t * LIST)
     INFO:  the node info to modify

     LIST:  the list of verified nodes, will be freed by this function

     Sets the list of verified nodes, that is, the list of nodes we are
     sure to exist, this is typically the list we will display later on
     a web page. We can't directly display any discovered node, one
     needs to filter them through main thread.  Something very
     important about this function is that `list' will be freed by
     function, that is, if you call this, then you can (you should)
     forget your object, it will disappear any time soon.

     *Return value:*  1 if OK, 0 on error.

 -- Function: void lw6nod_info_map_verified_nodes (lw6nod_info_t *
          INFO, lw6sys_list_callback_func_t FUNC, void * FUNC_DATA)
     INFO:  the node info concerned

     FUNC:  the function to apply

     FUNC_DATA:  arbitrary pointer holding data to pass to function

     Calls `lw6sys_hash_map' with `func' on every member of the list of
     verified nodes. The reason there's a function for this is that it
     is very important that list object is locked when doing this.
     This function does perform a lock/unlock so it is safe.

     *Return value:*  none.

 -- Function: int lw6nod_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `nod' module test suite.

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6nod_const_info_s

 -- member of lw6nod_const_info_s: program
          char* lw6nod_const_info_s::program


 -- member of lw6nod_const_info_s: version
          char* lw6nod_const_info_s::version


 -- member of lw6nod_const_info_s: codename
          char* lw6nod_const_info_s::codename


 -- member of lw6nod_const_info_s: stamp
          int lw6nod_const_info_s::stamp


 -- member of lw6nod_const_info_s: id_int
          u_int64_t lw6nod_const_info_s::id_int


 -- member of lw6nod_const_info_s: id_str
          char* lw6nod_const_info_s::id_str


 -- member of lw6nod_const_info_s: url
          char* lw6nod_const_info_s::url


 -- member of lw6nod_const_info_s: title
          char* lw6nod_const_info_s::title


 -- member of lw6nod_const_info_s: description
          char* lw6nod_const_info_s::description


 -- member of lw6nod_const_info_s: has_password
          int lw6nod_const_info_s::has_password


 -- member of lw6nod_const_info_s: password
          char* lw6nod_const_info_s::password


 -- member of lw6nod_const_info_s: bench
          int lw6nod_const_info_s::bench


 -- member of lw6nod_const_info_s: open_relay
          int lw6nod_const_info_s::open_relay


 -- member of lw6nod_const_info_s: creation_timestamp
          int64_t lw6nod_const_info_s::creation_timestamp


 -- member of lw6nod_const_info_s: idle_screenshot_size
          int lw6nod_const_info_s::idle_screenshot_size


 -- member of lw6nod_const_info_s: idle_screenshot_data
          void* lw6nod_const_info_s::idle_screenshot_data


 -- struct: lw6nod_dyn_info_s

 -- member of lw6nod_dyn_info_s: community_id_int
          u_int64_t lw6nod_dyn_info_s::community_id_int


 -- member of lw6nod_dyn_info_s: community_id_str
          char* lw6nod_dyn_info_s::community_id_str


 -- member of lw6nod_dyn_info_s: round
          int lw6nod_dyn_info_s::round


 -- member of lw6nod_dyn_info_s: level
          char* lw6nod_dyn_info_s::level


 -- member of lw6nod_dyn_info_s: required_bench
          int lw6nod_dyn_info_s::required_bench


 -- member of lw6nod_dyn_info_s: nb_colors
          int lw6nod_dyn_info_s::nb_colors


 -- member of lw6nod_dyn_info_s: max_nb_colors
          int lw6nod_dyn_info_s::max_nb_colors


 -- member of lw6nod_dyn_info_s: nb_cursors
          int lw6nod_dyn_info_s::nb_cursors


 -- member of lw6nod_dyn_info_s: max_nb_cursors
          int lw6nod_dyn_info_s::max_nb_cursors


 -- member of lw6nod_dyn_info_s: nb_nodes
          int lw6nod_dyn_info_s::nb_nodes


 -- member of lw6nod_dyn_info_s: max_nb_nodes
          int lw6nod_dyn_info_s::max_nb_nodes


 -- member of lw6nod_dyn_info_s: game_screenshot_size
          int lw6nod_dyn_info_s::game_screenshot_size


 -- member of lw6nod_dyn_info_s: game_screenshot_data
          void* lw6nod_dyn_info_s::game_screenshot_data


 -- struct: lw6nod_info_s

 -- member of lw6nod_info_s: mutex
          void* lw6nod_info_s::mutex


 -- member of lw6nod_info_s: const_info
          lw6nod_const_info_t lw6nod_info_s::const_info


 -- member of lw6nod_info_s: dyn_info
          lw6nod_dyn_info_t lw6nod_info_s::dyn_info


 -- member of lw6nod_info_s: discovered_nodes
          lw6sys_hash_t* lw6nod_info_s::discovered_nodes


 -- member of lw6nod_info_s: verified_nodes
          lw6sys_list_t* lw6nod_info_s::verified_nodes



File: liquidwar6.info,  Node: libp2p,  Next: libpil,  Prev: libnod,  Up: C API

5.30 libp2p
===========

5.30.1 Overview
---------------

View lcov (http://ltp.sourceforge.net/coverage/lcov.php) test coverage
results on
`http://www.gnu.org/software/liquidwar6/coverage/src/lib/p2p/index.html'.

5.30.2 API
----------

 -- Function: lw6p2p_db_t * lw6p2p_db_open (int ARGC, const char * []
          ARGV, char * NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Creates a new database object. Normally there's only one object
     like this at a given time, it can be shared among various nodes.
     The database name is appended to user directory path, this allows
     different databases to be created, in theory.

     *Return value:*  a pointer on the newly created object.

 -- Function: void lw6p2p_db_close (lw6p2p_db_t * DB)
     DB:  the db to close

     Closes a db object, memory ressources will be freed.

     *Return value:*  none.

 -- Function: char * lw6p2p_db_repr (lw6p2p_db_t * DB)
     DB:  the db to work on

     Gives a readable representation of the db

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_db_reset (int ARGC, const char * [] ARGV, char
          * NAME)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     NAME:  the database name

     Clears the database. Simply removes the db file, in fact. Do not
     call while database is used...

     *Return value:*  1 on success, 0 if failed.

 -- Function: char * lw6p2p_db_default_name ()
     Returns the default database name, should be p2p.db (this is a
     relative path, not an absolute path, will be appended to user dir).

     *Return value:*  the default database name, need not (must not) be
     freed.

 -- Function: int _lw6p2p_db_now (_lw6p2p_db_t * DB)
     DB:  the db object concerned (used to calculate time origin)

     Returns a timestamp suitable for db usage. The reason we don't use
     regular timestamps is that they are 1) too accurate (msec is
     useless for what's involved here) and 2) too big and likely to be
     negative in signed mode even if converted to seconds.

     *Return value:*  a timestamp, 0 means "beginning of program"
     (think of it as uptime)

 -- Function: lw6p2p_entry_t * lw6p2p_entry_new (int
          CREATION_TIMESTAMP, char * VERSION, char * CODENAME, int
          STAMP, char * ID, char * URL, char * TITLE, char *
          DESCRIPTION, int HAS_PASSWORD, int BENCH, int OPEN_RELAY,
          char * COMMUNITY_ID, int ROUND, char * LEVEL, int
          REQUIRED_BENCH, int NB_COLORS, int MAX_NB_COLORS, int
          NB_CURSORS, int MAX_NB_CURSORS, int NB_NODES, int
          MAX_NB_NODES, char * IP, int PORT, int LAST_PING_TIMESTAMP,
          int PING_DELAY_MSEC, int AVAILABLE)
     CREATION_TIMESTAMP:  when it has been created, UNIX timestamp

     VERSION:  version of the node

     CODENAME:  codename of the node

     STAMP:  stamp of the node

     ID:  id of the node (string representation)

     URL:  public url of the node

     TITLE:  title of the node

     DESCRIPTION:  description of the node

     HAS_PASSWORD:  wether node is password protected or not

     BENCH:  node bench

     OPEN_RELAY:  wether the node is in open relay mode or not

     ROUND:  current round

     LEVEL:  current level played

     REQUIRED_BENCH:  current bench

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  maximum number of colors

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  maximum number of cursors

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  maximum number of nodes

     IP:  node ip (string representation)

     PORT:  node port

     LAST_PING_TIMESTAMP:  UNIX timestamp of last contact with node

     PING_DELAY_MSEC:  ping delay, in milliseconds

     AVAILABLE:  wether node is available, wether we can connect to it

     Creates a new p2p entry. Will accept NULL parameters for strings
     as well as arbitrary long strings, will simply cut them short if
     there aren't already limited to max size.

     *Return value:*  newly allocated object

 -- Function: void lw6p2p_entry_free (lw6p2p_entry_t * ENTRY)
     ENTRY:  entry to free

     Frees a p2p entry.

     *Return value:*  none.

 -- Function: char * lw6p2p_entry_repr (lw6p2p_entry_t * ENTRY)
     ENTRY:  entry to represent

     Gives a human-readable representation of the entry

     *Return value:*  dynamically allocated string

 -- Function: lw6p2p_node_t * lw6p2p_node_new (int ARGC, const char *
          [] ARGV, lw6p2p_db_t * DB, char * CLIENT_BACKENDS, char *
          SERVER_BACKENDS, char * BIND_IP, int BIND_PORT, int
          BROADCAST, char * PUBLIC_URL, char * TITLE, char *
          DESCRIPTION, char * PASSWORD, int BENCH, int OPEN_RELAY, char
          * KNOWN_NODES, int NETWORK_RELIABILITY, int TROJAN)
     ARGC:  number of args, as passed to `main'

     ARGV:  args array, as passed to `main'

     DB:  the database to use

     CLIENT_BACKENDS:  the list of client backends to use

     SERVER_BACKENDS:  the list of server backends to use

     BIND_IP:  the IP address to bind on

     BIND_PORT:  the IP port to listen on

     BROADCAST:  wether broadcast is allowed on this node

     PUBLIC_URL:  the public URL we want to show

     TITLE:  the title of the node

     DESCRIPTION:  the description of the node

     PASSWORD:  the password to use

     BENCH:  the bench of the node (its power)

     OPEN_RELAY:  act as an open relay or not

     KNOWN_NODES:  list of already known nodes

     NETWORK_RELIABILITY:  drop 1 packet out of X

     TROJAN:  act as a stupid trojan to test out automatic kick-off

     Creates a new "pear to pear" node. This will fire the server and
     allow client access, on demand. A lot of stuff can be done in the
     background once this is called.

     *Return value:*  a pointer on the newly created objects.

 -- Function: void lw6p2p_node_free (lw6p2p_node_t * NODE)
     NODE:  the node to free

     Frees a node object, all network communications will be shut.

     *Return value:*  none.

 -- Function: char * lw6p2p_node_repr (lw6p2p_node_t * NODE)
     NODE:  the node to work on

     Gives a readable representation of the node

     *Return value:*  a dynamically allocated string

 -- Function: int lw6p2p_node_poll (lw6p2p_node_t * NODE)
     NODE:  the node to poll

     Polls a p2p node. This must be called on a regular basis, else
     network communication is stalled.

     *Return value:*  1 on success, 0 on error.

 -- Function: void lw6p2p_node_close (lw6p2p_node_t * NODE)
     NODE:  the node to close

     Closes a p2p node. Closing is necessary in some contexts, for
     instance scheme/smob instanciation when you want to release the
     object ressources (sockets, ports, threads...) *before* it is
     deleted by, for instance, a garbage collector.

     *Return value:*  1 on success, 0 on error.

 -- Function: u_int64_t lw6p2p_node_get_id (lw6p2p_node_t * NODE)
     NODE:  the node to query

     Returns the node id, an id which is supposed to uniquely identify
     the node at run-time.

     *Return value:*  numerical id.

 -- Function: lw6sys_list_t * lw6p2p_node_get_entries (lw6p2p_node_t *
          NODE)
     NODE:  node to query

     Returns a list of all known nodes, this is a plain table dump,
     sorted so that the most likely to be interesting to connect
     oneself to are listed *last*, this is just a (little)
     optimization, since we know we'll need to parse this list to
     construct a Guile object, we reverse the order.

     *Return value:*  list object containing `lw6p2p_entry_t' objects

 -- Function: int lw6p2p_node_server_start (lw6p2p_node_t * NODE)
     NODE:  node to start

     Starts a node in server mode, if node was previously connected to
     other nodes, disconnect it from any peer.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6p2p_node_client_join (lw6p2p_node_t * NODE, char *
          REMOTE_URL)
     NODE:  node to use

     REMOTE_URL:  url of remote node to join

     Starts a node in client mode, joins the given node, if node was
     previously connected to other nodes, disconnect it from any peer.

     *Return value:*  1 on success, 0 on failure.

 -- Function: void lw6p2p_node_disconnect (lw6p2p_node_t * NODE)
     NODE:  node to disconnect

     Disconnects a node, if node was previously connected to other
     nodes, disconnect it from any peer. Note that this does not affect
     out-of-band connections, only real game-related links.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6p2p_node_update_info (lw6p2p_node_t * NODE, int
          ROUND, char * LEVEL, int REQUIRED_BENCH, int NB_COLORS, int
          MAX_NB_COLORS, int NB_CURSORS, int MAX_NB_CURSORS, int
          NB_NODES, int MAX_NB_NODES, int GAME_SCREENSHOT_SIZE, void *
          GAME_SCREENSHOT_DATA)
     NODE:  node to update

     ROUND:  the current round (can have an offset with real round
     number)

     LEVEL:  the name of the current level (map)

     REQUIRED_BENCH:  the bench required to connect

     NB_COLORS:  number of colors playing

     MAX_NB_COLORS:  max number of colors allowed

     NB_CURSORS:  number of cursors playing

     MAX_NB_CURSORS:  max number of cursors allowed

     NB_NODES:  number of nodes playing

     MAX_NB_NODES:  max number of nodes allowed

     GAME_SCREENSHOT_SIZE:  size of screenshot (bytes)

     GAME_SCREENSHOT_DATA:  screenshot data (byte buffer, contains JPEG)

     Updates node info, that is, all the data/metadata which can be
     displayed to other peers and are, by nature, dynamic.

     *Return value:*  1 on success, 0 on failure.

 -- Function: int lw6p2p_node_update_serialized (lw6p2p_node_t * NODE,
          u_int64_t SEQ_ID, char * SERIALIZED_LEVEL, char *
          SERIALIZED_GAME_STRUCT, char * SERIALIZED_GAME_STATE)
     NODE:  node to update

     SERIALIZED_LEVEL:  level object serialized serialized as an hexa
     string

     SERIALIZED_GAME_STRUCT:  game struct object serialized as an hexa
     string

     SERIALIZED_GAME_STATE:  game state object serialized as an hexa
     string

     Updates the (rather heavy) serialized objects for the game, which
     are required to transmit game context to peers over the network.

     *Return value:*  1 on success, 0 on failure

 -- Function: int lw6p2p_test (int MODE)
     MODE:  0 for check only, 1 for full test

     Runs the `p2p' module test suite. This test can fail if one cannot
     bind on some network port, in a general manner it is dependent on
     the network environment, so it's better if there's some sort of
     human control on it.

     *Return value:*  1 if test is successfull, 0 on error.

 -- struct: lw6p2p_db_s

 -- member of lw6p2p_db_s: id
          u_int32_t lw6p2p_db_s::id


 -- struct: lw6p2p_entry_s

 -- member of lw6p2p_entry_s: creation_timestamp
          int lw6p2p_entry_s::creation_timestamp


 -- member of lw6p2p_entry_s: version
          char lw6p2p_entry_s::version[LW6P2P_VERSION_SIZE+1]


 -- member of lw6p2p_entry_s: codename
          char lw6p2p_entry_s::codename[LW6P2P_CODENAME_SIZE+1]


 -- member of lw6p2p_entry_s: stamp
          int lw6p2p_entry_s::stamp


 -- member of lw6p2p_entry_s: id
          char lw6p2p_entry_s::id[LW6P2P_ID_SIZE+1]


 -- member of lw6p2p_entry_s: url
          char lw6p2p_entry_s::url[LW6P2P_URL_SIZE+1]


 -- member of lw6p2p_entry_s: title
          char lw6p2p_entry_s::title[LW6P2P_TITLE_SIZE+1]


 -- member of lw6p2p_entry_s: description
          char lw6p2p_entry_s::description[LW6P2P_DESCRIPTION_SIZE+1]


 -- member of lw6p2p_entry_s: has_password
          int lw6p2p_entry_s::has_password


 -- member of lw6p2p_entry_s: bench
          int lw6p2p_entry_s::bench


 -- member of lw6p2p_entry_s: open_relay
          int lw6p2p_entry_s::open_relay


 -- member of lw6p2p_entry_s: community_id
          char lw6p2p_entry_s::community_id[LW6P2P_COMMUNITY_ID_SIZE+1]


 -- member of lw6p2p_entry_s: round
          int lw6p2p_entry_s::round


 -- member of lw6p2p_entry_s: level
          char lw6p2p_entry_s::level[LW6P2P_LEVEL_SIZE+1]


 -- member of lw6p2p_entry_s: required_bench
          int lw6p2p_entry_s::required_bench


 -- member of lw6p2p_entry_s: nb_colors
          int lw6p2p_entry_s::nb_colors


 -- member of lw6p2p_entry_s: max_nb_colors
          int lw6p2p_entry_s::max_nb_colors


 -- member of lw6p2p_entry_s: nb_cursors
          int lw6p2p_entry_s::nb_cursors


 -- member of lw6p2p_entry_s: max_nb_cursors
          int lw6p2p_entry_s::max_nb_cursors


 -- member of lw6p2p_entry_s: nb_nodes
          int lw6p2p_entry_s::nb_nodes


 -- member of lw6p2p_entry_s: max_nb_nodes
          int lw6p2p_entry_s::max_nb_nodes


 -- member of lw6p2p_entry_s: ip
          char lw6p2p_entry_s::ip[LW6P2P_IP_SIZE+1]


 -- member of lw6p2p_entry_s: port
          int lw6p2p_entry_s::port


 -- member of lw6p2p_entry_s: last_ping_timestamp
          int lw6p2p_entry_s::last_ping_timestamp


 -- member of lw6p2p_entry_s: ping_delay_msec
          int lw6p2p_entry_s::ping_delay_msec


 -- member of lw6p2p_entry_s: available
          int lw6p2p_entry_s::available


 -- struct: lw6p2p_node_s

 -- member of lw6p2p_node_s: id
          u_int32_t lw6p2p_node_s::id


