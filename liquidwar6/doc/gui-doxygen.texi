

  
@deftp {Struct} {lw6gui_button_s}

    
Used to store a complete button state, along with repeat informations, queues. It might be overkill for basic cases, having different types of buttons (union?) for different cases might be a good idea.     
@end deftp

@defcv {Member} {lw6gui_button_s} {is_pressed}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_button_s::is_pressed}


Wether button is pressed, 1 means pressed, 0 unpressed.         
        
@end defcv

@defcv {Member} {lw6gui_button_s} {press_queue}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_button_s::press_queue}


        
Each time the button is pressed, this increases, each times one "pops" a press from it, it's decreased. This allows for button buffering, as events might take some time to go through the pipeline given the heavily multithreaded nature of the dsp/gfx couple.         
@end defcv

@defcv {Member} {lw6gui_button_s} {simple_click_queue}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_button_s::simple_click_queue}


        
Simple-click counter, as opposed to double-click. A "simple-click" is validated when one has pressed the button, and then waiting long enough to discard the possibility to double-click. This is not really buffered, queue will ignore simple-clicks if one is already buffered.         
@end defcv

@defcv {Member} {lw6gui_button_s} {double_click_queue}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_button_s::double_click_queue}


        
Double-click counter. This is not really buffered, queue will ignore double-clicks if one is already buffered.         
@end defcv

@defcv {Member} {lw6gui_button_s} {triple_click_queue}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_button_s::triple_click_queue}


        
Triple-click counter. This is not really buffered, queue will ignore triple-clicks if one is already buffered.         
@end defcv

@defcv {Member} {lw6gui_button_s} {last_press}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_button_s::last_press}


Timestamp of last key press.         
        
@end defcv

@defcv {Member} {lw6gui_button_s} {last_repeat}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_button_s::last_repeat}


Timestamp of last key repeat.         
        
@end defcv

@defcv {Member} {lw6gui_button_s} {double_click_t1}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_button_s::double_click_t1}


        
Used to handle multiple-clicks, this is the timestamp of the click "2 clicks ago".         
@end defcv

@defcv {Member} {lw6gui_button_s} {double_click_t2}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_button_s::double_click_t2}


        
Used to handle multiple-clicks, this is the timestamp of the click just before the last click.         
@end defcv

@defcv {Member} {lw6gui_button_s} {double_click_t3}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_button_s::double_click_t3}


        
Used to handle multiple-clicks, this is the timestamp of the last click.         
@end defcv



  
@deftp {Struct} {lw6gui_fullscreen_modes_s}

    
Contains information about available fullscreen modes.     
@end deftp

@defcv {Member} {lw6gui_fullscreen_modes_s} {low}
@strong{Type:} @code{lw6gui_video_mode_t}

@strong{Definition:} @code{lw6gui_video_mode_t lw6gui_fullscreen_modes_s::low}


Low resolution mode.         
        
@end defcv

@defcv {Member} {lw6gui_fullscreen_modes_s} {standard}
@strong{Type:} @code{lw6gui_video_mode_t}

@strong{Definition:} @code{lw6gui_video_mode_t lw6gui_fullscreen_modes_s::standard}


Standard resolution mode.         
        
@end defcv

@defcv {Member} {lw6gui_fullscreen_modes_s} {high}
@strong{Type:} @code{lw6gui_video_mode_t}

@strong{Definition:} @code{lw6gui_video_mode_t lw6gui_fullscreen_modes_s::high}


High resolution mode.         
        
@end defcv



  
@deftp {Struct} {lw6gui_input_s}

    
Global input state, contains informations about the keyboard, mouse and joystick. This is the macro object used to exchange data and transmit input information from the rendering thread which gathers it to the logical thread which computes the game state.     
@end deftp

@defcv {Member} {lw6gui_input_s} {need_sync}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_input_s::need_sync}


Wether this input struct has changed and needs to be synchronized.         
        
@end defcv

@defcv {Member} {lw6gui_input_s} {keyboard}
@strong{Type:} @code{lw6gui_keyboard_t}

@strong{Definition:} @code{lw6gui_keyboard_t lw6gui_input_s::keyboard}


Keyboard information.         
        
@end defcv

@defcv {Member} {lw6gui_input_s} {mouse}
@strong{Type:} @code{lw6gui_mouse_t}

@strong{Definition:} @code{lw6gui_mouse_t lw6gui_input_s::mouse}


Mouse information.         
        
@end defcv

@defcv {Member} {lw6gui_input_s} {joysticks}
@strong{Type:} @code{lw6gui_joystick_t}

@strong{Definition:} @code{lw6gui_joystick_t lw6gui_input_s::joysticks[LW6GUI_NB_JOYSTICKS]}


Joysticks information.         
        
@end defcv



  
@deftp {Struct} {lw6gui_joystick_s}

    
Joystick information, contains detailed joystick state. This structure uses a pad-like interface, there's no knowledge of analog interfaces, it transforms everything to a binary "up or down" and "left or right". This interface only knows about 6 buttons, this is done on purpose, the logic behind it is that more than 6 buttons makes the control way too complicated. Actually, most common functions are and should be available through the 4 first (a,b,c,d) buttons. The e and f are here for additionnal not-so-important features.     
@end deftp

@defcv {Member} {lw6gui_joystick_s} {pad_up}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::pad_up}


Joystick up button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {pad_down}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::pad_down}


Joystick down button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {pad_left}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::pad_left}


Joystick left button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {pad_right}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::pad_right}


Joystick right button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_a}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_a}


Joystick a button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_b}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_b}


Joystick b button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_c}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_c}


Joystick c button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_d}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_d}


Joystick d button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_e}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_e}


Joystick e button state.         
        
@end defcv

@defcv {Member} {lw6gui_joystick_s} {button_f}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_joystick_s::button_f}


Joystick f button state.         
        
@end defcv



  
@deftp {Struct} {lw6gui_keyboard_s}

    
Stores a complete keyboard state.     
@end deftp

@defcv {Member} {lw6gui_keyboard_s} {auto_release_enabled}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_keyboard_s::auto_release_enabled}


Wether auto_release mode is set.         
        
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {arrow_up}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::arrow_up}


        
State of keyboard up arrow. This can be the combination of several keys, for instance the numeric pad up arrow, and the corresponding arrow pad key.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {arrow_down}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::arrow_down}


        
State of keyboard down arrow. This can be the combination of several keys, for instance the numeric pad down arrow, and the corresponding arrow pad key.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {arrow_left}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::arrow_left}


        
State of keyboard left arrow. This can be the combination of several keys, for instance the numeric pad left arrow, and the corresponding arrow pad key.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {arrow_right}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::arrow_right}


        
State of keyboard right arrow. This can be the combination of several keys, for instance the numeric pad right arrow, and the corresponding arrow pad key.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_enter}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_enter}


        
State of keyboard ENTER key. This can be the combination of several keys, for instance both the numeric pad ENTER and the standard, default one.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_esc}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_esc}


        
State of keyboard ESC key. This can be the combination of several keys, for instance both the standard ESC key and another key.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_ctrl}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_ctrl}


        
State of keyboard ESC key. This can be the combination of several keys, for instance both left and right CTRL keys.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_alt}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_alt}


        
State of keyboard ESC key. This can be the combination of several keys, for instance both left and right ALT keys.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_pgup}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_pgup}


        
State of keyboard PAGE UP key. This can be the combination of several keys.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {key_pgdown}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::key_pgdown}


        
State of keyboard PAGE UP key. This can be the combination of several keys.         
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {queue}
@strong{Type:} @code{lw6sys_list_t *}

@strong{Definition:} @code{lw6sys_list_t* lw6gui_keyboard_s::queue}


List of events, contains keypress objects.         
        
@end defcv

@defcv {Member} {lw6gui_keyboard_s} {keys_state}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_keyboard_s::keys_state[LW6GUI_NB_KEYS]}


Array of button states, indexed by keycodes.         
        
@end defcv



  
@deftp {Struct} {lw6gui_keypress_s}

    
Keypress information, contains more than just a keycode but also meta/readable informations about it.     
@end deftp

@defcv {Member} {lw6gui_keypress_s} {keysym}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_keypress_s::keysym}


        
The keysym, note that this is implementation specific. In practice, SDL uniformizes this, but there's no garantee all graphics engine are SDL based, so don't rely on this too much outside the graphics backend.         
@end defcv

@defcv {Member} {lw6gui_keypress_s} {unicode}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_keypress_s::unicode}


Unicode code for this letter/key.         
        
@end defcv

@defcv {Member} {lw6gui_keypress_s} {label}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_keypress_s::label}


        
Readable label for the key, typically usable in a "choose keyboard settings" interface.         
@end defcv



  
@deftp {Struct} {lw6gui_look_s}

    
The look structure contains everything the renderer needs to skin the display. This is where one specifies the color set, dynamic zoom effect, and possibly other things.     
@end deftp

@defcv {Member} {lw6gui_look_s} {id}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6gui_look_s::id}


        
The id of the object, this is non-zero and unique within one run session, incremented at each object creation.         
@end defcv

@defcv {Member} {lw6gui_look_s} {dynamic_zoom}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_look_s::dynamic_zoom}


        
Dynamic zoom, this is multiplicated by the map zoom, and gives the global zoom, the one finally used.         
@end defcv

@defcv {Member} {lw6gui_look_s} {gfx_quality}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_look_s::gfx_quality}


        
Overall graphics quality, the higher the better, will trigger various parameters, depending on the renderer.         
@end defcv

@defcv {Member} {lw6gui_look_s} {style}
@strong{Type:} @code{lw6map_style_t}

@strong{Definition:} @code{lw6map_style_t lw6gui_look_s::style}


        
A style structure which will override the one from the map, depending on the local options (config file, environnement, command-line options).         
@end defcv



  
@deftp {Struct} {lw6gui_menuitem_s}

    
Menu item object. Basically, a menu is an array of these items, it's up to the gfx backend to render this as accurately as possible. The most important field is probably the label.     
@end deftp

@defcv {Member} {lw6gui_menuitem_s} {id}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6gui_menuitem_s::id}


        
The id of the object, this is non-zero and unique within one run session, incremented at each object creation.         
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {label}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_menuitem_s::label}


What is displayed in the menu item.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {tooltip}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_menuitem_s::tooltip}


An additionnal tooltip explaining what the item is about.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {value}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::value}


        
The value for this item, can typically be used for booleans and integer values, in addition to the information conveyed by the label. One special case is colored items, in that case the value will be used as a color index.         
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {enabled}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::enabled}


Wether the item is valid and can be used.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {selected}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::selected}


Wether the item is the current selection.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {colored}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::colored}


        
Wether to colorize the item, and in that case, use the value field to know which color to use.         
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {last_change}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::last_change}


Timestamp of last time the menu item was updated and changed.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {last_select}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::last_select}


Timestamp of last time the menu was selected.         
        
@end defcv

@defcv {Member} {lw6gui_menuitem_s} {last_unselect}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menuitem_s::last_unselect}


Timestamp of last time the menu was unselected.         
        
@end defcv



  
@deftp {Struct} {lw6gui_menu_s}

    
Menu item object. Basically, a menu is an array of menu items, it's up to the gfx backend to render this as accurately as possible. The most important field is probably the items labels. The menu object also stores state information such as what was the first item displayed lately.     
@end deftp

@defcv {Member} {lw6gui_menu_s} {id}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6gui_menu_s::id}


        
The id of the object, this is non-zero and unique within one run session, incremented at each object creation.         
@end defcv

@defcv {Member} {lw6gui_menu_s} {title}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_menu_s::title}


Title of the menu, used for breadcrumbs.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {help}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_menu_s::help}


Additionnal help text, explaining what the menu is about.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {popup}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6gui_menu_s::popup}


        
Popup text, will be displayed when the menu is first displayed, and then disappear.         
@end defcv

@defcv {Member} {lw6gui_menu_s} {nb_items}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::nb_items}


Number of items.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {esc_item}
@strong{Type:} @code{lw6gui_menuitem_t *}

@strong{Definition:} @code{lw6gui_menuitem_t* lw6gui_menu_s::esc_item}


Special item describing the ESC button.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {items}
@strong{Type:} @code{lw6gui_menuitem_t **}

@strong{Definition:} @code{lw6gui_menuitem_t** lw6gui_menu_s::items}


Array of items, containing all the menu items.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {selected_item}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::selected_item}


The current selection.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {first_item_displayed}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::first_item_displayed}


        
The first item displayed, this is mandatory if we want the menus to be displayable in different states, for instance with first item being 2 and items displayed from 2 to 10 or with first item being 5 and items displayed from 2 to 10. In the first case the 1st item is selected, in the second case it's the 4th.         
@end defcv

@defcv {Member} {lw6gui_menu_s} {nb_items_displayed}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::nb_items_displayed}


Number of items displayed.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {order_of_selected_on_display}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::order_of_selected_on_display}


        
Index, display-based (that is, 0 here means first displayed and not necessarly first in the items array), of the selected item.         
@end defcv

@defcv {Member} {lw6gui_menu_s} {allow_scroll}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_menu_s::allow_scroll}


Wether scrolling is allowed.         
        
@end defcv

@defcv {Member} {lw6gui_menu_s} {breadcrumbs}
@strong{Type:} @code{lw6sys_list_t *}

@strong{Definition:} @code{lw6sys_list_t* lw6gui_menu_s::breadcrumbs}


        
List of strings containing the breadcrumbs, that is to say all the menu titles that one must use to get here.         
@end defcv



  
@deftp {Struct} {lw6gui_mouse_pointer_s}

    
Use to store mouse pointer information.     
@end deftp

@defcv {Member} {lw6gui_mouse_pointer_s} {pos_x}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_pointer_s::pos_x}


Mouse X position (pixels).         
        
@end defcv

@defcv {Member} {lw6gui_mouse_pointer_s} {pos_y}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_pointer_s::pos_y}


Mouse Y position (pixels).         
        
@end defcv

@defcv {Member} {lw6gui_mouse_pointer_s} {speed_x}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_pointer_s::speed_x}


        
Mouse X speed. The unit is pixels per second. This is based on the last move, for instance if between two moves 100 msec have elapsed, and mouse moved 13 pixels, then speed is 130.         
@end defcv

@defcv {Member} {lw6gui_mouse_pointer_s} {speed_y}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_pointer_s::speed_y}


        
Mouse Y speed. The unit is pixels per second. This is based on the last move, for instance if between two moves 100 msec have elapsed, and mouse moved 13 pixels, then speed is 130.         
@end defcv



  
@deftp {Struct} {lw6gui_mouse_s}

    
Mouse information, contains detailed mouse state, including mouse position and button states but also keeps track of mouse speed as well as its corresponding map coordinates. That is, given the current screen position, what does it mean on the logical map/battlefield.     
@end deftp

@defcv {Member} {lw6gui_mouse_s} {moved}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_s::moved}


Wether mouse was moved lately. 1 means yes, 0 no.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {last_moved}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_mouse_s::last_moved}


Timestamp of last move.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {screen_pointer}
@strong{Type:} @code{lw6gui_mouse_pointer_t}

@strong{Definition:} @code{lw6gui_mouse_pointer_t lw6gui_mouse_s::screen_pointer}


        
Information about the mouse pointer, using screen coordinates, the unit being pixels.         
@end defcv

@defcv {Member} {lw6gui_mouse_s} {map_pointer}
@strong{Type:} @code{lw6gui_mouse_pointer_t}

@strong{Definition:} @code{lw6gui_mouse_pointer_t lw6gui_mouse_s::map_pointer}


        
Information about the mouse pointer, using map coordinates, the unit being the map slot. This is possibly very different from screen coordinates, they can be inverted, have a different scale, and globally it's just something else, even if it refers to the same physical move.         
@end defcv

@defcv {Member} {lw6gui_mouse_s} {screen_drag_start}
@strong{Type:} @code{lw6gui_mouse_pointer_t}

@strong{Definition:} @code{lw6gui_mouse_pointer_t lw6gui_mouse_s::screen_drag_start}


        
Information about the mouse pointer when drag mode was entered. The unit is screen pixels.         
@end defcv

@defcv {Member} {lw6gui_mouse_s} {drag_mode}
@strong{Type:} @code{lw6gui_drag_mode_t}

@strong{Definition:} @code{lw6gui_drag_mode_t lw6gui_mouse_s::drag_mode}


The current drag state.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {menu_position}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_s::menu_position}


        
The index of the menu item the mouse is on. This is the only was to know when to select an item, one should not use mouse coords outside the gfx renderer code for this purpose, it's the renderer which has knowledge about where menu items are.         
@end defcv

@defcv {Member} {lw6gui_mouse_s} {menu_scroll}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_s::menu_scroll}


        
Set to -1 if one needs to scroll up (decrease menu index) to +1 if one needs to scroll down (increase menu index) and 0 if one needs to do nothing as far as scrolling is concerned.         
@end defcv

@defcv {Member} {lw6gui_mouse_s} {menu_esc}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_mouse_s::menu_esc}


Wether mouse pointer is over the ESC button.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {button_left}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_mouse_s::button_left}


Mouse left button state.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {button_right}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_mouse_s::button_right}


Mouse right button state.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {button_middle}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_mouse_s::button_middle}


Mouse middle button state.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {wheel_up}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_mouse_s::wheel_up}


Mouse wheel up state.         
        
@end defcv

@defcv {Member} {lw6gui_mouse_s} {wheel_down}
@strong{Type:} @code{lw6gui_button_t}

@strong{Definition:} @code{lw6gui_button_t lw6gui_mouse_s::wheel_down}


Mouse wheel down state.         
        
@end defcv



  
@deftp {Struct} {lw6gui_move_pad_s}

    
Standard interface for joypad-like interfaces, can also be used to map keyboard arrows.     
@end deftp

@defcv {Member} {lw6gui_move_pad_s} {up}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_move_pad_s::up}


Up button (boolean).         
        
@end defcv

@defcv {Member} {lw6gui_move_pad_s} {down}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_move_pad_s::down}


Down button (boolean).         
        
@end defcv

@defcv {Member} {lw6gui_move_pad_s} {left}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_move_pad_s::left}


Left button (boolean).         
        
@end defcv

@defcv {Member} {lw6gui_move_pad_s} {right}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_move_pad_s::right}


Right button (boolean).         
        
@end defcv



  
@deftp {Struct} {lw6gui_point_s}

    
Basic point type, 3 floating point coords.     
@end deftp

@defcv {Member} {lw6gui_point_s} {x}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_point_s::x}


X position.         
        
@end defcv

@defcv {Member} {lw6gui_point_s} {y}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_point_s::y}


Y position.         
        
@end defcv

@defcv {Member} {lw6gui_point_s} {z}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_point_s::z}


Z position.         
        
@end defcv



  
@deftp {Struct} {lw6gui_quad_s}

    
Basic quad type, composed of 4 points (floating point values).     
@end deftp

@defcv {Member} {lw6gui_quad_s} {p1}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_quad_s::p1}


1st point.         
        
@end defcv

@defcv {Member} {lw6gui_quad_s} {p2}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_quad_s::p2}


2nd point.         
        
@end defcv

@defcv {Member} {lw6gui_quad_s} {p3}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_quad_s::p3}


3rd point.         
        
@end defcv

@defcv {Member} {lw6gui_quad_s} {p4}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_quad_s::p4}


4th point.         
        
@end defcv



  
@deftp {Struct} {lw6gui_rect_array_s}

    
Array of rectangles. This is typically used to make tiles that overlap. It's mostly used to display fighters/maps using multiple textures when the whole stuff does not fit in one single OpenGL texture and needs to be splitted. Technically, when one needs to split textures, performance is poor, but still better than relying on software renderer only.     
@end deftp

@defcv {Member} {lw6gui_rect_array_s} {source}
@strong{Type:} @code{lw6sys_whd_t}

@strong{Definition:} @code{lw6sys_whd_t lw6gui_rect_array_s::source}


Size of original source data.         
        
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {limits}
@strong{Type:} @code{lw6gui_rect_t}

@strong{Definition:} @code{lw6gui_rect_t lw6gui_rect_array_s::limits}


        
Boundary limits of the rect array, this is typically bigger that source size, it starts at negative values and finishes outside the source. It's interesting to cover that big an area to enable both the water effect and proper wrapping/clamping.         
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {tile_size}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::tile_size}


        
Width and height of the tiles, this is typically a power of two, as it's designed to match an OpenGL low-level texture object.         
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {border_size}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::border_size}


        
The border size one needs to cut from the tile_size (on both sides, up and down or left and right) to get the real usable size of the tile.         
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {tile_spacing}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::tile_spacing}


        
The tile spacing, difference of X or Y between two tiles, this is typically smaller that tile_size.         
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {nb_tiles_w}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::nb_tiles_w}


Number of tiles on the X axis (width).         
        
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {nb_tiles_h}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::nb_tiles_h}


Number of tiles on the Y axis (height).         
        
@end defcv

@defcv {Member} {lw6gui_rect_array_s} {nb_tiles}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_array_s::nb_tiles}


Overall number of tiles.         
        
@end defcv



  
@deftp {Struct} {lw6gui_rect_s}

    
A basic rectangle data. The idea is to store both corner positions and width and height to cache the values and avoid always recalculating them. Values are integer based, for a floating point equivalent, see the zone struct.     
@end deftp

@defcv {Member} {lw6gui_rect_s} {x1}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::x1}


Top-left corner X position.         
        
@end defcv

@defcv {Member} {lw6gui_rect_s} {y1}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::y1}


Top-left corner Y position.         
        
@end defcv

@defcv {Member} {lw6gui_rect_s} {x2}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::x2}


Bottom-right corner X position.         
        
@end defcv

@defcv {Member} {lw6gui_rect_s} {y2}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::y2}


Bottom-right corner Y position.         
        
@end defcv

@defcv {Member} {lw6gui_rect_s} {w}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::w}


Width.         
        
@end defcv

@defcv {Member} {lw6gui_rect_s} {h}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_rect_s::h}


Height.         
        
@end defcv



  
@deftp {Struct} {lw6gui_repeat_settings_s}

    
Parameters used to handle repeat. This is used both by keys and buttons (joystick buttons and mouse buttons).     
@end deftp

@defcv {Member} {lw6gui_repeat_settings_s} {delay}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_repeat_settings_s::delay}


        
Delay, in milliseconds, after which a given key/button enters repeat mode.         
@end defcv

@defcv {Member} {lw6gui_repeat_settings_s} {interval}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_repeat_settings_s::interval}


        
Interval, in milliseconds, between two key/button press events in repeat mode.         
@end defcv

@defcv {Member} {lw6gui_repeat_settings_s} {double_click_delay}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_repeat_settings_s::double_click_delay}


        
If pressed twice within this delay (in milliseconds) then a double-click event is generated.         
@end defcv

@defcv {Member} {lw6gui_repeat_settings_s} {auto_release_delay}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_repeat_settings_s::auto_release_delay}


        
After this delay (milliseconds) any key will be considered be unpressed, that is, it will be released automatically. This is usefull when the input library (depends on the gfx backend) does not send proper "key up" events. The workarround is to automatically consider the key is released after some time. Usually, this would typically be set just below the repeat delay.         
@end defcv



  
@deftp {Struct} {lw6gui_segment_s}

    
Basic segment type, composed of 2 points (floating point values).     
@end deftp

@defcv {Member} {lw6gui_segment_s} {p1}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_segment_s::p1}


1st point.         
        
@end defcv

@defcv {Member} {lw6gui_segment_s} {p2}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_segment_s::p2}


2nd point.         
        
@end defcv



  
@deftp {Struct} {lw6gui_smoother_s}

    
Statefull object used to make transitions between 2 floats. Basically, one needs to choose a target, which is y2, and give a start, which is defined by s1 and y1 (speed and y value). Then with t1 (start timestamp) and duration the object has functions which enables interpolation between those two values, knowing at the end the value will be y2 and the speed 0. To some extent, this is a primitive bezier-like tool.     
@end deftp

@defcv {Member} {lw6gui_smoother_s} {s1}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_smoother_s::s1}


Speed at startup.         
        
@end defcv

@defcv {Member} {lw6gui_smoother_s} {y1}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_smoother_s::y1}


Y value at startup.         
        
@end defcv

@defcv {Member} {lw6gui_smoother_s} {y2}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_smoother_s::y2}


Y target value.         
        
@end defcv

@defcv {Member} {lw6gui_smoother_s} {t1}
@strong{Type:} @code{int64_t}

@strong{Definition:} @code{int64_t lw6gui_smoother_s::t1}


Timestamp at startup.         
        
@end defcv

@defcv {Member} {lw6gui_smoother_s} {duration}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_smoother_s::duration}


Duration (in milliseconds) of the transition.         
        
@end defcv



  
@deftp {Struct} {lw6gui_triangle_s}

    
Basic triangle type, composed of 3 points (floating point values).     
@end deftp

@defcv {Member} {lw6gui_triangle_s} {p1}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_triangle_s::p1}


1st point.         
        
@end defcv

@defcv {Member} {lw6gui_triangle_s} {p2}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_triangle_s::p2}


2nd point.         
        
@end defcv

@defcv {Member} {lw6gui_triangle_s} {p3}
@strong{Type:} @code{lw6gui_point_t}

@strong{Definition:} @code{lw6gui_point_t lw6gui_triangle_s::p3}


3rd point.         
        
@end defcv



  
@deftp {Struct} {lw6gui_video_mode_s}

    
Contains the parameters for a video mode, regardless of driver used.     
@end deftp

@defcv {Member} {lw6gui_video_mode_s} {width}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_video_mode_s::width}


Width, in pixels.         
        
@end defcv

@defcv {Member} {lw6gui_video_mode_s} {height}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_video_mode_s::height}


Height, in pixels.         
        
@end defcv

@defcv {Member} {lw6gui_video_mode_s} {fullscreen}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_video_mode_s::fullscreen}


1 for fullscreen mode, 0 for windowed mode.         
        
@end defcv



  
@deftp {Struct} {lw6gui_viewport_s}

    
Macro object used to store viewport information. Viewport here means "what part of the map should we display, on which part of the screen, and with which parameters".     
@end deftp

@defcv {Member} {lw6gui_viewport_s} {map_shape}
@strong{Type:} @code{lw6sys_whd_t}

@strong{Definition:} @code{lw6sys_whd_t lw6gui_viewport_s::map_shape}


Shape of the map to display, unit is map slot.         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {screen_shape}
@strong{Type:} @code{lw6sys_whd_t}

@strong{Definition:} @code{lw6sys_whd_t lw6gui_viewport_s::screen_shape}


Shape of the screen, unit is pixels.         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {center_x}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::center_x}


        
X coord of the point we want to display at the center of the screen. This is typically our main cursor if we're using the keyboard to move it. Unit is map slot.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {center_y}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::center_y}


        
Y coord of the point we want to display at the center of the screen. This is typically our main cursor if we're using the keyboard to move it. Unit is map slot.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {old_center_x}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::old_center_x}


        
Previous X coord of the point we wanted to display at the center of the screen. This is typically our main cursor if we're using the keyboard to move it. Unit is map slot.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {old_center_y}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::old_center_y}


        
Previous Y coord of the point we wanted to display at the center of the screen. This is typically our main cursor if we're using the keyboard to move it. Unit is map slot.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {speed_x}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::speed_x}


        
Speed at which the viewport is moving on the X axis, unit is map slot per second.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {speed_y}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_viewport_s::speed_y}


        
Speed at which the viewport is moving on the Y axis, unit is map slot per second.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {x_polarity}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_viewport_s::x_polarity}


X-polarity parameter (1=on, 0=off, -1=invert).         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {y_polarity}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_viewport_s::y_polarity}


Y-polarity parameter (1=on, 0=off, -1=invert).         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {x_wrap}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_viewport_s::x_wrap}


Wether to wrap map on the X axis.         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {y_wrap}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6gui_viewport_s::y_wrap}


Wether to wrap map on the Y axis.         
        
@end defcv

@defcv {Member} {lw6gui_viewport_s} {drawable}
@strong{Type:} @code{lw6gui_zone_t}

@strong{Definition:} @code{lw6gui_zone_t lw6gui_viewport_s::drawable}


        
Drawable zone, this is the physical on-screen viewport. Unit is pixels.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {map_main}
@strong{Type:} @code{lw6gui_zone_t}

@strong{Definition:} @code{lw6gui_zone_t lw6gui_viewport_s::map_main}


        
Zone corresponding to the map, if it was to be drawn as a whole, regardless of drawable size, wrapping and polarity.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {map_main_clipped}
@strong{Type:} @code{lw6gui_zone_t}

@strong{Definition:} @code{lw6gui_zone_t lw6gui_viewport_s::map_main_clipped}


        
Zone corresponding to the map, only the main map, ignoring wrapping and polarity, but clipped with drawable zone.         
@end defcv

@defcv {Member} {lw6gui_viewport_s} {map_visible}
@strong{Type:} @code{lw6gui_zone_t}

@strong{Definition:} @code{lw6gui_zone_t lw6gui_viewport_s::map_visible}


        
Actual visible zone of the map, including wrapping, polarity, and drawable clip aware.         
@end defcv



  
@deftp {Struct} {lw6gui_zone_s}

    
A basic rectangle data. The idea is to store both corner positions and width and height to cache the values and avoid always recalculating them. Values are float based, for an integer point equivalent, see the rect struct.     
@end deftp

@defcv {Member} {lw6gui_zone_s} {x1}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::x1}


Top-left corner X position.         
        
@end defcv

@defcv {Member} {lw6gui_zone_s} {y1}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::y1}


Top-left corner Y position.         
        
@end defcv

@defcv {Member} {lw6gui_zone_s} {x2}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::x2}


Bottom-right corner X position.         
        
@end defcv

@defcv {Member} {lw6gui_zone_s} {y2}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::y2}


Bottom-right corner Y position.         
        
@end defcv

@defcv {Member} {lw6gui_zone_s} {w}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::w}


Width.         
        
@end defcv

@defcv {Member} {lw6gui_zone_s} {h}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6gui_zone_s::h}


Height.         
        
@end defcv


