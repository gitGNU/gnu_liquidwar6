

  
@deftp {Struct} {lw6sys_assoc_s}

    
    
@end deftp

@defcv {Member} {lw6sys_assoc_s} {key}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_assoc_s::key}


        
        
@end defcv

@defcv {Member} {lw6sys_assoc_s} {value}
@strong{Type:} @code{void *}

@strong{Definition:} @code{void* lw6sys_assoc_s::value}


        
        
@end defcv

@defcv {Member} {lw6sys_assoc_s} {free_func}
@strong{Type:} @code{lw6sys_free_func_t}

@strong{Definition:} @code{lw6sys_free_func_t lw6sys_assoc_s::free_func}


        
        
@end defcv

@defcv {Member} {lw6sys_assoc_s} {next_item}
@strong{Type:} @code{void *}

@strong{Definition:} @code{void* lw6sys_assoc_s::next_item}


        
        
@end defcv



  
@deftp {Struct} {lw6sys_color_8_s}

    
Used to store colors when representing them in RGBA mode with integers ranging from 0 to 255.     
@end deftp

@defcv {Member} {lw6sys_color_8_s} {r}
@strong{Type:} @code{u_int8_t}

@strong{Definition:} @code{u_int8_t lw6sys_color_8_s::r}


Red [0 ... 255].         
        
@end defcv

@defcv {Member} {lw6sys_color_8_s} {g}
@strong{Type:} @code{u_int8_t}

@strong{Definition:} @code{u_int8_t lw6sys_color_8_s::g}


Green [0 ... 255].         
        
@end defcv

@defcv {Member} {lw6sys_color_8_s} {b}
@strong{Type:} @code{u_int8_t}

@strong{Definition:} @code{u_int8_t lw6sys_color_8_s::b}


Blue [0 ... 255].         
        
@end defcv

@defcv {Member} {lw6sys_color_8_s} {a}
@strong{Type:} @code{u_int8_t}

@strong{Definition:} @code{u_int8_t lw6sys_color_8_s::a}


Alpha [0 ... 255]. 255 is opaque, 0 is transparent.         
        
@end defcv



  
@deftp {Struct} {lw6sys_color_f_s}

    
Used to store colors when representing them in RGBA mode with floats ranging from 0.0f to 1.0f.     
@end deftp

@defcv {Member} {lw6sys_color_f_s} {r}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_f_s::r}


Red [0 ... 1.0f].         
        
@end defcv

@defcv {Member} {lw6sys_color_f_s} {g}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_f_s::g}


Green [0 ... 1.0f].         
        
@end defcv

@defcv {Member} {lw6sys_color_f_s} {b}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_f_s::b}


Blue [0 ... 1.0f].         
        
@end defcv

@defcv {Member} {lw6sys_color_f_s} {a}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_f_s::a}


Alpha [0 ... 1.0f]. 1.0f is opaque, 0.0f is transparent.         
        
@end defcv



  
@deftp {Struct} {lw6sys_color_hsv_s}

    
Used to store colors when representing them in HSV mode with floats ranging from 0.0f to 1.0f. An alpha channel has been added so this is more HSVA than HSV.     
@end deftp

@defcv {Member} {lw6sys_color_hsv_s} {h}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_hsv_s::h}


Hue [0 ... 360.0f]. 0.0f is red, 120.0f is green, 240.0f is blue.         
        
@end defcv

@defcv {Member} {lw6sys_color_hsv_s} {s}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_hsv_s::s}


Saturation [0 ... 1.0f].         
        
@end defcv

@defcv {Member} {lw6sys_color_hsv_s} {v}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_hsv_s::v}


Value [0 ... 1.0f].         
        
@end defcv

@defcv {Member} {lw6sys_color_hsv_s} {a}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_color_hsv_s::a}


Alpha [0 ... 1.0f]. 1.0f is opaque, 0.0f is transparent.         
        
@end defcv



  
@deftp {Struct} {lw6sys_hash_s}

    
    
@end deftp

@defcv {Member} {lw6sys_hash_s} {size}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6sys_hash_s::size}


        
        
@end defcv

@defcv {Member} {lw6sys_hash_s} {entries}
@strong{Type:} @code{lw6sys_assoc_t **}

@strong{Definition:} @code{lw6sys_assoc_t** lw6sys_hash_s::entries}


        
        
@end defcv

@defcv {Member} {lw6sys_hash_s} {free_func}
@strong{Type:} @code{lw6sys_free_func_t}

@strong{Definition:} @code{lw6sys_free_func_t lw6sys_hash_s::free_func}


        
        
@end defcv



  
@deftp {Struct} {lw6sys_hexa_serializer_s}

    
    
@end deftp

@defcv {Member} {lw6sys_hexa_serializer_s} {buf}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_hexa_serializer_s::buf}


        
        
@end defcv

@defcv {Member} {lw6sys_hexa_serializer_s} {buf_size}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6sys_hexa_serializer_s::buf_size}


        
        
@end defcv

@defcv {Member} {lw6sys_hexa_serializer_s} {pos}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6sys_hexa_serializer_s::pos}


        
        
@end defcv



  
@deftp {Struct} {lw6sys_list_s}

    
    
@end deftp

@defcv {Member} {lw6sys_list_s} {data}
@strong{Type:} @code{void *}

@strong{Definition:} @code{void* lw6sys_list_s::data}


        
        
@end defcv

@defcv {Member} {lw6sys_list_s} {free_func}
@strong{Type:} @code{lw6sys_free_func_t}

@strong{Definition:} @code{lw6sys_free_func_t lw6sys_list_s::free_func}


        
        
@end defcv

@defcv {Member} {lw6sys_list_s} {next_item}
@strong{Type:} @code{void *}

@strong{Definition:} @code{void* lw6sys_list_s::next_item}


        
        
@end defcv



  
@deftp {Struct} {lw6sys_module_pedigree_s}

    
Structure used to store informations about a module. This describes the module, its author license, this is both a legal check and a technical check, to maximize the chances the code we're running is the right one, and to trace it.     
@end deftp

@defcv {Member} {lw6sys_module_pedigree_s} {id}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::id}


Module id, for instance, could be "gl".         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {category}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::category}


Module category, for instance, could be "gfx".         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {name}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::name}


Module name, readable (displayable) name.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {readme}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::readme}


Module readme text.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {version}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::version}


Module version.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {copyright}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::copyright}


Module (short) copyright information.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {license}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::license}


Module (short) license.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {date}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::date}


Date of module compilation.         
        
@end defcv

@defcv {Member} {lw6sys_module_pedigree_s} {time}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_module_pedigree_s::time}


Time of module compilation.         
        
@end defcv



  
@deftp {Struct} {lw6sys_progress_s}

    
Structure used to store progress information. The idea is that is that must be usable in polling mode or in multithreaded mode, and we must be able to truncate a progress indicator into several stages. So this structure contains a range start, a range end, and its value between those two, which is meant to be written by the code executing the operation and read by the caller/rendering thread.     
@end deftp

@defcv {Member} {lw6sys_progress_s} {min}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_progress_s::min}


Where the progress operation starts.         
        
@end defcv

@defcv {Member} {lw6sys_progress_s} {max}
@strong{Type:} @code{float}

@strong{Definition:} @code{float lw6sys_progress_s::max}


Where the progress operation ends.         
        
@end defcv

@defcv {Member} {lw6sys_progress_s} {value}
@strong{Type:} @code{float *}

@strong{Definition:} @code{volatile float* lw6sys_progress_s::value}


Somewhere between min and max.         
        
@end defcv



  
@deftp {Struct} {lw6sys_url_s}

    
    
@end deftp

@defcv {Member} {lw6sys_url_s} {use_ssl}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6sys_url_s::use_ssl}


        
        
@end defcv

@defcv {Member} {lw6sys_url_s} {host}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_url_s::host}


        
        
@end defcv

@defcv {Member} {lw6sys_url_s} {port}
@strong{Type:} @code{int}

@strong{Definition:} @code{int lw6sys_url_s::port}


        
        
@end defcv

@defcv {Member} {lw6sys_url_s} {uri}
@strong{Type:} @code{char *}

@strong{Definition:} @code{char* lw6sys_url_s::uri}


        
        
@end defcv



  
@deftp {Struct} {lw6sys_whd_s}

    
Contains the shape of a 3D box. There are 3 differences with its "XYZ" equivalent. First, sometimes w*h*d reads better than x,y,z. Then, xyz is signed, whd is unsigned. Finally, these are real int32 values, they are not 14-bit limited. It does not really cost any memory for it's usually used as a single "shape" attribute for a whole map. At the same time, it's very often used as a test value in loops, so it's interesting to have it in a value that's easy to optimize for the compiler (exactly one register...)     
@end deftp

@defcv {Member} {lw6sys_whd_s} {w}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6sys_whd_s::w}


Width.         
        
@end defcv

@defcv {Member} {lw6sys_whd_s} {h}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6sys_whd_s::h}


Height.         
        
@end defcv

@defcv {Member} {lw6sys_whd_s} {d}
@strong{Type:} @code{u_int32_t}

@strong{Definition:} @code{u_int32_t lw6sys_whd_s::d}


Depth.         
        
@end defcv



  
@deftp {Struct} {lw6sys_xyz_s}

    
All-in 32 bit 3D position, to save memory.It's a deliberate choice in Liquid War to handle "limited size" levels. In fact 14 bits still allows 8000x8000 maps, which are at least 100 times too slow to play now (2008). Should we follow Moore's law we'd have at least 6 years until those are playable, and well, until then, let's wait. The point is that storing this information (x*y) on 4 bytes might be very important in some cases, since it can reduce memory footprint on structs which are stored in numerous quantities, and therefore maximize chances that we use level 1 &amp; 2 caches and other nice things which happen when memory consumption is not too high.Point is: why use INT32 and then limit it to 14 bits instead of using an INT16 or short in the first place? Answer: it's easier to handle INT32 all the time in the rest of the code. Compiler and CPU might even handle that better than short. Then, and only when data will be read/written in the struct will it be truncated. Typical example is: we want to multiplicate y by w (which is a width). Result is beyond INT16/short scope but we want to handle it! Casting everything to INT32/int is a pain. With this int y:14 trick, we use y as a "full-featured" INT32/int and well, when it will be read/written we'll loose values over 8191, but we simply do not care.     
@end deftp

@defcv {Member} {lw6sys_xyz_s} {x}
@strong{Type:} @code{int32_t}

@strong{Definition:} @code{int32_t lw6sys_xyz_s::x}


X position, from -8192 to +8191.         
        
@end defcv

@defcv {Member} {lw6sys_xyz_s} {y}
@strong{Type:} @code{int32_t}

@strong{Definition:} @code{int32_t lw6sys_xyz_s::y}


Y position, from -8192 to +8191.         
        
@end defcv

@defcv {Member} {lw6sys_xyz_s} {z}
@strong{Type:} @code{int32_t}

@strong{Definition:} @code{int32_t lw6sys_xyz_s::z}


Z position, from -8 to +7.         
        
@end defcv


