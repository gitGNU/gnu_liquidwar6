@deftypefun {int} {lw6net_dns_is_ip} (char * @var{ip})
@var{ip}:  the string to check

Tests if a given string is a valid IP (IPV4). Test is only syntaxic,
it's just to know if we're likely to need to query the DNS, it does not
mean the IP is *really* valid.

@strong{Return value:}  1 if it's an IP, O if not.
@end deftypefun

@deftypefun {char *} {lw6net_dns_gethostbyname} (char * @var{name})
@var{name}:  name of the host

A wrapper over the standard gethostbyname function, will even accept
an IP as an input (in this case, will copy it...) and 
allocate a new string for the result.

@strong{Return value:}  an IP if success, 0 on error.
@end deftypefun

@deftypefun {int} {lw6net_last_error} ()

Reports the last network error. This is basically a debug function,
designed mostly for Microsoft Winsock API, but can be safely called
on any platform.

@strong{Return value:}  the last error code, has no universal meaning, depends
on the platform you're working on.
@end deftypefun

@deftypefun {char *} {lw6net_if_guess_local} ()

Guess the local IP address. This is not fool-proof,
and it probably cannot be as we can't handle all
user-specific configs involving multiple IP addresses,
virtual private networks, and so on. But this is just
to provide a default public IP address when starting
a network game, saavy users can always specify the right
interface/address if needed. Will return NULL if interface
can't be guessed.

@strong{Return value:}  the IP as a string, dynamically allocated
@end deftypefun

@deftypefun {char *} {lw6net_if_guess_public_url} (char * @var{bind_ip}, int @var{bind_port})
@var{bind_ip}:  the IP address used to bind on

@var{bind_port}:  the IP port used to bind on

Guess the server public url, based 
on @code{lw6net_if_guess_local} which tries to find a
valid local IP address which is not loopback. This is only
in case @code{bind_ip} is 0.0.0.0 (listen on all addresses) else
it will just use @code{bind_ip} as you would expect.
Function isn't foolproof, that's why one can override
its default with a user settings.

@strong{Return value:}  the IP as a string, dynamically allocated
@end deftypefun

@deftypefun {char *} {lw6net_recv_line_tcp} (int @var{sock})
@var{sock}:  the socket descriptor

Receives a line terminated by LF ("\n", chr(10)) or
CR/LF ("\r\n", chr(10)chr(13)) on a TCP socket, that is,
stream oriented. If there's no complete line
available, function returns immediately with NULL. Same
if socket is closed, broken, whatever. Only if there's
something consistent will the function return non-NULL.

@strong{Return value:}  a dynamically allocated string with the
content received. The tailing (CR)/LF is stripped.
@end deftypefun

@deftypefun {int} {lw6net_send_line_tcp} (int @var{sock}, char * @var{line})
@var{sock}:  the socket descriptor

@var{line}:  the line to be sent, without the "\n" at the end

Sends a line terminated by LF ("\n", chr(10)) on a TCP
socket, that is, stream oriented. The "\n" is automatically
added, do not bother sending it.

@strong{Return value:}  non-zero if success
@end deftypefun

@deftypefun {char *} {lw6net_recv_line_udp} (int @var{sock}, char ** @var{incoming_ip}, int * @var{incoming_port})
@var{sock}:  the socket descriptor

@var{incoming_ip}:  the IP address of the sender (returned)

@var{incoming_port}:  the IP port of the sender (returned)

Receives a line terminated by LF ("\n", chr(10)) or
CR/LF ("\r\n", chr(10)chr(13)) on a UDP socket, that is,
datagram oriented. If there's no complete line
available, function returns immediately with NULL. Same
if socket is closed, broken, whatever. Only if there's
something consistent will the function return non-NULL.
By-value parameters allow the caller to know where the
data come from.

@strong{Return value:}  a dynamically allocated string with the
content received. The tailing (CR)/LF is stripped.
@end deftypefun

@deftypefun {int} {lw6net_send_line_udp} (int @var{sock}, char * @var{line}, char * @var{ip}, int @var{port})
@var{sock}:  the socket descriptor

@var{line}:  the line to be sent, without the "\n" at the end

@var{ip}:  the IP address of the target

@var{port}:  the IP port of the target

Sends a line terminated by LF ("\n", chr(10)) on a UDP
socket, that is, datagram oriented. The "\n" is automatically
added, do not bother sending it.

@strong{Return value:}  the number of bytes sent, 0 if failure
@end deftypefun

@deftypefun {int} {lw6net_init} (int @var{argc}, char * [] @var{argv})

Initializes the low-level network API, you must call this before
calling any other network related function, for it allocates a dynamic
context which is in turn used by every function.

@strong{Return value:}  non-zero if success
@end deftypefun

@deftypefun {void} {lw6net_quit} ()

Frees memory, joins active threads, and releases everything
set up by network code.

@strong{Return value:}  void
@end deftypefun

@deftypefun {int} {lw6net_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{net} module test suite. This one could fail if some
sockets are already bound, for instance. It's still run even
in check-only (mode=0) mode.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

