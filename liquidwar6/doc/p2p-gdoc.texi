@deftypefun {lw6p2p_db_t *} {lw6p2p_db_open} (int @var{argc}, char * [] @var{argv}, char * @var{name})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{name}:  the database name

Creates a new database object. Normally there's only one object
like this at a given time, it can be shared among various nodes.
The database name is appended to user directory path, this allows
different databases to be created, in theory.

@strong{Return value:}  a pointer on the newly created object.
@end deftypefun

@deftypefun {void} {lw6p2p_db_close} (lw6p2p_db_t * @var{db})
@var{db}:  the db to close

Closes a db object, memory ressources will be freed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {char *} {lw6p2p_db_repr} (lw6p2p_db_t * @var{db})
@var{db}:  the db to work on

Gives a readable representation of the db

@strong{Return value:}  a dynamically allocated string
@end deftypefun

@deftypefun {int} {lw6p2p_db_reset} (int @var{argc}, char * [] @var{argv}, char * @var{name})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{name}:  the database name

Clears the database. Simply removes the db file, in fact. Do
not call while database is used...

@strong{Return value:}  1 on success, 0 if failed.
@end deftypefun

@deftypefun {char *} {lw6p2p_db_default_name} ()

Returns the default database name, should be p2p.db (this is a relative path,
not an absolute path, will be appended to user dir).

@strong{Return value:}  the default database name, need not (must not) be freed.
@end deftypefun

@deftypefun {int} {_lw6p2p_db_now} (_lw6p2p_db_t * @var{db})
@var{db}:  the db object concerned (used to calculate time origin)

Returns a timestamp suitable for db usage. The reason we don't use
regular timestamps is that they are 1) too accurate (msec is useless
for what's involved here) and 2) too big and likely to be negative
in signed mode even if converted to seconds.

@strong{Return value:}  a timestamp, 0 means "beginning of program" (think of it as uptime)
@end deftypefun

@deftypefun {lw6p2p_node_t *} {lw6p2p_node_new} (int @var{argc}, char * [] @var{argv}, lw6p2p_db_t * @var{db}, char * @var{client_backends}, char * @var{server_backends}, char * @var{bind_ip}, int @var{bind_port}, int @var{broadcast}, char * @var{public_url}, char * @var{title}, char * @var{description}, char * @var{password}, int @var{bench}, int @var{open_relay}, char * @var{known_nodes}, int @var{network_reliability}, int @var{trojan})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{db}:  the database to use

@var{client_backends}:  the list of client backends to use

@var{server_backends}:  the list of server backends to use

@var{bind_ip}:  the IP address to bind on

@var{bind_port}:  the IP port to listen on

@var{broadcast}:  wether broadcast is allowed on this node

@var{public_url}:  the public URL we want to show

@var{title}:  the title of the node

@var{description}:  the description of the node

@var{password}:  the password to use

@var{bench}:  the bench of the node (its power)

@var{open_relay}:  act as an open relay or not

@var{known_nodes}:  list of already known nodes

@var{network_reliability}:  drop 1 packet out of X

@var{trojan}:  act as a stupid trojan to test out automatic kick-off 

Creates a new "pear to pear" node. This will fire the server
and allow client access, on demand. A lot of stuff can be done
in the background once this is called.

@strong{Return value:}  a pointer on the newly created objects.
@end deftypefun

@deftypefun {void} {lw6p2p_node_free} (lw6p2p_node_t * @var{node})
@var{node}:  the node to free

Frees a node object, all network communications will be shut.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {char *} {lw6p2p_node_repr} (lw6p2p_node_t * @var{node})
@var{node}:  the node to work on

Gives a readable representation of the node

@strong{Return value:}  a dynamically allocated string
@end deftypefun

@deftypefun {int} {lw6p2p_node_poll} (lw6p2p_node_t * @var{node})
@var{node}:  the node to poll

Polls a p2p node. This must be called on a regular basis, else
network communication is stalled.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {void} {lw6p2p_node_close} (lw6p2p_node_t * @var{node})
@var{node}:  the node to close

Closes a p2p node. Closing is necessary in some contexts, for instance
scheme/smob instanciation when you want to release the object ressources
(sockets, ports, threads...) *before* it is deleted by, for instance,
a garbage collector.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {u_int64_t} {lw6p2p_node_get_id} (lw6p2p_node_t * @var{node})
@var{node}:  the node to query

Returns the node id, an id which is supposed to uniquely identify
the node at run-time.

@strong{Return value:}  numerical id.
@end deftypefun

@deftypefun {int} {lw6p2p_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{p2p} module test suite. This test can fail if one
cannot bind on some network port, in a general manner it is
dependent on the network environment, so it's better if there's
some sort of human control on it.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

