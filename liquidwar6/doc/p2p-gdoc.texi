@deftypefun {lw6p2p_db_t *} {lw6p2p_db_open} (int @var{argc}, char * [] @var{argv}, char * @var{name})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{name}:  the database name

Creates a new database object. Normally there's only one object
like this at a given time, it can be shared among various nodes.
The database name is appended to user directory path, this allows
different databases to be created, in theory.

@strong{Return value:}  a pointer on the newly created object.
@end deftypefun

@deftypefun {void} {lw6p2p_db_close} (lw6p2p_db_t * @var{db})
@var{db}:  the db to close

Closes a db object, memory ressources will be freed.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {char *} {lw6p2p_db_repr} (lw6p2p_db_t * @var{db})
@var{db}:  the db to work on

Gives a readable representation of the db

@strong{Return value:}  a dynamically allocated string
@end deftypefun

@deftypefun {int} {lw6p2p_db_reset} (int @var{argc}, char * [] @var{argv}, char * @var{name})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{name}:  the database name

Clears the database. Simply removes the db file, in fact. Do
not call while database is used...

@strong{Return value:}  1 on success, 0 if failed.
@end deftypefun

@deftypefun {char *} {lw6p2p_db_default_name} ()

Returns the default database name, should be p2p.db (this is a relative path,
not an absolute path, will be appended to user dir).

@strong{Return value:}  the default database name, need not (must not) be freed.
@end deftypefun

@deftypefun {lw6p2p_node_t *} {lw6p2p_node_new} (int @var{argc}, char * [] @var{argv}, lw6p2p_db_t * @var{db}, char * @var{client_backends}, char * @var{server_backends}, char * @var{bind_ip}, int @var{bind_port}, u_int64_t @var{node_id}, char * @var{public_url})
@var{argc}:  number of args, as passed to @code{main}

@var{argv}:  args array, as passed to @code{main}

@var{db}:  the database to use

@var{client_backends}:  the list of client backends to use

@var{server_backends}:  the list of server backends to use

@var{bind_ip}:  the IP address to bind on

@var{bind_port}:  the IP port to listen on

@var{node_id}:  the server unique ID

@var{public_url}:  the public URL we want to show

Creates a new "pear to pear" node. This will fire the server
and allow client access, on demand. A lot of stuff can be done
in the background once this is called.

@strong{Return value:}  a pointer on the newly created objects.
@end deftypefun

@deftypefun {void} {lw6p2p_node_free} (lw6p2p_node_t * @var{node})
@var{node}:  the node to free

Frees a node object, all network communications will be shut.

@strong{Return value:}  none.
@end deftypefun

@deftypefun {char *} {lw6p2p_node_repr} (lw6p2p_node_t * @var{node})
@var{node}:  the node to work on

Gives a readable representation of the node

@strong{Return value:}  a dynamically allocated string
@end deftypefun

@deftypefun {int} {lw6p2p_node_poll} (lw6p2p_node_t * @var{node})
@var{node}:  the node to poll

Polls a p2p node. This must be called on a regular basis, else
network communication is stalled.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {void} {lw6p2p_node_close} (lw6p2p_node_t * @var{node})
@var{node}:  the node to close

Closes a p2p node. Closing is necessary in some contexts, for instance
scheme/smob instanciation when you want to release the object ressources
(sockets, ports, threads...) *before* it is deleted by, for instance,
a garbage collector.

@strong{Return value:}  1 on success, 0 on error.
@end deftypefun

@deftypefun {int} {lw6p2p_test} (int @var{mode})
@var{mode}:  0 for check only, 1 for full test

Runs the @code{p2p} module test suite. This test can fail if one
cannot bind on some network port, in a general manner it is
dependent on the network environment, so it's better if there's
some sort of human control on it.

@strong{Return value:}  1 if test is successfull, 0 on error.
@end deftypefun

